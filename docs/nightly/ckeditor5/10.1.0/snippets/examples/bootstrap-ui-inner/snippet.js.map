{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./packages/ckeditor5-utils/src/ckeditorerror.js","webpack:///./packages/ckeditor5-utils/src/log.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_root.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_checkGlobal.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/buildin/global.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isBuffer.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/constant.js","webpack:///./packages/ckeditor5-widget/theme/icons/drag-handler.svg","webpack:///./packages/ckeditor5-core/theme/icons/check.svg","webpack:///./packages/ckeditor5-core/theme/icons/cancel.svg","webpack:///./packages/ckeditor5-core/theme/icons/low-vision.svg","webpack:///./packages/ckeditor5-core/theme/icons/image.svg","webpack:///./packages/ckeditor5-image/theme/icons/image_placeholder.svg","webpack:///./packages/ckeditor5-utils/src/version.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getPrototype.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isHostObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isObjectLike.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isPlainObject.js","webpack:///./packages/ckeditor5-utils/src/config.js","webpack:///./packages/ckeditor5-utils/src/spy.js","webpack:///./packages/ckeditor5-utils/src/eventinfo.js","webpack:///./packages/ckeditor5-utils/src/uid.js","webpack:///./packages/ckeditor5-utils/src/priorities.js","webpack:///./packages/ckeditor5-utils/src/emittermixin.js","webpack:///./packages/ckeditor5-utils/src/mix.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_listCacheClear.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/eq.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_assocIndexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_listCacheDelete.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_listCacheGet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_listCacheHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_listCacheSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_ListCache.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stackClear.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stackDelete.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stackGet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stackHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isFunction.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_toSource.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isNative.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getNative.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_nativeCreate.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hashClear.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hashDelete.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hashGet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hashHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hashSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Hash.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Map.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapCacheClear.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isKeyable.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getMapData.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapCacheDelete.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapCacheGet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapCacheHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapCacheSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_MapCache.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stackSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Stack.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayEach.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_assignValue.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_copyObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseKeys.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseTimes.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseProperty.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getLength.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isLength.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isArrayLike.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isArrayLikeObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isArguments.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isString.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_indexKeys.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isPrototype.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/keys.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseAssign.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneBuffer.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_copyArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getSymbols.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_copySymbols.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayPush.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseGetAllKeys.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getAllKeys.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_DataView.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Promise.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Set.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_WeakMap.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getTag.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_initCloneArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Uint8Array.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneArrayBuffer.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneDataView.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_addMapEntry.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayReduce.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_mapToArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneMap.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneRegExp.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_addSetEntry.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_setToArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Symbol.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneSymbol.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cloneTypedArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_initCloneByTag.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseCreate.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_initCloneObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseClone.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/clone.js","webpack:///./packages/ckeditor5-utils/src/comparearrays.js","webpack:///./packages/ckeditor5-engine/src/view/node.js","webpack:///./packages/ckeditor5-engine/src/view/text.js","webpack:///./packages/ckeditor5-engine/src/view/textproxy.js","webpack:///./packages/ckeditor5-utils/src/objecttomap.js","webpack:///./packages/ckeditor5-utils/src/isiterable.js","webpack:///./packages/ckeditor5-engine/src/view/matcher.js","webpack:///./packages/ckeditor5-engine/src/view/element.js","webpack:///./packages/ckeditor5-engine/src/view/containerelement.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isIterateeCall.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_apply.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isSymbol.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toNumber.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toFinite.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toInteger.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/rest.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_createAssigner.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_Reflect.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_iteratorToArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseKeysIn.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/keysIn.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/assignIn.js","webpack:///./packages/ckeditor5-utils/src/observablemixin.js","webpack:///./packages/ckeditor5-engine/src/view/editableelement.js","webpack:///./packages/ckeditor5-engine/src/view/rooteditableelement.js","webpack:///./packages/ckeditor5-engine/src/view/treewalker.js","webpack:///./packages/ckeditor5-engine/src/view/position.js","webpack:///./packages/ckeditor5-engine/src/view/range.js","webpack:///./packages/ckeditor5-utils/src/count.js","webpack:///./packages/ckeditor5-engine/src/view/selection.js","webpack:///./packages/ckeditor5-engine/src/view/documentselection.js","webpack:///./packages/ckeditor5-utils/src/collection.js","webpack:///./packages/ckeditor5-engine/src/view/document.js","webpack:///./packages/ckeditor5-engine/src/view/attributeelement.js","webpack:///./packages/ckeditor5-engine/src/view/emptyelement.js","webpack:///./packages/ckeditor5-utils/src/env.js","webpack:///./packages/ckeditor5-utils/src/keyboard.js","webpack:///./packages/ckeditor5-engine/src/view/uielement.js","webpack:///./packages/ckeditor5-engine/src/view/documentfragment.js","webpack:///./packages/ckeditor5-engine/src/view/writer.js","webpack:///./packages/ckeditor5-engine/src/view/filler.js","webpack:///./packages/ckeditor5-utils/src/diff.js","webpack:///./packages/ckeditor5-utils/src/dom/insertat.js","webpack:///./packages/ckeditor5-utils/src/dom/remove.js","webpack:///./packages/ckeditor5-utils/src/dom/istext.js","webpack:///./packages/ckeditor5-utils/src/dom/isnode.js","webpack:///./packages/ckeditor5-utils/src/fastdiff.js","webpack:///./packages/ckeditor5-engine/src/view/renderer.js","webpack:///./packages/ckeditor5-utils/src/dom/global.js","webpack:///./packages/ckeditor5-utils/src/dom/indexof.js","webpack:///./packages/ckeditor5-utils/src/dom/getancestors.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isElement.js","webpack:///./packages/ckeditor5-engine/src/view/domconverter.js","webpack:///./packages/ckeditor5-utils/src/dom/getcommonancestor.js","webpack:///./packages/ckeditor5-utils/src/dom/iswindow.js","webpack:///./packages/ckeditor5-utils/src/dom/emittermixin.js","webpack:///./packages/ckeditor5-engine/src/view/observer/observer.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_setCacheAdd.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_setCacheHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_SetCache.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arraySome.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_equalArrays.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_equalByTag.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_equalObjects.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isTypedArray.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIsEqualDeep.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIsEqual.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isEqualWith.js","webpack:///./packages/ckeditor5-engine/src/view/observer/mutationobserver.js","webpack:///./packages/ckeditor5-engine/src/view/observer/domeventdata.js","webpack:///./packages/ckeditor5-engine/src/view/observer/domeventobserver.js","webpack:///./packages/ckeditor5-engine/src/view/observer/keyobserver.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/now.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/debounce.js","webpack:///./packages/ckeditor5-engine/src/view/observer/fakeselectionobserver.js","webpack:///./packages/ckeditor5-engine/src/view/observer/selectionobserver.js","webpack:///./packages/ckeditor5-engine/src/view/observer/focusobserver.js","webpack:///./packages/ckeditor5-engine/src/view/observer/compositionobserver.js","webpack:///./packages/ckeditor5-utils/src/dom/isrange.js","webpack:///./packages/ckeditor5-utils/src/dom/getborderwidths.js","webpack:///./packages/ckeditor5-utils/src/dom/rect.js","webpack:///./packages/ckeditor5-utils/src/dom/scroll.js","webpack:///./packages/ckeditor5-engine/src/view/view.js","webpack:///./packages/ckeditor5-utils/src/tomap.js","webpack:///./packages/ckeditor5-engine/src/model/node.js","webpack:///./packages/ckeditor5-engine/src/model/text.js","webpack:///./packages/ckeditor5-engine/src/model/textproxy.js","webpack:///./packages/ckeditor5-engine/src/model/nodelist.js","webpack:///./packages/ckeditor5-engine/src/model/element.js","webpack:///./packages/ckeditor5-engine/src/model/treewalker.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/last.js","webpack:///./packages/ckeditor5-engine/src/model/position.js","webpack:///./packages/ckeditor5-engine/src/model/range.js","webpack:///./packages/ckeditor5-engine/src/conversion/mapper.js","webpack:///./packages/ckeditor5-engine/src/conversion/modelconsumable.js","webpack:///./packages/ckeditor5-engine/src/conversion/downcastdispatcher.js","webpack:///./packages/ckeditor5-engine/src/model/selection.js","webpack:///./packages/ckeditor5-engine/src/model/liverange.js","webpack:///./packages/ckeditor5-engine/src/model/documentselection.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/cloneDeep.js","webpack:///./packages/ckeditor5-engine/src/conversion/downcast-converters.js","webpack:///./packages/ckeditor5-engine/src/controller/editingcontroller.js","webpack:///./packages/ckeditor5-engine/src/conversion/upcast-selection-converters.js","webpack:///./packages/ckeditor5-engine/src/conversion/downcast-selection-converters.js","webpack:///./packages/ckeditor5-core/src/plugincollection.js","webpack:///./packages/ckeditor5-core/src/commandcollection.js","webpack:///./packages/ckeditor5-utils/src/translation-service.js","webpack:///./packages/ckeditor5-utils/src/locale.js","webpack:///./packages/ckeditor5-engine/src/conversion/viewconsumable.js","webpack:///./packages/ckeditor5-engine/src/model/schema.js","webpack:///./packages/ckeditor5-engine/src/conversion/upcastdispatcher.js","webpack:///./packages/ckeditor5-engine/src/conversion/upcast-converters.js","webpack:///./packages/ckeditor5-engine/src/controller/datacontroller.js","webpack:///./packages/ckeditor5-engine/src/conversion/conversion.js","webpack:///./packages/ckeditor5-engine/src/model/operation/operation.js","webpack:///./packages/ckeditor5-engine/src/model/documentfragment.js","webpack:///./packages/ckeditor5-engine/src/model/operation/utils.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/isEqual.js","webpack:///./packages/ckeditor5-engine/src/model/operation/attributeoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/moveoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/reinsertoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/removeoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/insertoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/markeroperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/nooperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/renameoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/rootattributeoperation.js","webpack:///./packages/ckeditor5-engine/src/model/operation/operationfactory.js","webpack:///./packages/ckeditor5-engine/src/model/delta/deltafactory.js","webpack:///./packages/ckeditor5-engine/src/model/delta/delta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/attributedelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/splitdelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/mergedelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/movedelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/removedelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/renamedelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/wrapdelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/unwrapdelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/insertdelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/weakinsertdelta.js","webpack:///./packages/ckeditor5-engine/src/model/operation/transform.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseSlice.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/chunk.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/compact.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isFlattenable.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseFlatten.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/concat.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_indexOfNaN.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIndexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayIncludes.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayIncludesWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayMap.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseUnary.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_cacheHas.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseDifference.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/difference.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIsMatch.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isStrictComparable.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseToPairs.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_setToPairs.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_createToPairs.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toPairs.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_getMatchData.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_matchesStrictComparable.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseMatches.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/memoize.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseToString.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toString.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_stringToPath.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_castPath.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_isKey.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_toKey.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseGet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/get.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseHasIn.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_hasPath.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/hasIn.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseMatchesProperty.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/identity.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_basePropertyDeep.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/property.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIteratee.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/differenceBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/differenceWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/drop.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/dropRight.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseWhile.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/dropRightWhile.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/dropWhile.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseClamp.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/toLength.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseFill.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/fill.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseFindIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/findIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/findLastIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/head.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/flatten.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/flattenDeep.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/flattenDepth.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/fromPairs.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/indexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/initial.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIntersection.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_castArrayLikeObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/intersection.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/intersectionBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/intersectionWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/join.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/lastIndexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseNth.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/nth.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseIndexOfWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_basePullAll.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/pullAll.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/pull.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/pullAllBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/pullAllWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseAt.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_parent.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_basePullAt.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_compareAscending.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/pullAt.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/remove.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/reverse.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/slice.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseSortedIndexBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseSortedIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedIndexBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedIndexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedLastIndex.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedLastIndexBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedLastIndexOf.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseSortedUniq.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedUniq.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/sortedUniqBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/tail.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/take.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/takeRight.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/takeRightWhile.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/takeWhile.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/noop.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_createSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseUniq.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/union.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/unionBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/unionWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/uniq.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/uniqBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/uniqWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_arrayFilter.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/unzip.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/unzipWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/without.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseXor.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/xor.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/xorBy.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/xorWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/zip.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseZipObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/zipObject.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/_baseSet.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/zipObjectDeep.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/zipWith.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/array.default.js","webpack:///./packages/ckeditor5-engine/src/model/delta/transform.js","webpack:///./packages/ckeditor5-engine/src/model/delta/markerdelta.js","webpack:///./packages/ckeditor5-engine/src/model/delta/basic-transformations.js","webpack:///./packages/ckeditor5-engine/src/model/batch.js","webpack:///./packages/ckeditor5-engine/src/model/delta/rootattributedelta.js","webpack:///./packages/ckeditor5-engine/src/model/operation/detachoperation.js","webpack:///./packages/ckeditor5-engine/src/model/rootelement.js","webpack:///./packages/ckeditor5-engine/src/model/writer.js","webpack:///./packages/ckeditor5-engine/src/model/differ.js","webpack:///./packages/ckeditor5-engine/src/model/history.js","webpack:///./packages/ckeditor5-utils/src/unicode.js","webpack:///./packages/ckeditor5-engine/src/model/document.js","webpack:///./packages/ckeditor5-engine/src/model/markercollection.js","webpack:///./packages/ckeditor5-engine/src/model/liveposition.js","webpack:///./packages/ckeditor5-engine/src/model/utils/insertcontent.js","webpack:///./packages/ckeditor5-engine/src/model/utils/deletecontent.js","webpack:///./packages/ckeditor5-engine/src/model/utils/modifyselection.js","webpack:///./packages/ckeditor5-engine/src/model/utils/getselectedcontent.js","webpack:///./packages/ckeditor5-engine/src/model/utils/selection-post-fixer.js","webpack:///./packages/ckeditor5-engine/src/model/model.js","webpack:///./packages/ckeditor5-utils/src/keystrokehandler.js","webpack:///./packages/ckeditor5-core/src/editingkeystrokehandler.js","webpack:///./packages/ckeditor5-core/src/editor/editor.js","webpack:///./packages/ckeditor5-ui/src/viewcollection.js","webpack:///./packages/ckeditor5-utils/src/lib/lodash/cloneDeepWith.js","webpack:///./packages/ckeditor5-ui/src/template.js","webpack:///./packages/ckeditor5-ui/src/view.js","webpack:///./packages/ckeditor5-ui/src/editorui/editoruiview.js","webpack:///./packages/ckeditor5-utils/src/focustracker.js","webpack:///./packages/ckeditor5-ui/src/componentfactory.js","webpack:///./packages/ckeditor5-ui/src/editableui/editableuiview.js","webpack:///./packages/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js","webpack:///./packages/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js","webpack:///./packages/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js","webpack:///./packages/ckeditor5-utils/src/elementreplacer.js","webpack:///./packages/ckeditor5-core/src/editor/utils/dataapimixin.js","webpack:///./packages/ckeditor5-core/src/editor/utils/elementapimixin.js","webpack:///./packages/ckeditor5-utils/src/dom/setdatainelement.js","webpack:///./packages/ckeditor5-core/src/plugin.js","webpack:///./packages/ckeditor5-clipboard/src/datatransfer.js","webpack:///./packages/ckeditor5-clipboard/src/clipboardobserver.js","webpack:///./packages/ckeditor5-clipboard/src/utils/viewtoplaintext.js","webpack:///./packages/ckeditor5-core/src/command.js","webpack:///./packages/ckeditor5-enter/src/entercommand.js","webpack:///./packages/ckeditor5-enter/src/enterobserver.js","webpack:///./packages/ckeditor5-typing/src/utils/changebuffer.js","webpack:///./packages/ckeditor5-typing/src/inputcommand.js","webpack:///./packages/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling.js","webpack:///./packages/ckeditor5-typing/src/utils/utils.js","webpack:///./packages/ckeditor5-utils/src/difftochanges.js","webpack:///./packages/ckeditor5-typing/src/utils/injecttypingmutationshandling.js","webpack:///./packages/ckeditor5-typing/src/input.js","webpack:///./packages/ckeditor5-typing/src/deletecommand.js","webpack:///./packages/ckeditor5-typing/src/deleteobserver.js","webpack:///./packages/ckeditor5-typing/src/utils/injectandroidbackspacemutationshandling.js","webpack:///./packages/ckeditor5-typing/src/delete.js","webpack:///./packages/ckeditor5-utils/src/first.js","webpack:///./packages/ckeditor5-paragraph/src/paragraphcommand.js","webpack:///./packages/ckeditor5-paragraph/src/paragraph.js","webpack:///./packages/ckeditor5-undo/src/basecommand.js","webpack:///./packages/ckeditor5-undo/src/undocommand.js","webpack:///./packages/ckeditor5-undo/src/redocommand.js","webpack:///./packages/ckeditor5-basic-styles/src/attributecommand.js","webpack:///./packages/ckeditor5-basic-styles/src/bold/boldediting.js","webpack:///./packages/ckeditor5-basic-styles/src/italic/italicediting.js","webpack:///./packages/ckeditor5-basic-styles/src/underline/underlineediting.js","webpack:///./packages/ckeditor5-heading/src/headingcommand.js","webpack:///./packages/ckeditor5-heading/src/headingediting.js","webpack:///./packages/ckeditor5-core/src/pendingactions.js","webpack:///./packages/ckeditor5-upload/src/filereader.js","webpack:///./packages/ckeditor5-upload/src/filerepository.js","webpack:///./node_modules/@ckeditor/ckeditor-cloud-services-core/src/uploadgateway/fileuploader.js","webpack:///./node_modules/@ckeditor/ckeditor-cloud-services-core/src/token/token.js","webpack:///./packages/ckeditor5-cloud-services/src/cloudservices.js","webpack:///./packages/ckeditor5-easy-image/src/cloudservicesuploadadapter.js","webpack:///./node_modules/@ckeditor/ckeditor-cloud-services-core/src/uploadgateway/uploadgateway.js","webpack:///./packages/ckeditor5-image/src/image/imageloadobserver.js","webpack:///./packages/ckeditor5-image/src/image/converters.js","webpack:///./packages/ckeditor5-widget/src/highlightstack.js","webpack:///./packages/ckeditor5-ui/src/icon/iconview.js","webpack:///./packages/ckeditor5-widget/src/utils.js","webpack:///./packages/ckeditor5-image/src/image/utils.js","webpack:///./packages/ckeditor5-image/src/image/imageediting.js","webpack:///./packages/ckeditor5-engine/src/view/observer/mouseobserver.js","webpack:///./packages/ckeditor5-widget/src/widget.js","webpack:///./packages/ckeditor5-image/src/imagetextalternative/imagetextalternativecommand.js","webpack:///./packages/ckeditor5-image/src/imagetextalternative/imagetextalternativeediting.js","webpack:///./packages/ckeditor5-ui/src/tooltip/tooltipview.js","webpack:///./packages/ckeditor5-ui/src/button/buttonview.js","webpack:///./packages/ckeditor5-ui/src/label/labelview.js","webpack:///./packages/ckeditor5-ui/src/labeledinput/labeledinputview.js","webpack:///./packages/ckeditor5-ui/src/inputtext/inputtextview.js","webpack:///./packages/ckeditor5-ui/src/focuscycler.js","webpack:///./packages/ckeditor5-image/src/imagetextalternative/ui/textalternativeformview.js","webpack:///./packages/ckeditor5-ui/src/bindings/submithandler.js","webpack:///./packages/ckeditor5-utils/src/dom/position.js","webpack:///./packages/ckeditor5-ui/src/panel/balloon/balloonpanelview.js","webpack:///./packages/ckeditor5-utils/src/dom/tounit.js","webpack:///./packages/ckeditor5-utils/src/dom/getpositionedancestor.js","webpack:///./packages/ckeditor5-ui/src/panel/balloon/contextualballoon.js","webpack:///./packages/ckeditor5-image/src/image/ui/utils.js","webpack:///./packages/ckeditor5-image/src/imagetextalternative/imagetextalternativeui.js","webpack:///./packages/ckeditor5-ui/src/bindings/clickoutsidehandler.js","webpack:///./packages/ckeditor5-image/src/imagetextalternative.js","webpack:///./packages/ckeditor5-image/src/image.js","webpack:///./packages/ckeditor5-upload/src/ui/filedialogbuttonview.js","webpack:///./packages/ckeditor5-image/src/imageupload/utils.js","webpack:///./packages/ckeditor5-image/src/imageupload/imageuploadui.js","webpack:///./packages/ckeditor5-image/src/imageupload/imageuploadprogress.js","webpack:///./packages/ckeditor5-image/src/imageupload/imageuploadcommand.js","webpack:///./packages/ckeditor5-ui/src/notification/notification.js","webpack:///./packages/ckeditor5-image/src/imageupload/imageuploadediting.js","webpack:///./packages/ckeditor5-image/src/imageupload.js","webpack:///./packages/ckeditor5-cloud-services/tests/_utils/cloud-services-config.js","webpack:///./node_modules/umberto/hexo/source/ckeditor5/10.1.0/_snippets/examples/bootstrap-ui-inner.js","webpack:///./packages/ckeditor5-core/src/editor/utils/attachtoform.js","webpack:///./packages/ckeditor5-utils/src/dom/getdatafromelement.js","webpack:///./packages/ckeditor5-clipboard/src/clipboard.js","webpack:///./packages/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js","webpack:///./packages/ckeditor5-clipboard/src/utils/plaintexttohtml.js","webpack:///./packages/ckeditor5-enter/src/enter.js","webpack:///./packages/ckeditor5-typing/src/typing.js","webpack:///./packages/ckeditor5-easy-image/src/easyimage.js","webpack:///./packages/ckeditor5-undo/src/undoediting.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","attachLinkToDocumentation","DOCUMENTATION_URL","CKEditorError","Error","[object Object]","message","data","JSON","stringify","super","this","error","matchedErrorName","match","_ckeditorerror__WEBPACK_IMPORTED_MODULE_0__","log","console","warn","objectTypes","function","freeExports","nodeType","undefined","freeModule","freeGlobal","_checkGlobal__WEBPACK_IMPORTED_MODULE_0__","global","freeSelf","self","freeWindow","window","thisGlobal","root","Function","originalModule","webpackPolyfill","children","g","eval","e","Buffer","_root__WEBPACK_IMPORTED_MODULE_1__","isBuffer","_constant__WEBPACK_IMPORTED_MODULE_0__","ckeditor5_package_json__WEBPACK_IMPORTED_MODULE_1__","windowOrGlobal","CKEDITOR_VERSION","_log__WEBPACK_IMPORTED_MODULE_0__","collidingVersion","version","nativeGetPrototype","getPrototypeOf","_getPrototype","_isHostObject","result","toString","lodash_isObjectLike","objectTag","objectProto","funcToString","isPlainObject_hasOwnProperty","objectCtorString","objectToString","lodash_isPlainObject","proto","Ctor","constructor","config_Config","configurations","defaultConfigurations","_config","define","_setObjectToTarget","_setToTarget","_getFromSource","target","isDefine","parts","split","pop","part","source","configuration","keys","forEach","src_spy","spy","called","eventinfo_EventInfo","path","stop","off","uid_uid","uuid","Math","floor","random","substring","src_priorities","priority","normal","highest","high","low","lowest","_listeningTo","_emitterId","event","callback","options","listenTo","args","stopListening","emitter","emitterInfo","eventCallbacks","emitters","_getEmitterId","_setEmitterId","emitterId","callbacks","push","eventName","events","getEvents","childEventName","newEventNodes","childEvents","substr","lastIndexOf","node","slice","createEventNamespace","lists","getCallbacksListsForNamespace","callbackDefinition","added","length","splice","removeCallback","eventOrInfo","eventInfo","getCallbacksForEvent","_events","indexOf","callbackArgs","Array","from","apply","_delegations","destinations","passAllDestinations","fireDelegatedEvents","return","to","nameOrFunction","Map","set","delete","clear","id","eventNode","callbacksLists","childCallbacksLists","concat","fireArgs","delegatedInfo","fire","mix","baseClass","mixins","mixin","getOwnPropertyNames","getOwnPropertySymbols","sourceDescriptor","getOwnPropertyDescriptor","_listCacheClear","__data__","lodash_eq","other","_assocIndexOf","array","_listCacheDelete","index","_listCacheGet","_listCacheHas","_listCacheSet","ListCache","entries","entry","has","_ListCache","_stackClear","_stackDelete","_stackGet","_stackHas","lodash_isObject","type","funcTag","genTag","isFunction_objectToString","lodash_isFunction","tag","_toSource_funcToString","_toSource","func","reIsHostCtor","isNative_objectProto","isNative_funcToString","isNative_hasOwnProperty","reIsNative","RegExp","replace","lodash_isNative","test","_getNative","_nativeCreate","_hashClear","_hashDelete","HASH_UNDEFINED","_hashGet_hasOwnProperty","_hashGet","_hashHas_hasOwnProperty","_hashHas","_hashSet_HASH_UNDEFINED","_hashSet","Hash","_Hash","_Map","_root","_mapCacheClear","hash","map","string","_isKeyable","_getMapData","_mapCacheDelete","_mapCacheGet","_mapCacheHas","_mapCacheSet","MapCache","_MapCache","LARGE_ARRAY_SIZE","_stackSet","cache","Stack","_Stack","_arrayEach","iteratee","_assignValue_hasOwnProperty","_assignValue","objValue","_copyObject","props","customizer","newValue","_baseHas_hasOwnProperty","_baseHas","nativeKeys","_baseKeys","_baseTimes","_baseProperty","_getLength","MAX_SAFE_INTEGER","lodash_isLength","lodash_isArrayLike","lodash_isArrayLikeObject","argsTag","isArguments_objectProto","isArguments_hasOwnProperty","isArguments_objectToString","propertyIsEnumerable","lodash_isArguments","lodash_isArray","isArray","stringTag","isString_objectToString","lodash_isString","_indexKeys","String","_isIndex_MAX_SAFE_INTEGER","reIsUint","_isIndex","_isPrototype_objectProto","_isPrototype","lodash_keys","isProto","indexes","skipIndexes","_baseAssign","_cloneBuffer","buffer","isDeep","copy","_copyArray","getSymbols","_getSymbols","_copySymbols","_arrayPush","values","offset","_baseGetAllKeys","keysFunc","symbolsFunc","_getAllKeys","_DataView","_Promise","_Set","_WeakMap","_getTag_objectToString","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","_getTag","_initCloneArray_hasOwnProperty","_initCloneArray","input","_Uint8Array","Uint8Array","_cloneArrayBuffer","arrayBuffer","byteLength","_cloneDataView","dataView","byteOffset","_addMapEntry","pair","_arrayReduce","accumulator","initAccum","_mapToArray","size","_cloneMap","cloneFunc","reFlags","_cloneRegExp","regexp","exec","lastIndex","_addSetEntry","add","_setToArray","_cloneSet","_Symbol","symbolProto","symbolValueOf","valueOf","_cloneSymbol","symbol","_cloneTypedArray","typedArray","boolTag","dateTag","_initCloneByTag_mapTag","numberTag","regexpTag","_initCloneByTag_setTag","_initCloneByTag_stringTag","symbolTag","arrayBufferTag","_initCloneByTag_dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","_initCloneByTag","objectCreate","_baseCreate","_initCloneObject","_baseClone_argsTag","_baseClone_funcTag","_baseClone_genTag","_baseClone_objectTag","cloneableTags","_baseClone","baseClone","isFull","stack","isArr","isFunc","stacked","subValue","lodash_clone","compareArrays","a","b","minLen","min","node_Node","parent","pos","getChildIndex","ckeditorerror","nextSibling","getChild","previousSibling","document","unshift","includeSelf","parentFirst","ancestors","ancestorsA","getAncestors","ancestorsB","thisPath","getPath","nodePath","isBefore","_removeChildren","_fireChange","json","emittermixin","text_Text","_textData","is","_data","otherNode","textproxy_TextProxy","textNode","offsetInText","offsetSize","isPartial","objectToMap","obj","isIterable","iterator","Matcher","pattern","_patterns","item","classes","element","singleElement","isElementMatching","results","matchName","attributes","patterns","hasAttribute","attribute","getAttribute","matchAttributes","getClassNames","hasClass","matchClasses","styles","hasStyle","style","getStyle","matchStyles","element_Element","attrs","_attrs","parseAttributes","_children","_insertChild","_classes","Set","classString","parseClasses","_styles","parseInlineStyles","_customProperties","childCount","isEmpty","join","styleString","otherElement","className","matcher","sort","deep","childrenClone","child","getChildren","_clone","cloned","getFillerOffset","items","count","nodes","normalize","_remove","howMany","stylesMap","stylesString","quoteType","propertyNameStart","propertyValueStart","propertyName","charAt","char","propertyValue","trim","classesSet","classesString","classArray","containerelement_ContainerElement","lastChild","_isIterateeCall","_apply","thisArg","isSymbol_symbolTag","isSymbol_objectToString","lodash_isSymbol","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","lodash_toNumber","isBinary","INFINITY","MAX_INTEGER","lodash_toFinite","lodash_toInteger","remainder","FUNC_ERROR_TEXT","nativeMax","max","lodash_rest","start","TypeError","arguments","otherArgs","_createAssigner","assigner","sources","guard","_Reflect","Reflect","_iteratorToArray","next","done","_baseKeysIn_objectProto","enumerate","_baseKeysIn_propertyIsEnumerable","baseKeysIn","_baseKeysIn","keysIn_hasOwnProperty","lodash_keysIn","propsLength","nonEnumShadows","lodash_assignIn","observablePropertiesSymbol","boundObservablesSymbol","boundPropertiesSymbol","ObservableMixin","initObservable","properties","configurable","oldValue","bindProperties","isStringArray","boundProperties","bindings","binding","bindTo","toMany","bindToMany","_observable","_bindProperties","_to","_bindings","unbindProperties","boundObservables","toObservable","toProperty","toProperties","toPropertyBindings","boundObservable","methodName","originalMethod","on","evt","observablemixin","observable","parsedArgs","parsed","lastObservable","parseBindToArgs","bindingsKeys","numberOfBindings","toBindings","updateBoundObservableProperty","attachBindToListeners","chain","toPropertyName","bindingsToObservable","updateBoundObservables","updateBindToBound","observables","observableAndAttributePairs","getBindingTargets","arr","every","documentSymbol","editableelement_EditableElement","getCustomProperty","_document","_setCustomProperty","isFocused","selection","editableElement","rootNameSymbol","rooteditableelement_RootEditableElement","rootName","_name","treewalker_TreeWalker","boundaries","startPosition","direction","position","position_Position","createFromPosition","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","_boundaryEndParent","end","skip","prevPosition","_next","_previous","previousPosition","isAtEnd","createAfter","_formatReturnValue","charactersCount","textLength","textProxy","isAtStart","createBefore","startOffset","nextPosition","isEqual","nodeAfter","nodeBefore","endOffset","editable","shift","shifted","treeWalker","otherPosition","compareWith","otherPath","itemOrPosition","range_Range","isCollapsed","isFlat","getLastMatchingPosition","enlargeTrimSkip","isAfter","nodeAfterStart","nodeBeforeEnd","otherRange","loose","containsStart","containsPosition","containsEnd","ranges","isIntersecting","createFromRange","commonRangeStart","commonRangeEnd","getCommonAncestor","startElement","endElement","range","getShiftedBy","createFromParentsAndOffsets","createFromPositionAndShift","createAt","count_count","_","selection_Selection","selectable","placeOrOffset","_ranges","_lastRangeBackward","_isFake","_fakeSelectionLabel","setTo","isFake","fakeSelectionLabel","anchor","focus","rangeCount","isBackward","first","last","firstRange","getFirstRange","lastRange","getLastRange","otherSelection","thisRange","found","numOfRangesA","getRanges","rangeA","getTrimmed","rangeB","_setRanges","_setFakeOptions","documentselection_DocumentSelection","fake","label","backward","createIn","createOn","createCollapsedAt","newFocus","_addRange","newRanges","isLastBackward","_pushRange","storedRange","addedRange","intersectingRange","_selection","delegate","getFirstPosition","getLastPosition","getSelectedElement","isSimilar","setFocus","collection_Collection","_items","_itemMap","_idProperty","idProperty","_bindToExternalToInternalMap","WeakMap","_bindToInternalToExternalMap","_skippedIndexesFromExternal","itemId","idOrIndex","idOrItem","subject","itemDoesNotExist","externalItem","ctx","find","filter","_bindToCollection","remove","externalCollection","as","Class","_setUpBindToBinding","using","callbackOrProperty","factory","addItem","isExternalBoundToThis","externalItemBound","finalIndex","skipped","getIndex","reduce","document_Document","roots","_postFixers","postFixer","writer","wasFixed","DEFAULT_PRIORITY","attributeelement_AttributeElement","attributeelement_getFillerOffset","_priority","_id","_clonesGroup","nonUiChildrenCount","emptyelement_EmptyElement","emptyelement_getFillerOffset","userAgent","navigator","toLowerCase","src_env","isMac","isEdge","macGlyphsToModifiers","⌘","⇧","⌥","modifiersToMacGlyphs","ctrl","alt","keyCodes","arrowleft","arrowup","arrowright","arrowdown","backspace","enter","space","esc","tab","cmd","code","letter","fromCharCode","generateKnownKeyCodes","getCode","keyCode","altKey","ctrlKey","shiftKey","parseKeystroke","keystroke","splitKeystrokeText","sum","uielement_UIElement","uielement_getFillerOffset","domDocument","toDomElement","domElement","createElement","getAttributeKeys","setAttribute","injectUiElementHandling","view","domConverter","domSelection","domTarget","ownerDocument","defaultView","getSelection","domSelectionCollapsed","getRangeAt","collapsed","domParent","focusNode","domOffset","focusOffset","viewPosition","domPositionToView","jumpedOverAnyUiElement","nextViewPosition","newDomPosition","viewPositionToDom","collapse","extend","jumpOverUiElement","documentfragment_DocumentFragment","documentfragment_normalize","writer_Writer","_cloneGroups","_setTo","_setFocus","attributeElement","renderFunction","uiElement","render","_setAttribute","_removeAttribute","_addClass","_removeClass","_setStyle","_removeStyle","_removeCustomProperty","positionOrRange","_breakAttributes","_breakAttributesRange","newElement","insert","sourceRange","targetPosition","move","positionOffset","positionParent","_removeFromClonedElementsGroup","mergeAttributes","mergeTextNodes","_appendChild","prev","newPosition","validateNodesToInsert","validNodesToInsert","some","validNode","container","getParentContainer","insertionPosition","_addToClonedElementsGroup","endPosition","validateRangeContainer","breakStart","breakEnd","parentContainer","removed","mergePosition","walker","getWalker","current","rangeToRemove","parentElement","ancestor","countBefore","_hasNonUiChildren","_wrapPosition","viewSelection","setSelection","_wrapRange","_unwrapAttributeElement","newRange","_unwrapChildren","viewElement","newName","getAttributes","wrapPositions","isText","isAttribute","isUI","shouldABeOutsideB","newAttribute","_wrapChildren","offsetChange","unwrapPositions","unwrapped","rangeSpansOnAllChildren","_wrapAttributeElement","unwrappedRange","movePositionToTextNode","breakTextNode","fakePosition","createAttributeElement","Number","POSITIVE_INFINITY","wrapRange","wrap","wrapper","toWrap","canBeJoined","getStyleNames","setStyle","addClass","toUnwrap","removeAttribute","removeClass","removeStyle","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","group","getIdentity","textToMove","t1","t2","nodeBeforeLength","startContainer","endContainer","BR_FILLER","fillerBr","dataset","ckeFiller","NBSP_FILLER","createTextNode","INLINE_FILLER_LENGTH","INLINE_FILLER","startsWithFiller","domNode","Text","isInlineFiller","domText","getDataWithoutFiller","templateBlockFillers","isBlockFiller","blockFiller","templateBlockFiller","isEqualNode","jumpOverInlineFiller","diff_diff","cmp","_insert","_delete","tmp","delta","es","fp","snake","k","y1","y2","dir","y","x","insertat_insertAt","nodeToInsert","insertBefore","childNodes","remove_remove","parentNode","removeChild","istext_isText","isNode","Document","Node","fastDiff","oldText","newText","changeIndexes","firstIndex","lastIndexOld","lastIndexNew","changeIndexesToChanges","findFirstDifferenceIndex","oldTextReversed","cutAndReverse","newTextReversed","findChangeBoundaryIndexes","text","reverse","renderer_Renderer","domDocuments","markedAttributes","markedChildren","markedTexts","_inlineFiller","_fakeSelectionContainer","mapViewToDom","inlineFillerPosition","_updateChildrenMappings","_isSelectionInInlineFiller","_removeInlineFiller","_getInlineFillerPosition","_needsInlineFillerAtSelection","_updateAttrs","_updateChildren","_updateText","fillerDomPosition","addInlineFiller","_updateSelection","_updateFocus","actualDomChildren","expectedDomChildren","viewChildrenToDom","withChildren","diff","_diffNodeLists","actions","_findReplaceActions","counter","equal","action","insertIndex","deleteIndex","viewChild","_updateElementMappings","newViewChild","mapDomToView","unbindDomElement","bindElements","firstPos","selectionPosition","domFillerNode","selectionParent","selectionOffset","findAncestor","isEditable","viewText","findCorrespondingDomText","newDomText","viewToDom","actualText","expectedText","filler","insertData","deleteData","domAttrKeys","attr","viewAttrKeys","nodesToUnbind","_markDescendantTextToSync","domToView","actualDomChild","expectedDomChild","actualDom","expectedDom","newActions","actualSlice","expectedSlice","areSimilar","viewNode","_removeDomSelection","_removeFakeSelection","domRoot","_updateFakeSelection","_updateDomSelection","assign","top","left","width","appendChild","firstChild","domRange","createRange","removeAllRanges","selectNodeContents","addRange","bindFakeSelection","_domSelectionNeedsUpdate","isDomSelectionCorrect","oldViewSelection","domSelectionToView","doc","activeDomElement","activeElement","domParentOrArray","nodeAfterFiller","fillerNode","node1","node2","tagName","indexof_indexOf","DOCUMENT_NODE","lodash_isElement","domconverter_DomConverter","preElements","blockElements","_domToViewMapping","_viewToDomMapping","_fakeSelectionMapping","viewDocumentSelection","domFragment","viewFragment","textData","_processDataFromViewText","createDocumentFragment","bindDocumentFragments","fillerPositionOffset","childView","viewRange","domStart","domEnd","setStart","setEnd","viewParent","domBefore","domAfter","getParentUIElement","_processDataFromDomText","isComment","isDocumentFragment","viewName","keepOriginalCase","domChildrenToView","domChild","fakeSelectionToView","isDomSelectionBackward","viewRanges","domRangeToView","viewStart","viewEnd","findCorrespondingViewText","viewBefore","domElementOrDocumentFragment","isElement","documentFragmentOrElement","viewEditable","domEditable","scrollX","scrollY","scrollPositions","forEachDomNodeAncestor","scrollLeft","scrollTop","scrollTo","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","anchorNode","anchorOffset","detach","_isDomSelectionPositionCorrect","includes","prevNode","_getTouchingViewTextNode","_nodeEndsWithSpace","_hasDomParentOfType","_getTouchingInlineDomNode","nextNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","getNext","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","nodeA","nodeB","types","boundaryParent","parents","isWindow","stringifiedObject","dom_emittermixin","rest","proxy","_getProxyEmitter","emittermixin_ProxyEmitter","attach","listeningEmitter","listenedToEmitterId","_getEmitterListenedTo","getNodeUID","_domNode","_domListeners","domListener","_createDomListener","useCapture","addEventListener","removeListener","domEvt","removeEventListener","Observer","isEnabled","disable","_setCacheAdd_HASH_UNDEFINED","_setCacheAdd","_setCacheHas","SetCache","_SetCache","_arraySome","predicate","UNORDERED_COMPARE_FLAG","PARTIAL_COMPARE_FLAG","_equalArrays","equalFunc","bitmask","arrLength","othLength","seen","arrValue","othValue","compared","othIndex","_equalByTag_UNORDERED_COMPARE_FLAG","_equalByTag_PARTIAL_COMPARE_FLAG","_equalByTag_boolTag","_equalByTag_dateTag","_equalByTag_errorTag","_equalByTag_mapTag","_equalByTag_numberTag","_equalByTag_regexpTag","_equalByTag_setTag","_equalByTag_stringTag","_equalByTag_symbolTag","_equalByTag_arrayBufferTag","_equalByTag_dataViewTag","_equalByTag_symbolProto","_equalByTag_symbolValueOf","_equalByTag","convert","_equalObjects_PARTIAL_COMPARE_FLAG","_equalObjects","objProps","objLength","skipCtor","objCtor","othCtor","typedArrayTags","isTypedArray_objectToString","lodash_isTypedArray","_baseIsEqualDeep_PARTIAL_COMPARE_FLAG","_baseIsEqualDeep_argsTag","_baseIsEqualDeep_arrayTag","_baseIsEqualDeep_objectTag","_baseIsEqualDeep_hasOwnProperty","_baseIsEqualDeep","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","_baseIsEqual","baseIsEqual","lodash_isEqualWith","mutationobserver_MutationObserver","childList","characterData","characterDataOldValue","subtree","renderer","_renderer","_domElements","_mutationObserver","MutationObserver","_onMutations","takeRecords","observe","enable","disconnect","destroy","domMutations","mutatedTexts","mutatedElements","mutation","_isBogusBrMutation","viewMutations","mutatedText","markToSync","viewChildren","newViewChildren","sameNodes","oldChildren","newChildren","viewSelectionAnchor","viewSelectionFocus","child1","child2","addedNode","removedNodes","addedNodes","domeventdata_DomEventData","domEvent","additionalData","preventDefault","stopPropagation","domeventobserver_DomEventObserver","domEventType","onDomEvent","eventType","keyobserver_KeyObserver","metaKey","lodash_now","Date","now","debounce_FUNC_ERROR_TEXT","debounce_nativeMax","nativeMin","lodash_debounce","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","invokeFunc","time","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","remainingWait","clearTimeout","debounced","isInvoking","leadingEdge","cancel","flush","fakeselectionobserver_FakeSelectionObserver","_fireSelectionChangeDoneDebounced","_isArrowKeyCode","_handleSelectionMove","newSelection","oldSelection","selectionobserver_SelectionObserver","mutationObserver","getObserver","_documents","WeakSet","_clearInfiniteLoopInterval","setInterval","_clearInfiniteLoop","_loopbackCounter","_handleSelectionChange","clearInterval","isReadOnly","newViewSelection","focusobserver_FocusObserver","_renderTimeoutId","selectedEditable","compositionobserver_CompositionObserver","isComposing","isRange","getBorderWidths","getComputedStyle","borderTopWidth","right","borderRightWidth","bottom","borderBottomWidth","borderLeftWidth","rect_Rect","isSourceRange","_source","writable","sourceNode","body","contains","copyRectProperties","getDomRangeRects","getBoundingClientRect","innerWidth","innerHeight","height","anotherRect","rect","getIntersection","getArea","visibleRect","clone","isBody","commonAncestorContainer","parentRect","intersectionRect","prop","rectProperties","intersectRect","scrollBarWidth","scrollBarHeight","documentElement","clientWidth","clientHeight","borderWidths","offsetWidth","offsetHeight","moveBy","rects","clientRects","getClientRects","elementOrRange","scrollViewportToShowTarget","viewportOffset","targetWindow","getWindow","currentWindow","currentFrame","firstAncestorToScroll","scrollAncestorsToShowRect","getParentElement","getRectRelativeToWindow","targetRect","scrollWindowToShowRect","frameElement","targetShiftedDownRect","targetShiftedUpRect","viewportRect","excludeScrollbarsAndBorders","isAbove","isBelow","isLeftOf","isRightOf","getRect","parentWindow","firstRect","secondRect","relativeWindow","frame","frameRect","scrollAncestorsToShowTarget","view_View","domRoots","_observers","_ongoingChange","_renderingInProgress","_postFixersInProgress","_writer","addObserver","injectQuirksHandling","_render","viewRoot","getRoot","observer","viewRangeToDom","_callPostFixers","change","disableObservers","enableObservers","toMap","model_node_Node","getChildStartOffset","model_text_Text","toJSON","model_textproxy_TextProxy","nodelist_NodeList","_nodes","_insertNodes","maxOffset","getNodeIndex","getNodeStartOffset","totalOffset","nodeList","indexStart","model_element_Element","getNode","offsetToIndex","relativePath","element_normalize","_removeNodes","fromJSON","model_treewalker_TreeWalker","model_position_Position","_visitedParent","prevVisitedParent","formatReturnValue","offsetInTextNode","lodash_last","newOffset","diffAt","leftParent","deletePosition","transformed","getParentPath","insertPosition","sourcePosition","sticky","_getTransformedByDeletion","_getCombined","_getTransformedByInsertion","combined","createFromParentAndOffset","graveyard","model_range_Range","getCommonPath","posParent","supportedTypes","operation","operations","_getTransformedByDocumentChange","deltas","getTransformedByDelta","j","containsRange","deltaType","_getTransformedByMove","spread","isSticky","insertBeforeStart","insertBeforeEnd","newPos","moveRange","differenceSet","getDifference","difference","common","ref","refIndex","mapper_Mapper","_modelToViewMapping","_viewToModelMapping","_viewToModelLengthCallbacks","_markerNameToElements","viewContainer","modelPosition","_findPositionIn","viewBlock","modelParent","modelOffset","_toModelOffset","modelElement","toModelElement","toViewElement","elements","toModelPosition","modelRange","toViewPosition","mapper","isPhantom","boundElements","getElementsWithSameId","viewElementName","lengthCallback","viewOffset","getModelLength","len","expectedOffset","lastLength","_moveViewPositionToTextNode","modelconsumable_ModelConsumable","_consumable","_textProxyRegistry","_normalizeConsumableType","_getSymbolForTextProxy","itemConsumables","startMap","endMap","_addSymbolForTextProxy","downcastdispatcher_DowncastDispatcher","conversionApi","dispatcher","differ","getMarkersToRemove","convertMarkerRemove","getChanges","convertInsert","convertRemove","convertAttribute","attributeKey","attributeOldValue","attributeNewValue","getMarkersToAdd","convertMarkerAdd","consumable","_createInsertConsumable","_testAndFire","_clearConversionApi","_createConsumableForRange","markers","markersAtSelection","getMarkersAtPosition","_createSelectionConsumable","marker","markerRange","getRange","shouldMarkerChangeBeConverted","markerName","getItems","containsItem","model_selection_Selection","anyNewRange","oldRange","_removeAllRanges","directChange","_popRange","attributeKeys","visited","startBlock","getParentBlock","isUnvisitedBlockContainer","endBlock","isTouching","limitStartPosition","limitEndPosition","_checkRange","model","schema","isBlock","block","liverange_LiveRange","isDocumentOperation","changeType","batch","targetRange","getMovedRangeStart","updated","createFromRanges","boundariesChanged","rangeExpanded","rangeShrunk","contentChanged","storePrefix","model_documentselection_DocumentSelection","documentselection_LiveSelection","hasOwnRange","isGravityOverridden","getSelectedBlocks","containsEntireContent","_getStoredAttributes","overrideGravity","uid","restoreGravity","startsWith","_model","_attributePriority","_fixGraveyardRangesData","_hasChangedRange","_overriddenGravityRegister","_validateSelectionRange","_updateAttributes","changeParent","isNoLongerEmpty","enqueueChange","storedAttributes","clearAttributesStoredInElement","liveRange","_fixGraveyardSelection","_getDefaultRange","optionsOrPlaceOrOffset","_refreshAttributes","overrideUid","_prepareRange","clearAll","newAttributes","_getSurroundingAttributes","oldAttributes","_setAttributesTo","changed","newKey","oldKey","getAttrsIfCharacter","isObject","removedRangeStart","positionCandidate","selectionRange","getNearestSelectionRange","lodash_cloneDeep","downcastElementToElement","config","_normalizeToElementConfig","elementCreator","consume","insertElement","converterPriority","downcastAttributeToElement","modelValue","_getFromAttributeCreator","oldViewElement","newViewElement","viewWriter","toViewRange","unwrap","downcastAttributeToAttribute","_normalizeToAttributeConfig","attributeCreator","oldAttribute","changeAttribute","viewElementType","modelData","viewElementDefinition","createContainerElement","createUIElement","_createViewElementFromDefinition","modelAttributeValue","editingcontroller_EditingController","downcastDispatcher","convertChanges","convertSelection","modelSelection","toModelRange","convertSelectionChange","createText","modelEnd","unbindViewElement","brokenPosition","breakAttributes","plugincollection_PluginCollection","editor","availablePlugins","_editor","_availablePlugins","_plugins","PluginConstructor","pluginName","plugins","removePlugins","that","loading","loaded","pluginConstructors","mapToAvailableConstructors","removePluginConstructors","missingPlugins","pluginNameOrConstructor","getPluginConstructor","getMissingPluginNames","errorMsg","Promise","reject","all","loadPlugin","then","requires","RequiredPluginConstructorOrName","RequiredPluginConstructor","plugin","requiredBy","_add","instantiatePlugin","catch","err","PluginConstructorOrName","promises","pluginInstance","plugin1","plugin2","commandcollection_CommandCollection","_commands","commandName","command","execute","commands","translate","language","translationKey","numberOfLanguages","CKEDITOR_TRANSLATIONS","hasTranslation","locale_Locale","_t","str","translatedString","ViewConsumable","_consumables","consumables","elementConsumables","viewconsumable_ViewElementConsumables","revert","instance","consumablesFromElement","createFrom","_canConsumeName","_test","_consume","_revert","consumableName","schema_Schema","_sourceDefinitions","decorate","SchemaContext","getDefinition","itemName","definition","_clearCache","_compiledDefinitions","_compile","getDefinitions","def","isLimit","context","_checkContextMatch","attributeName","allowAttributes","positionOrBaseElement","elementToMerge","checkMerge","checkChild","childDef","retValue","selectionOrRangeOrPosition","rangeCommonAncestor","checkAttribute","validRanges","backwardWalker","forwardWalker","forward","step","combineWalkers","removeDisallowedAttributes","compiledDefinitions","sourceRules","itemNames","compileBaseItemRule","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","cleanUpAllowAttributes","contextItemIndex","contextItem","getItem","allowIn","parentRule","mapContextItem","query","getNames","endsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","inheritTypesFrom","sourceItemRule","typeNames","copyTypes","copyProperty","inheritFrom","inheritAllFrom","makeInheritAllWork","allowContentOfItemName","getAllowedChildren","allowedItem","allowWhereItemName","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","existingItems","itemToCheck","getValues","ctxItem","upcastdispatcher_UpcastDispatcher","_removeIfEmpty","_modelCursor","convertItem","_convertItem","convertChildren","_convertChildren","splitToAllowedParent","_splitToAllowedParent","viewItem","contextDefinition","append","createContextTree","store","documentFragment","_removeEmptyElements","modelItem","markerElements","markerElement","currentPosition","extractMarkersFromModelFragment","modelCursor","nextModelCursor","allowedParent","findAllowedParent","splitResult","getPositions","cursorParent","upcastElementToElement","converter","_getModelElement","childrenResult","_prepareToElementConverter","elementName","_getViewElementNameFromConfig","upcastElementToAttribute","_normalizeModelAttributeConfig","_prepareToAttributeConverter","upcastAttributeToAttribute","viewKey","normalized","keyName","_normalizeViewAttributeKeyValueConfig","viewAttributeKeyToCopy","defaultModelValue","modelKey","_onlyViewNameIsDefined","modelAttribute","_setAttributeOn","datacontroller_DataController","dataProcessor","processor","upcastDispatcher","modelElementOrFragment","viewDocumentFragment","toView","toData","elementRange","intersection","_getMarkersRelativeToElement","clearBindings","modelRoot","parse","removeSelectionAttribute","toModel","viewElementOrFragment","conversion_Conversion","_dispatchersGroups","groupName","dispatchers","_getDispatchers","conversionHelper","_addToDispatchers","for","_getAllUpcastDefinitions","_getUpcastDefinition","upcastAlso","upcastAlsoItem","operation_Operation","baseVersion","__className","model_documentfragment_DocumentFragment","model_documentfragment_normalize","_normalizeNodes","_splitNodeAtPosition","_mergeNodesAtIndex","_haveSameAttributes","mergedNode","offsetDiff","firstPart","secondPart","iteratorA","iteratorB","lodash_isEqual","attributeoperation_AttributeOperation","moveoperation_MoveOperation","op","newTargetPosition","sourceElement","targetElement","sourceOffset","targetOffset","_move","reinsertoperation_ReinsertOperation","removeoperation_RemoveOperation","_validate","insertoperation_InsertOperation","gyPosition","originalNodes","markeroperation_MarkerOperation","affectsData","_markers","nooperation_NoOperation","renameoperation_RenameOperation","oldName","rootattributeoperation_RootAttributeOperation","operationfactory_operations","OperationFactory","deserializers","deltafactory_DeltaFactory","addOperation","Delta","delta_Delta","_reverseDeltaClass","getReversed","register","attributedelta_AttributeDelta","_range","splitdelta_SplitDelta","_moveOperation","_cloneOperation","mergedelta_MergeDelta","_removeOperation","movedelta_MoveDelta","removedelta_RemoveDelta","renamedelta_RenameDelta","wrapdelta_WrapDelta","moveOp","_insertOperation","unwrapdelta_UnwrapDelta","insertdelta_InsertDelta","weakinsertdelta_WeakInsertDelta","isStrong","algorithm","ot","InsertOperation","AttributeOperation","RootAttributeOperation","RenameOperation","MarkerOperation","MoveOperation","doNotUpdate","updateBaseVersions","forceNotSticky","joinRanges","oldRanges","includeB","moveTargetIntoMovedRange","bTargetsToA","makeMoveOperationsFromRanges","aCompB","forceWeakRemove","shouldSpread","makeMoveOperation","OperationClass","_baseSlice","nativeCeil","ceil","chunk_nativeMax","lodash_chunk","resIndex","lodash_compact","_isFlattenable","_baseFlatten","baseFlatten","depth","isStrict","lodash_concat","_indexOfNaN","fromIndex","fromRight","_baseIndexOf","_arrayIncludes","_arrayIncludesWith","comparator","_arrayMap","_baseUnary","_cacheHas","_baseDifference_LARGE_ARRAY_SIZE","_baseDifference","isCommon","valuesLength","outer","computed","valuesIndex","lodash_difference","_baseIsMatch_UNORDERED_COMPARE_FLAG","_baseIsMatch_PARTIAL_COMPARE_FLAG","_baseIsMatch","matchData","noCustomizer","srcValue","_isStrictComparable","_baseToPairs","_setToPairs","_createToPairs_mapTag","_createToPairs_setTag","lodash_toPairs","_createToPairs","_getMatchData","_matchesStrictComparable","_baseMatches","memoize_FUNC_ERROR_TEXT","memoize","resolver","memoized","Cache","lodash_memoize","_baseToString_INFINITY","_baseToString_symbolProto","symbolToString","_baseToString","lodash_toString","rePropName","reEscapeChar","_stringToPath","number","quote","_castPath","reIsDeepProp","reIsPlainProp","_isKey","_toKey_INFINITY","_toKey","_baseGet","lodash_get","defaultValue","_baseHasIn","_hasPath","hasFunc","lodash_hasIn","_baseMatchesProperty_UNORDERED_COMPARE_FLAG","_baseMatchesProperty_PARTIAL_COMPARE_FLAG","_baseMatchesProperty","lodash_identity","_basePropertyDeep","lodash_property","_baseIteratee","lodash_differenceBy","lodash_differenceWith","lodash_drop","lodash_dropRight","_baseWhile","isDrop","lodash_dropRightWhile","lodash_dropWhile","_baseClamp","lower","upper","MAX_ARRAY_LENGTH","lodash_toLength","_baseFill","lodash_fill","_baseFindIndex","lodash_findIndex","lodash_findLastIndex","lodash_head","lodash_flatten","flattenDeep_INFINITY","lodash_flattenDeep","lodash_flattenDepth","lodash_fromPairs","pairs","indexOf_nativeMax","lodash_indexOf","lodash_initial","_baseIntersection_nativeMin","_baseIntersection","arrays","caches","maxLength","Infinity","_castArrayLikeObject","lodash_intersection","mapped","lodash_intersectionBy","lodash_intersectionWith","nativeJoin","lodash_join","separator","lastIndexOf_nativeMax","lastIndexOf_nativeMin","lodash_lastIndexOf","_baseNth","lodash_nth","_baseIndexOfWith","_basePullAll_splice","_basePullAll","lodash_pullAll","lodash_pull","lodash_pullAllBy","lodash_pullAllWith","_baseAt","paths","isNil","_parent","_basePullAt_splice","_basePullAt","previous","_compareAscending","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","lodash_pullAt","lodash_remove","nativeReverse","lodash_reverse","lodash_slice","MAX_ARRAY_INDEX","_baseSortedIndexBy_MAX_ARRAY_LENGTH","nativeFloor","_baseSortedIndexBy_nativeMin","_baseSortedIndexBy","retHighest","valIsNaN","valIsUndefined","mid","setLow","HALF_MAX_ARRAY_LENGTH","_baseSortedIndex_MAX_ARRAY_LENGTH","_baseSortedIndex","lodash_sortedIndex","lodash_sortedIndexBy","lodash_sortedIndexOf","lodash_sortedLastIndex","lodash_sortedLastIndexBy","lodash_sortedLastIndexOf","_baseSortedUniq","lodash_sortedUniq","lodash_sortedUniqBy","lodash_tail","lodash_take","lodash_takeRight","lodash_takeRightWhile","lodash_takeWhile","lodash_noop","_createSet","_baseUniq_LARGE_ARRAY_SIZE","_baseUniq","seenIndex","lodash_union","lodash_unionBy","lodash_unionWith","lodash_uniq","lodash_uniqBy","lodash_uniqWith","_arrayFilter","unzip_nativeMax","lodash_unzip","lodash_unzipWith","lodash_without","_baseXor","lodash_xor","lodash_xorBy","lodash_xorWith","lodash_zip","_baseZipObject","assignFunc","valsLength","lodash_zipObject","_baseSet","nested","lodash_zipObjectDeep","zipWith","array_default","chunk","compact","differenceBy","differenceWith","drop","dropRight","dropRightWhile","dropWhile","fill","findIndex","findLastIndex","flatten","flattenDeep","flattenDepth","fromPairs","head","initial","intersectionBy","intersectionWith","nth","pull","pullAll","pullAllBy","pullAllWith","pullAt","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","sortedUniq","sortedUniqBy","tail","take","takeRight","takeRightWhile","takeWhile","union","unionBy","unionWith","uniq","uniqBy","uniqWith","unzip","unzipWith","without","xor","xorBy","xorWith","zip","zipObject","zipObjectDeep","specialCases","delta_transform_transform","getTransformationCase","defaultTransform","updateBaseVersion","byOps","newByOps","opA","ops","opB","operation_transform","reverseContext","updatedOpB","getNormalizedDeltas","DeltaClass","attributeOperationIndex","A","B","casesA","cases","caseClass","deltasA","deltasB","transformedDeltasA","transformedDeltasB","useAdditionalContext","contextAB","wasAffected","originalDelta","undoMode","deltaA","deltaB","_setContext","resultAB","transform","resultBA","_updateContext","deltaBA","opsDiffA","getOpsCount","opsDiffB","padWithNoOps","delta_transform","lastDelta","noDelta","_isOperationAffected","_setWasAffected","history","isUndoingDelta","undoneDelta","getUndoneDelta","aWasAffectedBy","affected","_setInsertBeforeContext","originalB","isUndoneDelta","_setForceWeakRemove","_setForceNotSticky","cmpResult","oldDelta","newDeltas","markerdelta_MarkerDelta","addTransformationCase","transformMarkerDelta","transformedDelta","transformedOp","_getComplementaryAttrDelta","weakInsertDelta","attributeDelta","complementaryAttrDelta","val","lastOffset","offsetSum","nodeAttrVal","attrOperation","basic_transformations_noDelta","splitPosition","additionalAttributeDelta","operateInSameParent","mergeInsideMoveRange","pathA","pathB","aRange","bRange","newHowMany","newContext","sameRoot","splitInsideWrapRange","splitNodePos","insertPos","sourcePos","targetPos","additionalRenameDelta","Batch","rootattributedelta_RootAttributeDelta","detachoperation_DetachOperation","rootelement_RootElement","_doc","model_writer_Writer","_assertWriterUsedCorrectly","isSameTree","addDelta","applyOperation","rangeRootPosition","addMarker","usingOperation","itemOrRange","setAttributeOnRange","setAttributeOnItem","removeAttributesFromItem","addRemoveDelta","applyRemoveOperation","getMinimalFlatRanges","flat","positionAfter","positionBefore","moveVersion","renameOperation","limitElement","firstSplitElement","firstCopyElement","splitElement","insertVersion","elementOrString","applyMarkerOperation","_set","markerOrName","currentMarker","hasUsingOperationDefined","affectsDataDefined","currentRange","updatedRange","managedUsingOperations","keyOrObjectOrIterable","_setSelectionAttribute","keyOrIterableOfKeys","_removeSelectionAttribute","_overrideGravity","_restoreGravity","storeKey","_getStoreAttributeKey","_currentWriter","valueBefore","valueAfter","lastSplitPosition","previousValue","isRootChanged","graveyardPosition","rootA","rootB","differ_Differ","markerCollection","_markerCollection","_changesInElement","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","_isInInsertedElement","_markInsert","_markAttribute","sourceParentInserted","targetParentInserted","_markRemove","getMarkersIntersectingRange","bufferMarkerChange","buffered","includeChangesInGraveyard","diffSet","changes","snapshotChildren","elementChildren","_getChildrenSnapshot","_generateActionsFromChanges","_getInsertDiff","_getRemoveDiff","elementAttributes","snapshotAttributes","_getAttributesDiff","changeCount","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","_changesInGraveyardFilter","changeItem","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","inc","nodesToHandle","old","incEnd","oldEnd","intersectionLength","howManyAfter","attributePart","diffs","snapshot","oldChildrenLength","oldChildrenHandled","repeat","posInGy","rangeInGy","history_History","_deltas","_historyPoints","_undoPairs","_undoneDeltas","_getIndex","undoingDelta","nextBaseVersion","isInsideSurrogatePair","character","isHighSurrogateHalf","isLowSurrogateHalf","isInsideCombinedSymbol","isCombiningMark","graveyardName","model_document_Document","createRoot","bufferOperation","hasSelectionChanged","hasDataChanges","reset","defaultRoot","_getDefaultRoot","validateTextNodePosition","rangeBoundary","markercollection_MarkerCollection","markercollection_Marker","oldMarker","hasChanged","_attachLiveRange","_managedUsingOperations","_affectsData","_destroyMarker","prefix","_detachLiveRange","_liveRange","stopDelegating","liveposition_LivePosition","stickiness","originalRange","gotMoved","oldPosition","insertcontent_Insertion","canMergeWith","_filterAttributesOf","parentContext","_handleNode","isFirst","isLast","nodeToSelect","_handleObject","_checkAndSplitToAllowedPosition","_mergeSiblingsOf","_handleDisallowedNode","_tryAutoparagraphing","handleNodes","livePos","mergeLeft","_canMergeLeft","mergeRight","_canMergeRight","mergePosLeft","mergePosRight","merge","paragraph","_getAllowedIn","tempPos","deleteContent","doNotResetEntireContent","getLimitElement","shouldEntireContentBeReplacedWithParagraph","insertParagraph","replaceEntireContentWithParagraph","selRange","startPos","endPos","leaveUnmerged","mergeBranches","startParent","endParent","leftPos","rightPos","rangeToCheck","checkCanBeMerged","parentToRemove","isTextAllowed","isParagraphAllowed","shouldAutoparagraph","wordBoundaryCharacters","modifySelection","isForward","unit","searchEnd","getSearchRange","tryExtendingTo","setSelectionFocus","isAtWordBoundary","isAtNodeBoundary","boundaryChar","getCorrectWordBreakPosition","getCorrectPosition","offsetToCheck","removeRangeContent","parentsToCheck","itemRange","parentToCheck","removeRange","injectSelectionPostFixer","registerPostFixer","correctedRange","tryFixingRange","fixedRanges","selectionStart","selectionEnd","selectionPostFixer","originalPosition","nearestSelectionRange","fixedPosition","tryFixingCollapsedRange","isTextAllowedOnStart","isTextAllowedOnEnd","startLimitElement","endLimitElement","startIsOnBlock","endIsOnBlock","checkSelectionOnNonLimitElements","fixedStart","fixedEnd","isStartInLimit","isEndInLimit","expandSelectionOnIsLimitNode","tryFixingNonCollapsedRage","expandToDirection","model_Model","_pendingChanges","_runPendingChanges","batchOrType","_execute","useContext","transformDeltaSets","content","insertion","nodesToInsert","getSelectionRange","insertContent","frag","commonPath","commonParent","getNodeByPath","flatSubtreeRange","appendText","leftExcessRange","getSelectedContent","rangeOrElement","ret","currentBatch","callbackReturnValue","keystrokehandler_KeystrokeHandler","_listener","keyEvtData","editingkeystrokehandler_EditingKeystrokeHandler","evtData","editor_Editor","builtinPlugins","defaultConfig","locale","once","state","editing","conversion","keystrokes","load","loadPlugins","loadedPlugins","initPlugins","method","promise","readyPromise","viewcollection_ViewCollection","isRendered","_parentElement","elementOrDocFragment","viewcollection_isStringArray","dest","evtName","lodash_cloneDeepWith","xhtmlNs","template_Template","template_normalize","template_clone","_isRendered","_revertData","_renderNode","intoFragment","isApplying","revertData","_revertTemplateFromNode","search","isView","isTemplate","eventNameOrFunctionOrAttribute","TemplateToBinding","eventNameOrFunction","if","valueIfTrue","TemplateIfBinding","template","extendTemplate","extendObjectValueArray","eventListeners","childIndex","isInvalid","_renderText","_renderElement","createElementNS","_renderAttributes","_renderElementChildren","_setUpListeners","textContent","hasTemplateBinding","_bindToObservable","updater","getTextUpdater","attrName","attrValue","domAttrValue","attrNs","valueToBind","shouldExtend","getAttributeUpdater","_renderStyleAttribute","isFalsy","arrayValueReducer","setAttributeNS","styleName","styleValue","getStyleUpdater","isViewCollection","setParent","childRevertData","revertBindings","schemaItem","domEvtName","domSelector","activateDomEventListener","syncValueSchemaValue","templateBinding","activateAttributeListener","revertBinding","TemplateBinding","matches","getValue","getValueSchemaValue","el","removeAttributeNS","normalizePlainTextDefinition","normalizeTextDefinition","listeners","arrayify","normalizeListeners","normalizeAttributes","cur","ext","src_view_View","_viewCollections","_unboundChildren","createCollection","collection","bindTemplate","_bindTemplate","registerChild","getViews","editoruiview_EditorUIView","_renderBodyCollection","_bodyCollectionContainer","bodyElement","class","focustracker_FocusTracker","focusedElement","_elements","_nextEventLoopTimeout","_focus","_blur","componentfactory_ComponentFactory","_components","originalName","getNormalized","editableuiview_EditableUIView","setTemplate","contenteditable","externalElement","inlineeditableuiview_InlineEditableUIView","role","aria-label","BasicHtmlWriter","fragment","implementation","createHTMLDocument","innerHTML","htmldataprocessor_HtmlDataProcessor","_domParser","DOMParser","_domConverter","_htmlWriter","getHtml","_toDom","parseFromString","ElementReplacer","_replacedElements","display","dataapimixin","elementapimixin","HTMLTextAreaElement","setDataInElement","Plugin","DataTransfer","nativeDataTransfer","files","kind","getAsFile","getFiles","_native","getData","setData","clipboardobserver_ClipboardObserver","viewDocument","handleInput","targetRanges","dropRange","dataTransfer","clipboardData","domDoc","clientX","clientY","caretRangeFromPoint","rangeParent","rangeOffset","getDropViewRange","smallPaddingElements","Command","refresh","forceDisable","entercommand_EnterCommand","isSelectionEmpty","splitBlock","isContainedWithinOneElement","enterBlock","splitPos","oldElement","enterobserver_EnterObserver","isSoft","changebuffer_ChangeBuffer","limit","isLocked","_changeCallback","_batch","_reset","_selectionChangeCallback","ignoreLock","inputcommand_InputCommand","undoStepSize","_buffer","textInsertions","resultRange","isCollapsedRange","lock","insertText","unlock","injectUnsafeKeystrokesHandling","latestCompositionSelection","inputCommand","deleteSelectionContent","isSelectionUnchanged","keyData","safeKeycodes","isSafeKeystroke","handleKeydown","isFlatSelection","containerChildrenMutated","mutations","getSingleTextNodeChange","output","lastOperation","pushLast","isContinuationOf","expected","diffToChanges","compareChildNodes","oldChild","newChild","injecttypingmutationshandling_MutationHandler","_handleContainerChildrenMutations","_handleTextMutation","_handleTextNodeInsertion","mutationsCommonAncestor","commonAncestor","getMutationsContainer","domMutationCommonAncestor","freshDomConverter","modelFromCurrentDom","currentModel","modelFromDomChildren","currentModelChildren","lastDomChild","lastCurrentChild","isSafeForTextMutation","diffResult","firstChangeAt","insertions","deletions","calculateChanges","modelSelectionRange","viewPos","modelPos","insertedText","lastChangeAt","input_Input","handle","injectTypingMutationsHandling","deletecommand_DeleteCommand","_shouldEntireContentBeReplacedWithParagraph","sequence","_replaceEntireContentWithParagraph","limitElementFirstChild","deleteobserver_DeleteObserver","hasWordModifier","injectAndroidBackspaceMutationsHandling","selectionChangeToleranceMs","previousSelection","currentSelection","latestSelectionChangeMs","childrenBefore","childrenAfter","hasOnlyContainers","hasDelete","hasInsert","containsContainersRemoval","handleContainerRemovalMutations","delete_Delete","scrollToTheSelection","first_first","iterable","iteratorItem","paragraphcommand_ParagraphCommand","checkCanBecomeParagraph","blocks","rename","paragraph_Paragraph","elementToElement","paragraphLikeElements","isParagraphable","wrapInParagraph","_autoparagraphEmptyRoots","getRootNames","basecommand_BaseCommand","_stack","_createdBatches","docSelection","selectionRanges","transformedRange","transformSelectionRange","batchToUndo","undoingBatch","deltasToUndo","deltaToUndo","historyDeltas","getDeltas","reversedDeltas","transformDeltas","setDeltaAsUndone","transformRangesByDeltas","undocommand_UndoCommand","batchIndex","_undo","_restoreSelection","redocommand_RedoCommand","redoingBatch","attributecommand_AttributeCommand","_getValueFromFirstAllowedNode","checkAttributeInSelection","forceValue","setSelectionAttribute","getValidRanges","BOLD","ITALIC","UNDERLINE","headingcommand_HeadingCommand","modelElements","heading","checkCanBecomeHeading","defaultModelElement","pendingactions_PendingActions","_actions","hasAny","FileReader","reader","_reader","onprogress","file","total","onload","onerror","onabort","readAsDataURL","abort","filerepository_FileRepository","loaders","_updatePendingAction","_pendingAction","uploaded","loader","createUploadAdapter","filerepository_FileLoader","_adapter","aggregatedUploaded","aggregatedTotal","uploadTotal","fileOrLoader","getLoader","_destroy","pendingActions","getMessage","uploadedPercent","adapter","status","read","upload","uploadResponse","BASE64_HEADER_REG_EXP","FileUploader","fileOrData","token","apiAddress","_isBase64","base64","sliceSize","contentType","base64Data","atob","byteArrays","byteNumbers","charCodeAt","Blob","_base64ToBlob","_token","_apiAddress","xhr","_prepareRequest","_attachXHRListeners","_sendRequest","XMLHttpRequest","open","setRequestHeader","responseType","onError","lengthComputable","statusCode","xhrResponse","response","formData","FormData","send","fileuploader","DEFAULT_OPTIONS","refreshInterval","autoRefresh","Token","tokenUrl","initValue","_tokenUrl","_options","_startRefreshing","_refreshToken","_refreshInterval","init","token_token","cloudservices_CloudServices","optionName","cloudservicesuploadadapter_CloudServicesUploadAdapter","cloudServices","uploadUrl","_uploadGateway","_UploadGateway","Adapter","uploadGateway","fileUploader","imageloadobserver_ImageLoadObserver","_observedElements","_updateObservedElements","querySelectorAll","_fireEvents","modelToViewAttributeConverter","img","HighlightStack","descriptor","oldTop","_insertDescriptor","newTop","compareDescriptors","oldDescriptor","newDescriptor","_removeDescriptor","shouldABeBeforeB","classesToString","iconview_IconView","viewBox","_updateXMLContent","_colorFillPaths","svg","querySelector","fillColor","widgetSymbol","labelSymbol","WIDGET_CLASS_NAME","WIDGET_SELECTED_CLASS_NAME","isWidget","toWidget","setCustomProperty","utils_getFillerOffset","labelOrCreator","setLabel","hasSelectionHandler","selectionHandler","icon","drag_handler_default","addSelectionHandler","setHighlightHandling","normalizeToArray","getLabel","labelCreator","imageSymbol","isImageWidgetSelected","isImageWidget","isImage","imageediting_ImageEditing","createImageViewElement","altText","toImageWidget","srcset","srcsetAttributeConverter","src","viewImage","modelWriter","conversionResult","modelImage","viewFigureToModel","emptyElement","createEmptyElement","figure","mouseobserver_MouseObserver","selectAllKeystrokeCode","widget_Widget","_previouslySelected","_clearPreviouslySelectedWidgets","selectedElement","_onMousedown","_onKeydown","_handleDelete","domEventData","isInsideNestedEditable","_setSelectionOverElement","wasHandled","isArrowKeyCode","isSelectAllKeyCode","_handleEnterKey","_selectAllNestedEditableContent","_selectAllContent","_handleArrowKeys","objectElement","_getObjectElementNextToSelection","previousNode","nodeToRemove","objectElement2","isBackwards","documentSelection","widgetParent","probe","widget","imagetextalternativecommand_ImageTextAlternativeCommand","imageElement","imagetextalternativeediting_ImageTextAlternativeEditing","tooltipview_TooltipView","buttonview_ButtonView","ariaLabelUid","tooltipView","_createTooltipView","labelView","_createLabelView","iconView","_getTooltipString","tabindex","aria-labelledby","aria-disabled","aria-pressed","mousedown","click","tooltip","getEnvKeystrokeText","labelview_LabelView","labeledinputview_LabeledInputView","InputView","inputView","_createInputView","select","inputtextview_InputTextView","placeholder","readonly","setValue","FocusCycler","keystrokeHandler","focusables","isFocusable","_getFocusableItem","focusTracker","viewIndex","focused","collectionLength","textalternativeformview_TextAlternativeFormView","labeledInput","_createLabeledInputView","saveButtonView","_createButton","check_default","cancelButtonView","cancel_default","_focusables","_focusCycler","focusPrevious","focusNext","submitHandler","v","button","getPosition","elementRect","moveTo","getAbsoluteRectCoordinates","toPx","toUnit","defaultLimiterElement","balloonpanelview_BalloonPanelView","isVisible","show","defaultPositions","positionOptions","positions","southArrowNorth","southArrowNorthWest","southArrowNorthEast","northArrowSouth","northArrowSouthWest","northArrowSouthEast","limiter","fitInViewport","_getOptimalPosition","unpin","_pinWhenIsVisibleCallback","_startPinning","_stopPinning","hide","attachTo","getDomElement","limiterElement","scrollTarget","isWithinScrollTarget","isLimiterWithinScrollTarget","getNorthTop","balloonRect","arrowVerticalOffset","getSouthTop","arrowHorizontalOffset","positionedElementAncestor","getPositionedAncestor","bestPosition","limiterRect","getVisible","bestPositionRect","bestPositionName","maxLimiterIntersectArea","maxViewportIntersectArea","elementRectArea","positionName","positionRect","limiterIntersectArea","viewportIntersectArea","limiterViewportIntersectRect","getIntersectionArea","setBestPosition","getBestPosition","ancestorPosition","ancestorBorderWidths","northWestArrowSouth","northWestArrowSouthWest","northWestArrowSouthEast","northEastArrowSouth","northEastArrowSouthEast","northEastArrowSouthWest","southWestArrowNorth","southWestArrowNorthWest","southWestArrowNorthEast","southEastArrowNorth","southEastArrowNorthEast","southEastArrowNorthWest","contextualballoon_ContextualBalloon","positionLimiter","ui","visibleView","hasView","_show","pin","_getBalloonPosition","balloonClassName","getBalloonPositionData","editingView","imagetextalternativeui_ImageTextAlternativeUI","_createForm","componentFactory","low_vision_default","_showForm","_balloon","_form","_hideForm","_isVisible","balloon","updatePosition","repositionContextualBalloon","activator","contextElements","contextElement","clickOutsideHandler","focusEditable","imagetextalternative_ImageTextAlternative","image_Image","filedialogbuttonview_FileDialogButtonView","buttonView","_fileInputView","filedialogbuttonview_FileInputView","accept","multiple","isImageType","findOptimalInsertionPosition","firstBlock","imageuploadui_ImageUploadUI","acceptedType","allowMultipleFiles","icons_image_default","insertAt","imageuploadprogress_ImageUploadProgress","encodeURIComponent","image_placeholder_default","uploadStatusChange","uploadId","fileRepository","viewFigure","_startAppearEffect","_showPlaceholder","_hidePlaceholder","progressBar","progressBarSymbol","_createProgressBar","_showProgressBar","completeIcon","_showCompleteIcon","_removeUIElement","_hideProgressBar","_stopAppearEffect","placeholderSymbol","viewImg","_getUIElement","_createPlaceholder","imageFigure","uniqueProperty","imageuploadcommand_ImageUploadCommand","createLoader","insertAtSelection","notification_Notification","alert","_showNotification","namespace","title","imageuploadediting_ImageUploadEditing","isHtmlIncluded","targetModelSelection","targetSelection","isInGraveyard","_load","notification","setAttributes","uploadStatus","default","maxWidth","srcsetAttribute","isNaN","clean","showWarning","destroyLoader","imageupload_ImageUpload","CS_CONFIG","bootstrap_ui_inner_BootstrapEditor","bootstrap_ui_inner_BootstrapEditorUI","updateSourceElement","form","originalSubmit","onSubmit","submit","attachToForm","_elementReplacer","restore","attachDomRoot","getDataFromElement","$","dropdownMenu","dropdownToggle","toolbarButtons","editingRoot","_setupBootstrapToolbarButtons","_setupBootstrapHeadingDropdown","onValueChange","toggleClass","onIsEnabledChange","headingCommand","paragraphCommand","option","isParagraph","menuItem","commandValue","isActive","modelDocument","onCopyCut","_htmlDataProcessor","fullMatch","spaces","normalizeClipboardData","plainTextToHtml","dataController","modelFragment","viewToPlainText","childText","attributeToElement","font-weight","font-style","text-decoration","enterCommand","_batchRegistry","_undoCommand","_redoCommand","addBatch","clearStack","undoneBatch"],"mappings":"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","file":"snippet.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 44);\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/ckeditorerror\n */\n\n/**\n * URL to the documentation with error codes.\n */\nexport const DOCUMENTATION_URL =\n\t'https://docs.ckeditor.com/ckeditor5/latest/framework/guides/support/error-codes.html';\n\n/**\n * The CKEditor error class.\n *\n * All errors will be shortened during the minification process in order to reduce the code size.\n * Therefore, all error messages should be documented in the same way as those in {@link module:utils/log}.\n *\n * Read more in the {@link module:utils/log} module.\n *\n * @extends Error\n */\nexport default class CKEditorError extends Error {\n\t/**\n\t * Creates an instance of the CKEditorError class.\n\t *\n\t * Read more about error logging in the {@link module:utils/log} module.\n\t *\n\t * @param {String} message The error message in an `error-name: Error message.` format.\n\t * During the minification process the \"Error message\" part will be removed to limit the code size\n\t * and a link to this error documentation will be added to the `message`.\n\t * @param {Object} [data] Additional data describing the error. A stringified version of this object\n\t * will be appended to the error message, so the data are quickly visible in the console. The original\n\t * data object will also be later available under the {@link #data} property.\n\t */\n\tconstructor( message, data ) {\n\t\tmessage = attachLinkToDocumentation( message );\n\n\t\tif ( data ) {\n\t\t\tmessage += ' ' + JSON.stringify( data );\n\t\t}\n\n\t\tsuper( message );\n\n\t\t/**\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = 'CKEditorError';\n\n\t\t/**\n\t\t * The additional error data passed to the constructor.\n\t\t *\n\t\t * @member {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\t/**\n\t * Checks if error is an instance of CKEditorError class.\n\t *\n\t * @param {Object} error Object to check.\n\t * @returns {Boolean}\n\t */\n\tstatic isCKEditorError( error ) {\n\t\treturn error instanceof CKEditorError;\n\t}\n}\n\n/**\n * Attaches link to the documentation at the end of the error message.\n *\n * @param {String} message Message to be logged.\n * @returns {String}\n */\nexport function attachLinkToDocumentation( message ) {\n\tconst matchedErrorName = message.match( /^([^:]+):/ );\n\n\tif ( !matchedErrorName ) {\n\t\treturn message;\n\t}\n\n\treturn message + ` Read more: ${ DOCUMENTATION_URL }#error-${ matchedErrorName[ 1 ] }\\n`;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* global console */\n\n/**\n * @module utils/log\n */\n\nimport { attachLinkToDocumentation } from './ckeditorerror';\n\n/**\n * The logging module.\n *\n * This object features two functions that should be used across CKEditor code base to log errors and warnings.\n * Despite being an overridable interface for native `console.*` this module serves also the goal to limit the\n * code size of a minified CKEditor package. During minification process the messages will be shortened and\n * links to their documentation will be logged to the console.\n *\n * All errors and warning should be documented in the following way:\n *\n *\t\t/**\n *\t\t * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.\n *\t\t *\n *\t\t * @error plugin-load\n *\t\t * @param pluginName The name of the plugin that could not be loaded.\n *\t\t * @param moduleName The name of the module which tried to load this plugin.\n *\t\t * /\n *\t\tlog.error( 'plugin-load: It was not possible to load the \"{$pluginName}\" plugin in module \"{$moduleName}', {\n *\t\t\tpluginName: 'foo',\n *\t\t\tmoduleName: 'bar'\n *\t\t} );\n *\n * ### Warning vs Error vs Throw\n *\n * * Whenever a potentially incorrect situation occurs, which does not directly lead to an incorrect behavior,\n * log a warning.\n * * Whenever an incorrect situation occurs, but the app may continue working (although perhaps incorrectly),\n * log an error.\n * * Whenever it's really bad and it does not make sense to continue working, throw a {@link module:utils/ckeditorerror~CKEditorError}.\n *\n * @namespace\n */\nconst log = {\n\t/**\n\t * Logs an error to the console.\n\t *\n\t * Read more about error logging in the {@link module:utils/log} module.\n\t *\n\t * @param {String} message The error message in an `error-name: Error message.` format.\n\t * During the minification process the \"Error message\" part will be removed to limit the code size\n\t * and a link to this error documentation will be logged to the console.\n\t * @param {Object} [data] Additional data describing the error.\n\t */\n\terror( message, data ) {\n\t\tconsole.error( attachLinkToDocumentation( message ), data );\n\t},\n\n\t/**\n\t * Logs a warning to the console.\n\t *\n\t * Read more about error logging in the {@link module:utils/log} module.\n\t *\n\t * @param {String} message The warning message in a `warning-name: Warning message.` format.\n\t * During the minification process the \"Warning message\" part will be removed to limit the code size\n\t * and a link to this error documentation will be logged to the console.\n\t * @param {Object} [data] Additional data describing the warning.\n\t */\n\twarn( message, data ) {\n\t\tconsole.warn( attachLinkToDocumentation( message ), data );\n\t}\n};\n\nexport default log;\n","import checkGlobal from './_checkGlobal';\n\n/** Used to determine if values are of the language type `Object`. */\nvar objectTypes = {\n  'function': true,\n  'object': true\n};\n\n/** Detect free variable `exports`. */\nvar freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)\n  ? exports\n  : undefined;\n\n/** Detect free variable `module`. */\nvar freeModule = (objectTypes[typeof module] && module && !module.nodeType)\n  ? module\n  : undefined;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);\n\n/** Detect free variable `self`. */\nvar freeSelf = checkGlobal(objectTypes[typeof self] && self);\n\n/** Detect free variable `window`. */\nvar freeWindow = checkGlobal(objectTypes[typeof window] && window);\n\n/** Detect `this` as the global object. */\nvar thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n\n/**\n * Used as a reference to the global object.\n *\n * The `this` value is used if it's the global object to avoid Greasemonkey's\n * restricted `window` object, otherwise the `window` object is used.\n */\nvar root = freeGlobal ||\n  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||\n    freeSelf || thisGlobal || Function('return this')();\n\nexport default root;\n","/**\n * Checks if `value` is a global object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {null|Object} Returns `value` if it's a global object, else `null`.\n */\nfunction checkGlobal(value) {\n  return (value && value.Object === Object) ? value : null;\n}\n\nexport default checkGlobal;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import constant from './constant';\nimport root from './_root';\n\n/** Used to determine if values are of the language type `Object`. */\nvar objectTypes = {\n  'function': true,\n  'object': true\n};\n\n/** Detect free variable `exports`. */\nvar freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)\n  ? exports\n  : undefined;\n\n/** Detect free variable `module`. */\nvar freeModule = (objectTypes[typeof module] && module && !module.nodeType)\n  ? module\n  : undefined;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = (freeModule && freeModule.exports === freeExports)\n  ? freeExports\n  : undefined;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = !Buffer ? constant(false) : function(value) {\n  return value instanceof Buffer;\n};\n\nexport default isBuffer;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var getter = _.constant(object);\n *\n * getter() === object;\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nexport default constant;\n","module.exports = \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><g><path d=\\\"M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z\\\"/><path fill-opacity=\\\".256\\\" d=\\\"M1 1h14v14H1z\\\"/><g class=\\\"ck-icon__selected-indicator\\\"><path d=\\\"M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z\\\"/><path fill-opacity=\\\".254\\\" d=\\\"M1 1h14v14H1z\\\"/></g></g></svg>\\n\"","module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z\\\" fill=\\\"#000\\\" fill-rule=\\\"evenodd\\\"/></svg>\"","module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z\\\" fill=\\\"#000\\\" fill-rule=\\\"evenodd\\\"/></svg>\"","module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012.9.093 1.676.675 2.017 1.513.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z\\\" fill=\\\"#000\\\" fill-rule=\\\"evenodd\\\"/></svg>\"","module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z\\\" fill=\\\"#000\\\" fill-rule=\\\"nonzero\\\"/></svg>\\n\"","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 700 250\\\"><g fill=\\\"#FAFAFA\\\" fill-rule=\\\"evenodd\\\"><rect width=\\\"700\\\" height=\\\"250\\\" rx=\\\"4\\\"/></g></svg>\\n\"","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/version\n */\n\n/* globals window, global */\n\nimport log from './log';\nimport { version } from 'ckeditor5/package.json';\n\nconst windowOrGlobal = typeof window === 'object' ? window : global;\n\nif ( windowOrGlobal.CKEDITOR_VERSION ) {\n\t/**\n\t * This error is thrown when the `CKEDITOR_VERSION` global is being set more than once. This happens when in\n\t * two scenarios described above.\n\t *\n\t * # Some packages were duplicated\n\t *\n\t * CKEditor 5 was built from source packages which were duplicated during installation via npm.\n\t * Normally, npm deduplicates all packages so e.g. `@ckeditor/ckeditor5-core` is installed only once in `node_modules/`.\n\t * However, subsequent `npm install` calls or conflicting version dependencies may cause npm to install some packages\n\t * more than once. Furthermore, [npm in version 5+](https://github.com/npm/npm/issues/16991)\n\t * is also known for randomly failing to deduplicate packages.\n\t *\n\t * We recommend checking if any of the below steps helps:\n\t *\n\t * * `rm -rf node_modules && npm install` to make sure you have a clean `node_modules/` – this step\n\t * is known to help in majority of cases,\n\t * * check whether all CKEditor 5 packages are up to date and reinstall them\n\t * if you changed anything (`rm -rf node_modules && npm install`),\n\t * * downgrade npm to version 4 if you use a newer version.\n\t *\n\t * If all packages are correct and compatible with each other the above steps are known to help. If not, you may\n\t * try to check with `npm ls` how many times `@ckeditor/ckeditor5-core` is installed. If more than once, verify\n\t * which package causes that.\n\t *\n\t * # Two+ builds are loaded\n\t *\n\t * If you use CKEditor 5 builds, you might have loaded two (or more) `ckeditor.js` files in one web page\n\t * – check your web page for duplicated `<script>` elements or make sure your page builder/bundler includes CKEditor only once.\n\t *\n\t * @error ckeditor-version-collision\n\t * @param {String} collidingVersion The version of the build which has already been (incorrectly) loaded.\n\t * @param {String} version The version of the build which is supposed to be loaded.\n\t */\n\tlog.error( 'ckeditor-version-collision: The global CKEDITOR_VERSION constant has already been set.', {\n\t\tcollidingVersion: windowOrGlobal.CKEDITOR_VERSION,\n\t\tversion\n\t} );\n} else {\n\twindowOrGlobal.CKEDITOR_VERSION = version;\n}\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetPrototype = Object.getPrototypeOf;\n\n/**\n * Gets the `[[Prototype]]` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {null|Object} Returns the `[[Prototype]]`.\n */\nfunction getPrototype(value) {\n  return nativeGetPrototype(Object(value));\n}\n\nexport default getPrototype;\n","/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\nexport default isHostObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import getPrototype from './_getPrototype';\nimport isHostObject from './_isHostObject';\nimport isObjectLike from './isObjectLike';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object,\n *  else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) ||\n      objectToString.call(value) != objectTag || isHostObject(value)) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nexport default isPlainObject;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/config\n */\n\nimport isPlainObject from './lib/lodash/isPlainObject';\n\n/**\n * Handles a configuration dictionary.\n */\nexport default class Config {\n\t/**\n\t * Creates an instance of the {@link ~Config} class.\n\t *\n\t * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n\t * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n\t */\n\tconstructor( configurations, defaultConfigurations ) {\n\t\t/**\n\t\t * Store for the whole configuration.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._config = {};\n\n\t\t// Set default configuration.\n\t\tif ( defaultConfigurations ) {\n\t\t\tthis.define( defaultConfigurations );\n\t\t}\n\n\t\t// Set initial configuration.\n\t\tif ( configurations ) {\n\t\t\tthis._setObjectToTarget( this._config, configurations );\n\t\t}\n\t}\n\n\t/**\n\t * Set configuration values.\n\t *\n\t * It accepts both a name/value pair or an object, which properties and values will be used to set\n\t * configurations.\n\t *\n\t * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n\t * the value for the `width` configuration in the `resize` subset.\n\t *\n\t *\t\tconfig.set( 'width', 500 );\n\t *\t\tconfig.set( 'toolbar.collapsed', true );\n\t *\n\t *\t\t// Equivalent to:\n\t *\t\tconfig.set( {\n\t *\t\t\twidth: 500\n\t *\t\t\ttoolbar: {\n\t *\t\t\t\tcollapsed: true\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Passing an object as the value will amend the configuration, not replace it.\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcollapsed: true,\n\t *\t\t} );\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcolor: 'red',\n\t *\t\t} );\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' ); // true\n\t *\t\tconfig.get( 'toolbar.color' ); // 'red'\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tset( name, value ) {\n\t\tthis._setToTarget( this._config, name, value );\n\t}\n\n\t/**\n\t * Does exactly the same as {@link #set} with one exception – passed configuration extends\n\t * existing one, but does not overwrite already defined values.\n\t *\n\t * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n\t * rarely used for other needs.\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tdefine( name, value ) {\n\t\tconst isDefine = true;\n\n\t\tthis._setToTarget( this._config, name, value, isDefine );\n\t}\n\n\t/**\n\t * Gets the value for a configuration entry.\n\t *\n\t *\t\tconfig.get( 'name' );\n\t *\n\t * Deep configurations can be retrieved by separating each part with a dot.\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' );\n\t *\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\tget( name ) {\n\t\treturn this._getFromSource( this._config, name );\n\t}\n\n\t/**\n\t * Saves passed configuration to the specified target (nested object).\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n\t */\n\t_setToTarget( target, name, value, isDefine = false ) {\n\t\t// In case of an object, iterate through it and call `_setToTarget` again for each property.\n\t\tif ( isPlainObject( name ) ) {\n\t\t\tthis._setObjectToTarget( target, name, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\t// If there is no object for specified part then create one.\n\t\t\tif ( !isPlainObject( target[ part ] ) ) {\n\t\t\t\ttarget[ part ] = {};\n\t\t\t}\n\n\t\t\t// Nested object becomes a target.\n\t\t\ttarget = target[ part ];\n\t\t}\n\n\t\t// In case of value is an object.\n\t\tif ( isPlainObject( value ) ) {\n\t\t\t// We take care of proper config structure.\n\t\t\tif ( !isPlainObject( target[ name ] ) ) {\n\t\t\t\ttarget[ name ] = {};\n\t\t\t}\n\n\t\t\ttarget = target[ name ];\n\n\t\t\t// And iterate through this object calling `_setToTarget` again for each property.\n\t\t\tthis._setObjectToTarget( target, value, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Do nothing if we are defining configuration for non empty name.\n\t\tif ( isDefine && typeof target[ name ] != 'undefined' ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget[ name ] = value;\n\t}\n\n\t/**\n\t * Get specified configuration from specified source (nested object).\n\t *\n\t * @private\n\t * @param {Object} source level of nested object.\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\t_getFromSource( source, name ) {\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\tif ( !isPlainObject( source[ part ] ) ) {\n\t\t\t\tsource = null;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Nested object becomes a source.\n\t\t\tsource = source[ part ];\n\t\t}\n\n\t\t// Always returns undefined for non existing configuration\n\t\treturn source ? source[ name ] : undefined;\n\t}\n\n\t/**\n\t * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {Object} configuration Configuration data set\n\t * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n\t */\n\t_setObjectToTarget( target, configuration, isDefine ) {\n\t\tObject.keys( configuration ).forEach( key => {\n\t\t\tthis._setToTarget( target, key, configuration[ key ], isDefine );\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/spy\n */\n\n/**\n * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.\n *\n * The following are the present features:\n *\n * * spy.called: property set to `true` if the function has been called at least once.\n *\n * @returns {Function} The spy function.\n */\nfunction spy() {\n\treturn function spy() {\n\t\tspy.called = true;\n\t};\n}\n\nexport default spy;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/eventinfo\n */\n\nimport spy from './spy';\n\n/**\n * The event object passed to event callbacks. It is used to provide information about the event as well as a tool to\n * manipulate it.\n */\nexport default class EventInfo {\n\t/**\n\t * @param {Object} source The emitter.\n\t * @param {String} name The event name.\n\t */\n\tconstructor( source, name ) {\n\t\t/**\n\t\t * The object that fired the event.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object}\n\t\t */\n\t\tthis.source = source;\n\n\t\t/**\n\t\t * The event name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Path this event has followed. See {@link module:utils/emittermixin~EmitterMixin#delegate}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Object>}\n\t\t */\n\t\tthis.path = [];\n\n\t\t// The following methods are defined in the constructor because they must be re-created per instance.\n\n\t\t/**\n\t\t * Stops the event emitter to call further callbacks for this event interaction.\n\t\t *\n\t\t * @method #stop\n\t\t */\n\t\tthis.stop = spy();\n\n\t\t/**\n\t\t * Removes the current callback from future interactions of this event.\n\t\t *\n\t\t * @method #off\n\t\t */\n\t\tthis.off = spy();\n\n\t\t/**\n\t\t * The value which will be returned by {@link module:utils/emittermixin~EmitterMixin#fire}.\n\t\t *\n\t\t * It's `undefined` by default and can be changed by an event listener:\n\t\t *\n\t\t *\t\tdataController.fire( 'getSelectedContent', ( evt ) => {\n\t\t *\t\t\t// This listener will make `dataController.fire( 'getSelectedContent' )`\n\t\t *\t\t\t// always return an empty DocumentFragment.\n\t\t *\t\t\tevt.return = new DocumentFragment();\n\t\t *\n\t\t *\t\t\t// Make sure no other listeners are executed.\n\t\t *\t\t\tevt.stop();\n\t\t *\t\t} );\n\t\t *\n\t\t * @member #return\n\t\t */\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/uid\n */\n\n/**\n * Returns a unique id. This id consist of an 'e' character and a randomly generated string of 32 aphanumeric characters.\n * Each character in uid string represents a hexadecimal digit (base 16).\n *\n * @returns {String} A hexadecimal number representing the id.\n */\nexport default function uid() {\n\tlet uuid = 'e'; // Make sure that id does not start with number.\n\n\tfor ( let i = 0; i < 8; i++ ) {\n\t\tuuid += Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 );\n\t}\n\n\treturn uuid;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/priorities\n */\n\n/**\n * String representing a priority value.\n *\n * @typedef {'highest'|'high'|'normal'|'low'|'lowest'} module:utils/priorities~PriorityString\n */\n\n/**\n * Provides group of constants to use instead of hardcoding numeric priority values.\n *\n * @namespace\n */\nconst priorities = {\n\t/**\n\t * Converts a string with priority name to it's numeric value. If `Number` is given, it just returns it.\n\t *\n\t * @static\n\t * @param {module:utils/priorities~PriorityString|Number} priority Priority to convert.\n\t * @returns {Number} Converted priority.\n\t */\n\tget( priority ) {\n\t\tif ( typeof priority != 'number' ) {\n\t\t\treturn this[ priority ] || this.normal;\n\t\t} else {\n\t\t\treturn priority;\n\t\t}\n\t},\n\n\thighest: 100000,\n\thigh: 1000,\n\tnormal: 0,\n\tlow: -1000,\n\tlowest: -100000\n};\n\nexport default priorities;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/emittermixin\n */\n\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\n\nconst _listeningTo = Symbol( 'listeningTo' );\nconst _emitterId = Symbol( 'emitterId' );\n\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\nconst EmitterMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\ton( event, callback, options = {} ) {\n\t\tthis.listenTo( this, event, callback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tonce( event, callback, options ) {\n\t\tconst onceCallback = function( event, ...args ) {\n\t\t\t// Go off() at the first call.\n\t\t\tevent.off();\n\n\t\t\t// Go with the original callback.\n\t\t\tcallback.call( this, event, ...args );\n\t\t};\n\n\t\t// Make a similar on() call, simply replacing the callback.\n\t\tthis.listenTo( this, event, onceCallback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\toff( event, callback ) {\n\t\tthis.stopListening( this, event, callback );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tlistenTo( emitter, event, callback, options = {} ) {\n\t\tlet emitterInfo, eventCallbacks;\n\n\t\t// _listeningTo contains a list of emitters that this object is listening to.\n\t\t// This list has the following format:\n\t\t//\n\t\t// _listeningTo: {\n\t\t//     emitterId: {\n\t\t//         emitter: emitter,\n\t\t//         callbacks: {\n\t\t//             event1: [ callback1, callback2, ... ]\n\t\t//             ....\n\t\t//         }\n\t\t//     },\n\t\t//     ...\n\t\t// }\n\n\t\tif ( !this[ _listeningTo ] ) {\n\t\t\tthis[ _listeningTo ] = {};\n\t\t}\n\n\t\tconst emitters = this[ _listeningTo ];\n\n\t\tif ( !_getEmitterId( emitter ) ) {\n\t\t\t_setEmitterId( emitter );\n\t\t}\n\n\t\tconst emitterId = _getEmitterId( emitter );\n\n\t\tif ( !( emitterInfo = emitters[ emitterId ] ) ) {\n\t\t\temitterInfo = emitters[ emitterId ] = {\n\t\t\t\temitter,\n\t\t\t\tcallbacks: {}\n\t\t\t};\n\t\t}\n\n\t\tif ( !( eventCallbacks = emitterInfo.callbacks[ event ] ) ) {\n\t\t\teventCallbacks = emitterInfo.callbacks[ event ] = [];\n\t\t}\n\n\t\teventCallbacks.push( callback );\n\n\t\t// Finally register the callback to the event.\n\t\tcreateEventNamespace( emitter, event );\n\t\tconst lists = getCallbacksListsForNamespace( emitter, event );\n\t\tconst priority = priorities.get( options.priority );\n\n\t\tconst callbackDefinition = {\n\t\t\tcallback,\n\t\t\tpriority\n\t\t};\n\n\t\t// Add the callback to all callbacks list.\n\t\tfor ( const callbacks of lists ) {\n\t\t\t// Add the callback to the list in the right priority position.\n\t\t\tlet added = false;\n\n\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tif ( callbacks[ i ].priority < priority ) {\n\t\t\t\t\tcallbacks.splice( i, 0, callbackDefinition );\n\t\t\t\t\tadded = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add at the end, if right place was not found.\n\t\t\tif ( !added ) {\n\t\t\t\tcallbacks.push( callbackDefinition );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopListening( emitter, event, callback ) {\n\t\tconst emitters = this[ _listeningTo ];\n\t\tlet emitterId = emitter && _getEmitterId( emitter );\n\t\tconst emitterInfo = emitters && emitterId && emitters[ emitterId ];\n\t\tconst eventCallbacks = emitterInfo && event && emitterInfo.callbacks[ event ];\n\n\t\t// Stop if nothing has been listened.\n\t\tif ( !emitters || ( emitter && !emitterInfo ) || ( event && !eventCallbacks ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// All params provided. off() that single callback.\n\t\tif ( callback ) {\n\t\t\tremoveCallback( emitter, event, callback );\n\t\t}\n\t\t// Only `emitter` and `event` provided. off() all callbacks for that event.\n\t\telse if ( eventCallbacks ) {\n\t\t\twhile ( ( callback = eventCallbacks.pop() ) ) {\n\t\t\t\tremoveCallback( emitter, event, callback );\n\t\t\t}\n\n\t\t\tdelete emitterInfo.callbacks[ event ];\n\t\t}\n\t\t// Only `emitter` provided. off() all events for that emitter.\n\t\telse if ( emitterInfo ) {\n\t\t\tfor ( event in emitterInfo.callbacks ) {\n\t\t\t\tthis.stopListening( emitter, event );\n\t\t\t}\n\t\t\tdelete emitters[ emitterId ];\n\t\t}\n\t\t// No params provided. off() all emitters.\n\t\telse {\n\t\t\tfor ( emitterId in emitters ) {\n\t\t\t\tthis.stopListening( emitters[ emitterId ].emitter );\n\t\t\t}\n\t\t\tdelete this[ _listeningTo ];\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tfire( eventOrInfo, ...args ) {\n\t\tconst eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo( this, eventOrInfo );\n\t\tconst event = eventInfo.name;\n\t\tlet callbacks = getCallbacksForEvent( this, event );\n\n\t\t// Record that the event passed this emitter on its path.\n\t\teventInfo.path.push( this );\n\n\t\t// Handle event listener callbacks first.\n\t\tif ( callbacks ) {\n\t\t\t// Arguments passed to each callback.\n\t\t\tconst callbackArgs = [ eventInfo, ...args ];\n\n\t\t\t// Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n\t\t\t// are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n\t\t\t// failed if callbacks were added to the queue before currently processed callback.\n\t\t\t// If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n\t\t\t// event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n\t\t\tcallbacks = Array.from( callbacks );\n\n\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tcallbacks[ i ].callback.apply( this, callbackArgs );\n\n\t\t\t\t// Remove the callback from future requests if off() has been called.\n\t\t\t\tif ( eventInfo.off.called ) {\n\t\t\t\t\t// Remove the called mark for the next calls.\n\t\t\t\t\tdelete eventInfo.off.called;\n\n\t\t\t\t\tremoveCallback( this, event, callbacks[ i ].callback );\n\t\t\t\t}\n\n\t\t\t\t// Do not execute next callbacks if stop() was called.\n\t\t\t\tif ( eventInfo.stop.called ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delegate event to other emitters if needed.\n\t\tif ( this._delegations ) {\n\t\t\tconst destinations = this._delegations.get( event );\n\t\t\tconst passAllDestinations = this._delegations.get( '*' );\n\n\t\t\tif ( destinations ) {\n\t\t\t\tfireDelegatedEvents( destinations, eventInfo, args );\n\t\t\t}\n\n\t\t\tif ( passAllDestinations ) {\n\t\t\t\tfireDelegatedEvents( passAllDestinations, eventInfo, args );\n\t\t\t}\n\t\t}\n\n\t\treturn eventInfo.return;\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdelegate( ...events ) {\n\t\treturn {\n\t\t\tto: ( emitter, nameOrFunction ) => {\n\t\t\t\tif ( !this._delegations ) {\n\t\t\t\t\tthis._delegations = new Map();\n\t\t\t\t}\n\n\t\t\t\tfor ( const eventName of events ) {\n\t\t\t\t\tconst destinations = this._delegations.get( eventName );\n\n\t\t\t\t\tif ( !destinations ) {\n\t\t\t\t\t\tthis._delegations.set( eventName, new Map( [ [ emitter, nameOrFunction ] ] ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestinations.set( emitter, nameOrFunction );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopDelegating( event, emitter ) {\n\t\tif ( !this._delegations ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !event ) {\n\t\t\tthis._delegations.clear();\n\t\t} else if ( !emitter ) {\n\t\t\tthis._delegations.delete( event );\n\t\t} else {\n\t\t\tconst destinations = this._delegations.get( event );\n\n\t\t\tif ( destinations ) {\n\t\t\t\tdestinations.delete( emitter );\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport default EmitterMixin;\n\n/**\n * Emitter/listener interface.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.\n *\n * @interface Emitter\n */\n\n/**\n * Registers a callback function to be executed when an event is fired.\n *\n * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter\n * listen on itself).\n *\n * @method #on\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Registers a callback function to be executed on the next time the event is fired only. This is similar to\n * calling {@link #on} followed by {@link #off} in the callback.\n *\n * @method #once\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops executing the callback on the given event.\n * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.\n *\n * @method #off\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Registers a callback function to be executed when an event is fired in a specific (emitter) object.\n *\n * Events can be grouped in namespaces using `:`.\n * When namespaced event is fired, it additionally fires all callbacks for that namespace.\n *\n *\t\t// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).\n *\t\tmyEmitter.on( 'myGroup', genericCallback );\n *\t\tmyEmitter.on( 'myGroup:myEvent', specificCallback );\n *\n *\t\t// genericCallback is fired.\n *\t\tmyEmitter.fire( 'myGroup' );\n *\t\t// both genericCallback and specificCallback are fired.\n *\t\tmyEmitter.fire( 'myGroup:myEvent' );\n *\t\t// genericCallback is fired even though there are no callbacks for \"foo\".\n *\t\tmyEmitter.fire( 'myGroup:foo' );\n *\n * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and\n * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.\n *\n * @method #listenTo\n * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops listening for events. It can be used at different levels:\n *\n * * To stop listening to a specific callback.\n * * To stop listening to a specific event.\n * * To stop listening to all events fired by a specific object.\n * * To stop listening to all events fired by all objects.\n *\n * @method #stopListening\n * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n * for all events from `emitter`.\n * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n * `event`.\n */\n\n/**\n * Fires an event, executing all callbacks registered for it.\n *\n * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,\n * followed by the optional `args` provided in the `fire()` method call.\n *\n * @method #fire\n * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.\n * @param {...*} [args] Additional arguments to be passed to the callbacks.\n * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners\n * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info\n * is the first param of every callback).\n */\n\n/**\n * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:\n *\n *\t\temitterA.delegate( 'eventX' ).to( emitterB );\n *\t\temitterA.delegate( 'eventX', 'eventY' ).to( emitterC );\n *\n * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventX', data );\n *\n * and `eventY` is delegated (fired by) `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventY', data );\n *\n * @method #delegate\n * @param {...String} events Event names that will be delegated to another emitter.\n * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}\n */\n\n/**\n * Stops delegating events. It can be used at different levels:\n *\n * * To stop delegating all events.\n * * To stop delegating a specific event to all emitters.\n * * To stop delegating a specific event to a specific emitter.\n *\n * @method #stopDelegating\n * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.\n * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.\n * If omitted, stops delegation of `event` to all emitters.\n */\n\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @protected\n * @param {module:utils/emittermixin~EmitterMixin} listeningEmitter Emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~EmitterMixin|null}\n */\nexport function _getEmitterListenedTo( listeningEmitter, listenedToEmitterId ) {\n\tif ( listeningEmitter[ _listeningTo ] && listeningEmitter[ _listeningTo ][ listenedToEmitterId ] ) {\n\t\treturn listeningEmitter[ _listeningTo ][ listenedToEmitterId ].emitter;\n\t}\n\n\treturn null;\n}\n\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @protected\n * @param {module:utils/emittermixin~EmitterMixin} emitter Emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\nexport function _setEmitterId( emitter, id ) {\n\tif ( !emitter[ _emitterId ] ) {\n\t\temitter[ _emitterId ] = id || uid();\n\t}\n}\n\n/**\n * Returns emitter's unique id.\n *\n * @protected\n * @param {module:utils/emittermixin~EmitterMixin} emitter Emitter which id will be returned.\n */\nexport function _getEmitterId( emitter ) {\n\treturn emitter[ _emitterId ];\n}\n\n// Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\nfunction getEvents( source ) {\n\tif ( !source._events ) {\n\t\tObject.defineProperty( source, '_events', {\n\t\t\tvalue: {}\n\t\t} );\n\t}\n\n\treturn source._events;\n}\n\n// Creates event node for generic-specific events relation architecture.\nfunction makeEventNode() {\n\treturn {\n\t\tcallbacks: [],\n\t\tchildEvents: []\n\t};\n}\n\n// Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\nfunction createEventNamespace( source, eventName ) {\n\tconst events = getEvents( source );\n\n\t// First, check if the event we want to add to the structure already exists.\n\tif ( events[ eventName ] ) {\n\t\t// If it exists, we don't have to do anything.\n\t\treturn;\n\t}\n\n\t// In other case, we have to create the structure for the event.\n\t// Note, that we might need to create intermediate events too.\n\t// I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n\t// we need to also register foo:bar.\n\n\t// Currently processed event name.\n\tlet name = eventName;\n\t// Name of the event that is a child event for currently processed event.\n\tlet childEventName = null;\n\n\t// Array containing all newly created specific events.\n\tconst newEventNodes = [];\n\n\t// While loop can't check for ':' index because we have to handle generic events too.\n\t// In each loop, we truncate event name, going from the most specific name to the generic one.\n\t// I.e. foo:bar:abc -> foo:bar -> foo.\n\twhile ( name !== '' ) {\n\t\tif ( events[ name ] ) {\n\t\t\t// If the currently processed event name is already registered, we can be sure\n\t\t\t// that it already has all the structure created, so we can break the loop here\n\t\t\t// as no more events need to be registered.\n\t\t\tbreak;\n\t\t}\n\n\t\t// If this event is not yet registered, create a new object for it.\n\t\tevents[ name ] = makeEventNode();\n\t\t// Add it to the array with newly created events.\n\t\tnewEventNodes.push( events[ name ] );\n\n\t\t// Add previously processed event name as a child of this event.\n\t\tif ( childEventName ) {\n\t\t\tevents[ name ].childEvents.push( childEventName );\n\t\t}\n\n\t\tchildEventName = name;\n\t\t// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n\t\tname = name.substr( 0, name.lastIndexOf( ':' ) );\n\t}\n\n\tif ( name !== '' ) {\n\t\t// If name is not empty, we found an already registered event that was a parent of the\n\t\t// event we wanted to register.\n\n\t\t// Copy that event's callbacks to newly registered events.\n\t\tfor ( const node of newEventNodes ) {\n\t\t\tnode.callbacks = events[ name ].callbacks.slice();\n\t\t}\n\n\t\t// Add last newly created event to the already registered event.\n\t\tevents[ name ].childEvents.push( childEventName );\n\t}\n}\n\n// Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\nfunction getCallbacksListsForNamespace( source, eventName ) {\n\tconst eventNode = getEvents( source )[ eventName ];\n\n\tif ( !eventNode ) {\n\t\treturn [];\n\t}\n\n\tlet callbacksLists = [ eventNode.callbacks ];\n\n\tfor ( let i = 0; i < eventNode.childEvents.length; i++ ) {\n\t\tconst childCallbacksLists = getCallbacksListsForNamespace( source, eventNode.childEvents[ i ] );\n\n\t\tcallbacksLists = callbacksLists.concat( childCallbacksLists );\n\t}\n\n\treturn callbacksLists;\n}\n\n// Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\nfunction getCallbacksForEvent( source, eventName ) {\n\tlet event;\n\n\tif ( !source._events || !( event = source._events[ eventName ] ) || !event.callbacks.length ) {\n\t\t// There are no callbacks registered for specified eventName.\n\t\t// But this could be a specific-type event that is in a namespace.\n\t\tif ( eventName.indexOf( ':' ) > -1 ) {\n\t\t\t// If the eventName is specific, try to find callback lists for more generic event.\n\t\t\treturn getCallbacksForEvent( source, eventName.substr( 0, eventName.lastIndexOf( ':' ) ) );\n\t\t} else {\n\t\t\t// If this is a top-level generic event, return null;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn event.callbacks;\n}\n\n// Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing `[ {@link utils.Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\nfunction fireDelegatedEvents( destinations, eventInfo, fireArgs ) {\n\tfor ( let [ emitter, name ] of destinations ) {\n\t\tif ( !name ) {\n\t\t\tname = eventInfo.name;\n\t\t} else if ( typeof name == 'function' ) {\n\t\t\tname = name( eventInfo.name );\n\t\t}\n\n\t\tconst delegatedInfo = new EventInfo( eventInfo.source, name );\n\n\t\tdelegatedInfo.path = [ ...eventInfo.path ];\n\n\t\temitter.fire( delegatedInfo, ...fireArgs );\n\t}\n}\n\n// Removes callback from emitter for given event.\n//\n// @param {module:utils/emittermixin~Emitter} emitter\n// @param {String} event\n// @param {Function} callback\nfunction removeCallback( emitter, event, callback ) {\n\tconst lists = getCallbacksListsForNamespace( emitter, event );\n\n\tfor ( const callbacks of lists ) {\n\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\tif ( callbacks[ i ].callback == callback ) {\n\t\t\t\t// Remove the callback from the list (fixing the next index).\n\t\t\t\tcallbacks.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The return value of {@link ~EmitterMixin#delegate}.\n *\n * @interface module:utils/emittermixin~EmitterMixinDelegateChain\n */\n\n/**\n * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n *\n * @method #to\n * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.\n * @param {String|Function} nameOrFunction A custom event name or function which converts the original name string.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/mix\n */\n\n/**\n * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the\n * prototype of first object (a constructor).\n *\n *\t\tclass Editor {\n *\t\t\t...\n *\t\t}\n *\n *\t\tconst SomeMixin = {\n *\t\t\ta() {\n *\t\t\t\treturn 'a';\n *\t\t\t}\n *\t\t};\n *\n *\t\tmix( Editor, SomeMixin, ... );\n *\n *\t\tnew Editor().a(); // -> 'a'\n *\n * Note: Properties which already exist in the base class will not be overriden.\n *\n * @param {Function} [baseClass] Class which prototype will be extended.\n * @param {Object} [...mixins] Objects from which to get properties.\n */\nexport default function mix( baseClass, ...mixins ) {\n\tmixins.forEach( mixin => {\n\t\tObject.getOwnPropertyNames( mixin ).concat( Object.getOwnPropertySymbols( mixin ) )\n\t\t\t.forEach( key => {\n\t\t\t\tif ( key in baseClass.prototype ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceDescriptor = Object.getOwnPropertyDescriptor( mixin, key );\n\t\t\t\tsourceDescriptor.enumerable = false;\n\n\t\t\t\tObject.defineProperty( baseClass.prototype, key, sourceDescriptor );\n\t\t\t} );\n\t} );\n}\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var other = { 'user': 'fred' };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear';\nimport listCacheDelete from './_listCacheDelete';\nimport listCacheGet from './_listCacheGet';\nimport listCacheHas from './_listCacheHas';\nimport listCacheSet from './_listCacheSet';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import ListCache from './_ListCache';\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\nexport default stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\nexport default stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nexport default stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nexport default stackHas;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array and weak map constructors,\n  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\nexport default isFunction;\n","/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction';\nimport isHostObject from './_isHostObject';\nimport isObject from './isObject';\nimport toSource from './_toSource';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default isNative;\n","import isNative from './isNative';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object[key];\n  return isNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear';\nimport hashDelete from './_hashDelete';\nimport hashGet from './_hashGet';\nimport hashHas from './_hashHas';\nimport hashSet from './_hashSet';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","import getNative from './_getNative';\nimport root from './_root';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash';\nimport ListCache from './_ListCache';\nimport Map from './_Map';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear';\nimport mapCacheDelete from './_mapCacheDelete';\nimport mapCacheGet from './_mapCacheGet';\nimport mapCacheHas from './_mapCacheHas';\nimport mapCacheSet from './_mapCacheSet';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import ListCache from './_ListCache';\nimport MapCache from './_MapCache';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {\n    cache = this.__data__ = new MapCache(cache.__data__);\n  }\n  cache.set(key, value);\n  return this;\n}\n\nexport default stackSet;\n","import ListCache from './_ListCache';\nimport stackClear from './_stackClear';\nimport stackDelete from './_stackDelete';\nimport stackGet from './_stackGet';\nimport stackHas from './_stackHas';\nimport stackSet from './_stackSet';\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nexport default Stack;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nexport default arrayEach;\n","import eq from './eq';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\nexport default assignValue;\n","import assignValue from './_assignValue';\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : source[key];\n\n    assignValue(object, key, newValue);\n  }\n  return object;\n}\n\nexport default copyObject;\n","import getPrototype from './_getPrototype';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,\n  // that are composed entirely of index properties, return `false` for\n  // `hasOwnProperty` checks of them.\n  return hasOwnProperty.call(object, key) ||\n    (typeof object == 'object' && key in object && getPrototype(object) === null);\n}\n\nexport default baseHas;\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = Object.keys;\n\n/**\n * The base implementation of `_.keys` which doesn't skip the constructor\n * property of prototypes or treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  return nativeKeys(Object(object));\n}\n\nexport default baseKeys;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nexport default baseTimes;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nexport default baseProperty;\n","import baseProperty from './_baseProperty';\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a\n * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects\n * Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nexport default getLength;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length,\n *  else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nexport default isLength;\n","import getLength from './_getLength';\nimport isFunction from './isFunction';\nimport isLength from './isLength';\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value)) && !isFunction(value);\n}\n\nexport default isArrayLike;\n","import isArrayLike from './isArrayLike';\nimport isObjectLike from './isObjectLike';\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nexport default isArrayLikeObject;\n","import isArrayLikeObject from './isArrayLikeObject';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\nexport default isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @type {Function}\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","import isArray from './isArray';\nimport isObjectLike from './isObjectLike';\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\nexport default isString;\n","import baseTimes from './_baseTimes';\nimport isArguments from './isArguments';\nimport isArray from './isArray';\nimport isLength from './isLength';\nimport isString from './isString';\n\n/**\n * Creates an array of index keys for `object` values of arrays,\n * `arguments` objects, and strings, otherwise `null` is returned.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array|null} Returns index keys, else `null`.\n */\nfunction indexKeys(object) {\n  var length = object ? object.length : undefined;\n  if (isLength(length) &&\n      (isArray(object) || isString(object) || isArguments(object))) {\n    return baseTimes(length, String);\n  }\n  return null;\n}\n\nexport default indexKeys;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nexport default isIndex;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nexport default isPrototype;\n","import baseHas from './_baseHas';\nimport baseKeys from './_baseKeys';\nimport indexKeys from './_indexKeys';\nimport isArrayLike from './isArrayLike';\nimport isIndex from './_isIndex';\nimport isPrototype from './_isPrototype';\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  var isProto = isPrototype(object);\n  if (!(isProto || isArrayLike(object))) {\n    return baseKeys(object);\n  }\n  var indexes = indexKeys(object),\n      skipIndexes = !!indexes,\n      result = indexes || [],\n      length = result.length;\n\n  for (var key in object) {\n    if (baseHas(object, key) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n        !(isProto && key == 'constructor')) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default keys;\n","import copyObject from './_copyObject';\nimport keys from './keys';\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nexport default baseAssign;\n","/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\nexport default cloneBuffer;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nexport default copyArray;\n","/** Built-in value references. */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nfunction getSymbols(object) {\n  // Coerce `object` to an object to avoid non-object errors in V8.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.\n  return getOwnPropertySymbols(Object(object));\n}\n\n// Fallback for IE < 11.\nif (!getOwnPropertySymbols) {\n  getSymbols = function() {\n    return [];\n  };\n}\n\nexport default getSymbols;\n","import copyObject from './_copyObject';\nimport getSymbols from './_getSymbols';\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nexport default copySymbols;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nexport default arrayPush;\n","import arrayPush from './_arrayPush';\nimport isArray from './isArray';\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nexport default baseGetAllKeys;\n","import baseGetAllKeys from './_baseGetAllKeys';\nimport getSymbols from './_getSymbols';\nimport keys from './keys';\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nexport default getAllKeys;\n","import getNative from './_getNative';\nimport root from './_root';\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nexport default DataView;\n","import getNative from './_getNative';\nimport root from './_root';\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nexport default Promise;\n","import getNative from './_getNative';\nimport root from './_root';\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nexport default Set;\n","import getNative from './_getNative';\nimport root from './_root';\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nexport default WeakMap;\n","import DataView from './_DataView';\nimport Map from './_Map';\nimport Promise from './_Promise';\nimport Set from './_Set';\nimport WeakMap from './_WeakMap';\nimport toSource from './_toSource';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction getTag(value) {\n  return objectToString.call(value);\n}\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nexport default getTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nexport default initCloneArray;\n","import root from './_root';\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nexport default Uint8Array;\n","import Uint8Array from './_Uint8Array';\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nexport default cloneArrayBuffer;\n","import cloneArrayBuffer from './_cloneArrayBuffer';\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nexport default cloneDataView;\n","/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `Map#set` because it doesn't return the map instance in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\nexport default addMapEntry;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nexport default arrayReduce;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nexport default mapToArray;\n","import addMapEntry from './_addMapEntry';\nimport arrayReduce from './_arrayReduce';\nimport mapToArray from './_mapToArray';\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\nexport default cloneMap;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nexport default cloneRegExp;\n","/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  set.add(value);\n  return set;\n}\n\nexport default addSetEntry;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nexport default setToArray;\n","import addSetEntry from './_addSetEntry';\nimport arrayReduce from './_arrayReduce';\nimport setToArray from './_setToArray';\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\nexport default cloneSet;\n","import root from './_root';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nexport default cloneSymbol;\n","import cloneArrayBuffer from './_cloneArrayBuffer';\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nexport default cloneTypedArray;\n","import cloneArrayBuffer from './_cloneArrayBuffer';\nimport cloneDataView from './_cloneDataView';\nimport cloneMap from './_cloneMap';\nimport cloneRegExp from './_cloneRegExp';\nimport cloneSet from './_cloneSet';\nimport cloneSymbol from './_cloneSymbol';\nimport cloneTypedArray from './_cloneTypedArray';\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nexport default initCloneByTag;\n","import isObject from './isObject';\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\nexport default baseCreate;\n","import baseCreate from './_baseCreate';\nimport getPrototype from './_getPrototype';\nimport isPrototype from './_isPrototype';\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nexport default initCloneObject;\n","import Stack from './_Stack';\nimport arrayEach from './_arrayEach';\nimport assignValue from './_assignValue';\nimport baseAssign from './_baseAssign';\nimport cloneBuffer from './_cloneBuffer';\nimport copyArray from './_copyArray';\nimport copySymbols from './_copySymbols';\nimport getAllKeys from './_getAllKeys';\nimport getTag from './_getTag';\nimport initCloneArray from './_initCloneArray';\nimport initCloneByTag from './_initCloneByTag';\nimport initCloneObject from './_initCloneObject';\nimport isArray from './isArray';\nimport isBuffer from './isBuffer';\nimport isHostObject from './_isHostObject';\nimport isObject from './isObject';\nimport keys from './keys';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  // Recursively populate clone (susceptible to call stack limits).\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\nexport default baseClone;\n","import baseClone from './_baseClone';\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, false, true);\n}\n\nexport default clone;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/comparearrays\n */\n\n/**\n * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array\n * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,\n * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned\n * it means that arrays differ.\n *\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 2 ] );\t\t// 'same'\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 2, 1 ] );\t\t// 'prefix'\n *\t\tcompareArrays( [ 0, 2 ], [ 0 ] );\t\t\t// 'extension'\n *\t\tcompareArrays( [ 0, 2 ], [ 1, 2 ] );\t\t// 0\n *\t\tcompareArrays( [ 0, 2 ], [ 0, 1 ] );\t\t// 1\n *\n * @param {Array} a Array that is compared.\n * @param {Array} b Array to compare with.\n * @returns {module:utils/comparearrays~ArrayRelation} How array `a` is related to `b`.\n */\nexport default function compareArrays( a, b ) {\n\tconst minLen = Math.min( a.length, b.length );\n\n\tfor ( let i = 0; i < minLen; i++ ) {\n\t\tif ( a[ i ] != b[ i ] ) {\n\t\t\t// The arrays are different.\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t// Both arrays were same at all points.\n\tif ( a.length == b.length ) {\n\t\t// If their length is also same, they are the same.\n\t\treturn 'same';\n\t} else if ( a.length < b.length ) {\n\t\t// Compared array is shorter so it is a prefix of the other array.\n\t\treturn 'prefix';\n\t} else {\n\t\t// Compared array is longer so it is an extension of the other array.\n\t\treturn 'extension';\n\t}\n}\n\n/**\n * @typedef {'extension'|'same'|'prefix'} module:utils/comparearrays~ArrayRelation\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/node\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport clone from '@ckeditor/ckeditor5-utils/src/lib/lodash/clone';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Abstract tree view node class.\n *\n * @abstract\n */\nexport default class Node {\n\t/**\n\t * Creates a tree view node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\t}\n\n\t/**\n\t * Index of the node in the parent element or null if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that view tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// No parent or child doesn't exist in parent's children.\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) == -1 ) {\n\t\t\t/**\n\t\t\t * The node's parent does not contain this node. It means that the document tree is corrupted.\n\t\t\t *\n\t\t\t * @error view-node-not-found-in-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-node-not-found-in-parent: The node\\'s parent does not contain this node.' );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Node's next sibling, or `null` if it is the last child.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling, or `null` if it is the first child.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * Top-most ancestor of the node. If the node has no parent it is the root itself.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * {@link module:engine/view/document~Document View document} that owns this node, or `null` if the node is inside\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/document~Document|null}\n\t */\n\tget document() {\n\t\t// Parent might be Node, null or DocumentFragment.\n\t\tif ( this.parent instanceof Node ) {\n\t\t\treturn this.parent.document;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.index );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/view/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/view/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/view/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/view/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Removes node from parent.\n\t *\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Changed node.\n\t * @fires change\n\t */\n\t_fireChange( type, node ) {\n\t\tthis.fire( 'change:' + type, node );\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._fireChange( type, node );\n\t\t}\n\t}\n\n\t/**\n\t * Custom toJSON method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} Clone of this object with the parent property removed.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tdelete json.parent;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Checks whether given view tree object is of given type.\n\t *\n\t * This method is useful when processing view tree objects that are of unknown type. For example, a function\n\t * may return {@link module:engine/view/documentfragment~DocumentFragment} or {@link module:engine/view/node~Node}\n\t * that can be either text node or element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tobj.is( 'node' ); // true for any node, false for document fragment and text fragment\n\t *\t\tobj.is( 'documentFragment' ); // true for document fragment, false for any node\n\t *\t\tobj.is( 'element' ); // true for any element, false for text node or document fragment\n\t *\t\tobj.is( 'element', 'p' ); // true only for element which name is 'p'\n\t *\t\tobj.is( 'p' ); // shortcut for obj.is( 'element', 'p' )\n\t *\t\tobj.is( 'text' ); // true for text node, false for element and document fragment\n\t *\n\t * @method #is\n\t * @param {'element'|'containerElement'|'attributeElement'|'emptyElement'|'uiElement'|\n\t * 'rootElement'|'documentFragment'|'text'|'textProxy'} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'node';\n\t}\n\n\t/**\n\t * Clones this node.\n\t *\n\t * @protected\n\t * @method #_clone\n\t * @returns {module:engine/view/node~Node} Clone of this node.\n\t */\n\n\t/**\n\t * Checks if provided node is similar to this node.\n\t *\n\t * @method #isSimilar\n\t * @returns {Boolean} True if nodes are similar.\n\t */\n}\n\n/**\n * Fired when list of {@link module:engine/view/element~Element elements} children changes.\n *\n * Change event is bubbled – it is fired on all ancestors.\n *\n * @event change:children\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * Fired when list of {@link module:engine/view/element~Element elements} attributes changes.\n *\n * Change event is bubbled – it is fired on all ancestors.\n *\n * @event change:attributes\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * Fired when {@link module:engine/view/text~Text text nodes} data changes.\n *\n * Change event is bubbled – it is fired on all ancestors.\n *\n * @event change:text\n * @param {module:engine/view/node~Node} changedNode\n */\n\n/**\n * @event change\n */\n\nmix( Node, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/text\n */\n\nimport Node from './node';\n\n/**\n * Tree view text node.\n *\n * @extends module:engine/view/node~Node\n */\nexport default class Text extends Node {\n\t/**\n\t * Creates a tree view text node.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/view/writer~Writer#createText} method instead.\n\t *\n\t * @protected\n\t * @param {String} data Text.\n\t */\n\tconstructor( data ) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The text content.\n\t\t *\n\t\t * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.\n\t\t *\n\t\t * @protected\n\t\t * @member {String} module:engine/view/text~Text#_textData\n\t\t */\n\t\tthis._textData = data;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type ) {\n\t\treturn type == 'text' || super.is( type );\n\t}\n\n\t/**\n\t * The text content.\n\t *\n\t * @returns {String}\n\t */\n\tget data() {\n\t\treturn this._textData;\n\t}\n\n\t/**\n\t * This getter is required when using the addition assignment operator on protected property:\n\t *\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst bar = new Text( 'bar' );\n\t *\n\t *\t\tfoo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`\n\t *\t\tconsole.log( foo.data ); // prints: 'foobar'\n\t *\n\t * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.\n\t *\n\t * @protected\n\t * @returns {String}\n\t */\n\tget _data() {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.\n\t *\n\t * @protected\n\t * @fires change:text\n\t * @param {String} data New data for the text node.\n\t */\n\tset _data( data ) {\n\t\tthis._fireChange( 'text', this );\n\n\t\tthis._textData = data;\n\t}\n\n\t/**\n\t * Checks if this text node is similar to other text node.\n\t * Both nodes should have the same data to be considered as similar.\n\t *\n\t * @param {module:engine/view/text~Text} otherNode Node to check if it is same as this node.\n\t * @returns {Boolean}\n\t */\n\tisSimilar( otherNode ) {\n\t\tif ( !( otherNode instanceof Text ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this === otherNode || this.data === otherNode.data;\n\t}\n\n\t/**\n\t * Clones this node.\n\t *\n\t * @protected\n\t * @returns {module:engine/view/text~Text} Text node that is a clone of this node.\n\t */\n\t_clone() {\n\t\treturn new Text( this.data );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/textproxy\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * TextProxy is a wrapper for substring of {@link module:engine/view/text~Text}. Instance of this class is created by\n * {@link module:engine/view/treewalker~TreeWalker} when only a part of {@link module:engine/view/text~Text} needs to be returned.\n *\n * `TextProxy` has an API similar to {@link module:engine/view/text~Text Text} and allows to do most of the common tasks performed\n * on view nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/view/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is a readonly interface.\n *\n * **Note:** `TextProxy` instances are created on the fly basing on the current state of parent {@link module:engine/view/text~Text}.\n * Because of this it is highly unrecommended to store references to `TextProxy instances because they might get\n * invalidated due to operations on Document. Also TextProxy is not a {@link module:engine/view/node~Node} so it can not be\n * inserted as a child of {@link module:engine/view/element~Element}.\n *\n * `TextProxy` instances are created by {@link module:engine/view/treewalker~TreeWalker view tree walker}. You should not need to create\n * an instance of this class by your own.\n */\nexport default class TextProxy {\n\t/**\n\t * Creates a text proxy.\n\t *\n\t * @protected\n\t * @param {module:engine/view/text~Text} textNode Text node which part is represented by this text proxy.\n\t * @param {Number} offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}\n\t * from which the text proxy starts.\n\t * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n\t * @constructor\n\t */\n\tconstructor( textNode, offsetInText, length ) {\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/text~Text} element which TextProxy is a substring.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/text~Text} module:engine/view/textproxy~TextProxy#textNode\n\t\t */\n\t\tthis.textNode = textNode;\n\n\t\tif ( offsetInText < 0 || offsetInText > textNode.data.length ) {\n\t\t\t/**\n\t\t\t * Given offsetInText value is incorrect.\n\t\t\t *\n\t\t\t * @error view-textproxy-wrong-offsetintext\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.' );\n\t\t}\n\n\t\tif ( length < 0 || offsetInText + length > textNode.data.length ) {\n\t\t\t/**\n\t\t\t * Given length value is incorrect.\n\t\t\t *\n\t\t\t * @error view-textproxy-wrong-length\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-textproxy-wrong-length: Given length value is incorrect.' );\n\t\t}\n\n\t\t/**\n\t\t * Text data represented by this text proxy.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} module:engine/view/textproxy~TextProxy#data\n\t\t */\n\t\tthis.data = textNode.data.substring( offsetInText, offsetInText + length );\n\n\t\t/**\n\t\t * Offset in the `textNode` where this `TextProxy` instance starts.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} module:engine/view/textproxy~TextProxy#offsetInText\n\t\t */\n\t\tthis.offsetInText = offsetInText;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget offsetSize() {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}\n\t * (`true`) or the whole text node (`false`).\n\t *\n\t * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}\n\t * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n\t * text node size.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isPartial() {\n\t\treturn this.data.length !== this.textNode.data.length;\n\t}\n\n\t/**\n\t * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tget parent() {\n\t\treturn this.textNode.parent;\n\t}\n\n\t/**\n\t * Root of this text proxy, which is same as root of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.textNode.root;\n\t}\n\n\t/**\n\t * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/document~Document|null}\n\t */\n\tget document() {\n\t\treturn this.textNode.document;\n\t}\n\n\t/**\n\t * Checks whether given view tree object is of given type.\n\t *\n\t * Read more in {@link module:engine/view/node~Node#is}.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'textProxy';\n\t}\n\n\t/**\n\t * Returns ancestors array of this text proxy.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` {#textNode} will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to\n\t * root element, otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this.textNode : this.parent;\n\n\t\twhile ( parent !== null ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/objecttomap\n */\n\n/**\n * Transforms object to map.\n *\n *\t\tconst map = objectToMap( { 'foo': 1, 'bar': 2 } );\n *\t\tmap.get( 'foo' ); // 1\n *\n * @param {Object} obj Object to transform.\n * @returns {Map} Map created from object.\n */\nexport default function objectToMap( obj ) {\n\tconst map = new Map();\n\n\tfor ( const key in obj ) {\n\t\tmap.set( key, obj[ key ] );\n\t}\n\n\treturn map;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/isiterable\n */\n\n/**\n * Checks if value implements iterator interface.\n *\n * @param {*} value The value to check.\n * @returns {Boolean} True if value implements iterator interface.\n */\nexport default function isIterable( value ) {\n\treturn !!( value && value[ Symbol.iterator ] );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/matcher\n */\n\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n\t/**\n\t * Creates new instance of Matcher.\n\t *\n\t * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n\t * more information.\n\t */\n\tconstructor( ...pattern ) {\n\t\t/**\n\t\t * @private\n\t\t * @type {Array<String|RegExp|Object>}\n\t\t */\n\t\tthis._patterns = [];\n\n\t\tthis.add( ...pattern );\n\t}\n\n\t/**\n\t * Adds pattern or patterns to matcher instance.\n\t *\n\t *\t\t// String.\n\t *\t\tmatcher.add( 'div' );\n\t *\n\t *\t\t// Regular expression.\n\t *\t\tmatcher.add( /^\\w/ );\n\t *\n\t *\t\t// Single class.\n\t *\t\tmatcher.add( {\n\t *\t\t\tclasses: 'foobar'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n\t *\n\t * Multiple patterns can be added in one call:\n\t *\n\t * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n\t *\n\t * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n\t * is provided it will be used to match element's name. Pattern can be also provided in a form\n\t * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n\t * Function's return value will be stored under `match` key of the object returned from\n\t * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n\t * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n\t * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n\t * represents attribute name. Value under that key can be either:\n\t * * `true` - then attribute is just required (can be empty),\n\t * * a string - then attribute has to be equal, or\n\t * * a regular expression - then attribute has to match the expression.\n\t * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n\t * provided in a form of string or regular expression.\n\t * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n\t * represents style name. Value under that key can be either a string or a regular expression and it will be used\n\t * to match style value.\n\t */\n\tadd( ...pattern ) {\n\t\tfor ( let item of pattern ) {\n\t\t\t// String or RegExp pattern is used as element's name.\n\t\t\tif ( typeof item == 'string' || item instanceof RegExp ) {\n\t\t\t\titem = { name: item };\n\t\t\t}\n\n\t\t\t// Single class name/RegExp can be provided.\n\t\t\tif ( item.classes && ( typeof item.classes == 'string' || item.classes instanceof RegExp ) ) {\n\t\t\t\titem.classes = [ item.classes ];\n\t\t\t}\n\n\t\t\tthis._patterns.push( item );\n\t\t}\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns match information about first found\n\t * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n\t *\n\t * Example of returned object:\n\t *\n\t *\t\t{\n\t *\t\t\telement: <instance of found element>,\n\t *\t\t\tpattern: <pattern used to match found element>,\n\t *\t\t\tmatch: {\n\t *\t\t\t\tname: true,\n\t *\t\t\t\tattributes: [ 'title', 'href' ],\n\t *\t\t\t\tclasses: [ 'foo' ],\n\t *\t\t\t\tstyles: [ 'color', 'position' ]\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#matchAll\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Object|null} result\n\t * @returns {module:engine/view/element~Element} result.element Matched view element.\n\t * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n\t * @returns {Object} result.match Object representing matched element parts.\n\t * @returns {Boolean} [result.match.name] True if name of the element was matched.\n\t * @returns {Array} [result.match.attributes] Array with matched attribute names.\n\t * @returns {Array} [result.match.classes] Array with matched class names.\n\t * @returns {Array} [result.match.styles] Array with matched style names.\n\t */\n\tmatch( ...element ) {\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns array of match information with all found\n\t * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#match\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n\t * see {@link module:engine/view/matcher~Matcher#match match method} description.\n\t */\n\tmatchAll( ...element ) {\n\t\tconst results = [];\n\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tresults.push( {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results.length > 0 ? results : null;\n\t}\n\n\t/**\n\t * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n\t * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n\t *\n\t * @returns {String|null} Element name trying to match.\n\t */\n\tgetElementName() {\n\t\tif ( this._patterns.length !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst pattern = this._patterns[ 0 ];\n\t\tconst name = pattern.name;\n\n\t\treturn ( typeof pattern != 'function' && name && !( name instanceof RegExp ) ) ? name : null;\n\t}\n}\n\n// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\nfunction isElementMatching( element, pattern ) {\n\t// If pattern is provided as function - return result of that function;\n\tif ( typeof pattern == 'function' ) {\n\t\treturn pattern( element );\n\t}\n\n\tconst match = {};\n\t// Check element's name.\n\tif ( pattern.name ) {\n\t\tmatch.name = matchName( pattern.name, element.name );\n\n\t\tif ( !match.name ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's attributes.\n\tif ( pattern.attributes ) {\n\t\tmatch.attributes = matchAttributes( pattern.attributes, element );\n\n\t\tif ( !match.attributes ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's classes.\n\tif ( pattern.classes ) {\n\t\tmatch.classes = matchClasses( pattern.classes, element );\n\n\t\tif ( !match.classes ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Check element's styles.\n\tif ( pattern.styles ) {\n\t\tmatch.styles = matchStyles( pattern.styles, element );\n\n\t\tif ( !match.styles ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\nfunction matchName( pattern, name ) {\n\t// If pattern is provided as RegExp - test against this regexp.\n\tif ( pattern instanceof RegExp ) {\n\t\treturn pattern.test( name );\n\t}\n\n\treturn pattern === name;\n}\n\n// Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchAttributes( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const name in patterns ) {\n\t\tconst pattern = patterns[ name ];\n\n\t\tif ( element.hasAttribute( name ) ) {\n\t\t\tconst attribute = element.getAttribute( name );\n\n\t\t\tif ( pattern === true ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else if ( pattern instanceof RegExp ) {\n\t\t\t\tif ( pattern.test( attribute ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if ( attribute === pattern ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\nfunction matchClasses( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const pattern of patterns ) {\n\t\tif ( pattern instanceof RegExp ) {\n\t\t\tconst classes = element.getClassNames();\n\n\t\t\tfor ( const name of classes ) {\n\t\t\t\tif ( pattern.test( name ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( match.length === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if ( element.hasClass( pattern ) ) {\n\t\t\tmatch.push( pattern );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\nfunction matchStyles( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const name in patterns ) {\n\t\tconst pattern = patterns[ name ];\n\n\t\tif ( element.hasStyle( name ) ) {\n\t\t\tconst style = element.getStyle( name );\n\n\t\t\tif ( pattern instanceof RegExp ) {\n\t\t\t\tif ( pattern.test( style ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if ( style === pattern ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n *\n *\t\t// Match view element's name.\n *\t\tconst pattern = { name: /^p/ };\n *\n *\t\t// Match view element which has matching attributes.\n *\t\tconst pattern = {\n *\t\t\tattribute: {\n *\t\t\t\ttitle: 'foobar',\t// Attribute title should equal 'foobar'.\n *\t\t\t\tfoo: /^\\w+/,\t\t// Attribute foo should match /^\\w+/ regexp.\n *\t\t\t\tbar: true\t\t\t// Attribute bar should be set (can be empty).\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has given class.\n *\t\tconst pattern = {\n *\t\t\tclasses: 'foobar'\n *\t\t};\n *\n *\t\t// Match view element class using regular expression.\n *\t\tconst pattern = {\n *\t\t\tclasses: /foo.../\n *\t\t};\n *\n *\t\t// Multiple classes to match.\n *\t\tconst pattern = {\n *\t\t\tclasses: [ 'baz', 'bar', /foo.../ ]\n *\t\t}:\n *\n *\t\t// Match view element which has given styles.\n *\t\tconst pattern = {\n *\t\t\tstyles: {\n *\t\t\t\tposition: 'absolute',\n *\t\t\t\tcolor: /^\\w*blue$/\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Pattern with multiple properties.\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/element\n */\n\nimport Node from './node';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport objectToMap from '@ckeditor/ckeditor5-utils/src/objecttomap';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport isPlainObject from '@ckeditor/ckeditor5-utils/src/lib/lodash/isPlainObject';\nimport Matcher from './matcher';\n\n/**\n * View element.\n *\n * The editing engine does not define a fixed semantics of its elements (it is \"DTD-free\").\n * This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. When creating an element you should use one of the following methods:\n *\n * * {@link module:engine/view/writer~Writer#createContainerElement `writer.createContainerElement()`} in order to create\n * a {@link module:engine/view/containerelement~ContainerElement},\n * * {@link module:engine/view/writer~Writer#createAttributeElement `writer.createAttributeElement()`} in order to create\n * a {@link module:engine/view/attributeelement~AttributeElement},\n * * {@link module:engine/view/writer~Writer#createEmptyElement `writer.createEmptyElement()`} in order to create\n * a {@link module:engine/view/emptyelement~EmptyElement}.\n * * {@link module:engine/view/writer~Writer#createUIElement `writer.createUIElement()`} in order to create\n * a {@link module:engine/view/uielement~UIElement}.\n * * {@link module:engine/view/writer~Writer#createEditableElement `writer.createEditableElement()`} in order to create\n * a {@link module:engine/view/editableelement~EditableElement}.\n *\n * Note that for view elements which are not created from the model, like elements from mutations, paste or\n * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element, so\n * these will be instances of the {@link module:engine/view/element~Element}.\n *\n * @extends module:engine/view/node~Node\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a view element.\n\t *\n\t * Attributes can be passed in various formats:\n\t *\n\t *\t\tnew Element( 'div', { 'class': 'editor', 'contentEditable': 'true' } ); // object\n\t *\t\tnew Element( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator\n\t *\t\tnew Element( 'div', mapOfAttributes ); // map\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code. Use the\n\t * {@link module:engine/view/writer~Writer#createAttributeElement} for inline element,\n\t * {@link module:engine/view/writer~Writer#createContainerElement} for block element,\n\t * {@link module:engine/view/writer~Writer#createEditableElement} for editable element,\n\t * {@link module:engine/view/writer~Writer#createEmptyElement} for empty element or\n\t * {@link module:engine/view/writer~Writer#createUIElement} for UI element instead.\n\t *\n\t * @protected\n\t * @param {String} name Node name.\n\t * @param {Object|Iterable} [attrs] Collection of attributes.\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * List of nodes to be inserted into created element.\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Name of the element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Map of attributes, where attributes names are keys and attributes values are values.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map} #_attrs\n\t\t */\n\t\tthis._attrs = parseAttributes( attrs );\n\n\t\t/**\n\t\t * Array of child nodes.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis._children = [];\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\n\t\t/**\n\t\t * Set of classes associated with element instance.\n\t\t *\n\t\t * @protected\n\t\t * @member {Set}\n\t\t */\n\t\tthis._classes = new Set();\n\n\t\tif ( this._attrs.has( 'class' ) ) {\n\t\t\t// Remove class attribute and handle it by class set.\n\t\t\tconst classString = this._attrs.get( 'class' );\n\t\t\tparseClasses( this._classes, classString );\n\t\t\tthis._attrs.delete( 'class' );\n\t\t}\n\n\t\t/**\n\t\t * Map of styles.\n\t\t *\n\t\t * @protected\n\t\t * @member {Set} module:engine/view/element~Element#_styles\n\t\t */\n\t\tthis._styles = new Map();\n\n\t\tif ( this._attrs.has( 'style' ) ) {\n\t\t\t// Remove style attribute and handle it by styles map.\n\t\t\tparseInlineStyles( this._styles, this._attrs.get( 'style' ) );\n\t\t\tthis._attrs.delete( 'style' );\n\t\t}\n\n\t\t/**\n\t\t * Map of custom properties.\n\t\t * Custom properties can be added to element instance, will be cloned but not rendered into DOM.\n\t\t *\n\t\t * @protected\n\t\t * @memeber {Map}\n\t\t */\n\t\tthis._customProperties = new Map();\n\t}\n\n\t/**\n\t * Number of element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._children.length === 0;\n\t}\n\n\t/**\n\t * Checks whether given view tree object is of given type.\n\t *\n\t * Read more in {@link module:engine/view/node~Node#is}.\n\t *\n\t * @param {String} type\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'element' || type == this.name || super.is( type );\n\t\t} else {\n\t\t\treturn type == 'element' && name == this.name;\n\t\t}\n\t}\n\n\t/**\n\t * Gets child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/view/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children[ index ];\n\t}\n\n\t/**\n\t * Gets index of the given child node. Returns `-1` if child node is not found.\n\t *\n\t * @param {module:engine/view/node~Node} node Child node.\n\t * @returns {Number} Index of the child node.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.indexOf( node );\n\t}\n\n\t/**\n\t * Gets child nodes iterator.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.\n\t *\n\t * @returns {Iterable.<String>} Keys for attributes.\n\t */\n\t* getAttributeKeys() {\n\t\tif ( this._classes.size > 0 ) {\n\t\t\tyield 'class';\n\t\t}\n\n\t\tif ( this._styles.size > 0 ) {\n\t\t\tyield 'style';\n\t\t}\n\n\t\t// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.\n\t\t// It can be simplified to `yield* this._attrs.keys();`.\n\t\tfor ( const key of this._attrs.keys() ) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this element's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t* getAttributes() {\n\t\tyield* this._attrs.entries();\n\n\t\tif ( this._classes.size > 0 ) {\n\t\t\tyield [ 'class', this.getAttribute( 'class' ) ];\n\t\t}\n\n\t\tif ( this._styles.size > 0 ) {\n\t\t\tyield [ 'style', this.getAttribute( 'style' ) ];\n\t\t}\n\t}\n\n\t/**\n\t * Gets attribute by key. If attribute is not present - returns undefined.\n\t *\n\t * @param {String} key Attribute key.\n\t * @returns {String|undefined} Attribute value.\n\t */\n\tgetAttribute( key ) {\n\t\tif ( key == 'class' ) {\n\t\t\tif ( this._classes.size > 0 ) {\n\t\t\t\treturn [ ...this._classes ].join( ' ' );\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( key == 'style' ) {\n\t\t\tif ( this._styles.size > 0 ) {\n\t\t\t\tlet styleString = '';\n\n\t\t\t\tfor ( const [ property, value ] of this._styles ) {\n\t\t\t\t\tstyleString += `${ property }:${ value };`;\n\t\t\t\t}\n\n\t\t\t\treturn styleString;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns a boolean indicating whether an attribute with the specified key exists in the element.\n\t *\n\t * @param {String} key Attribute key.\n\t * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.\n\t */\n\thasAttribute( key ) {\n\t\tif ( key == 'class' ) {\n\t\t\treturn this._classes.size > 0;\n\t\t}\n\n\t\tif ( key == 'style' ) {\n\t\t\treturn this._styles.size > 0;\n\t\t}\n\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Checks if this element is similar to other element.\n\t * Both elements should have the same name and attributes to be considered as similar. Two similar elements\n\t * can contain different set of children nodes.\n\t *\n\t * @param {module:engine/view/element~Element} otherElement\n\t * @returns {Boolean}\n\t */\n\tisSimilar( otherElement ) {\n\t\tif ( !( otherElement instanceof Element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If exactly the same Element is provided - return true immediately.\n\t\tif ( this === otherElement ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check element name.\n\t\tif ( this.name != otherElement.name ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check number of attributes, classes and styles.\n\t\tif ( this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size ||\n\t\t\tthis._styles.size !== otherElement._styles.size ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes are the same.\n\t\tfor ( const [ key, value ] of this._attrs ) {\n\t\t\tif ( !otherElement._attrs.has( key ) || otherElement._attrs.get( key ) !== value ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if classes are the same.\n\t\tfor ( const className of this._classes ) {\n\t\t\tif ( !otherElement._classes.has( className ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles are the same.\n\t\tfor ( const [ property, value ] of this._styles ) {\n\t\t\tif ( !otherElement._styles.has( property ) || otherElement._styles.get( property ) !== value ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if class is present.\n\t * If more then one class is provided - returns true only when all classes are present.\n\t *\n\t *\t\telement.hasClass( 'foo' ); // Returns true if 'foo' class is present.\n\t *\t\telement.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.\n\t *\n\t * @param {...String} className\n\t */\n\thasClass( ...className ) {\n\t\tfor ( const name of className ) {\n\t\t\tif ( !this._classes.has( name ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns iterator that contains all class names.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetClassNames() {\n\t\treturn this._classes.keys();\n\t}\n\n\t/**\n\t * Returns style value for given property.\n\t * Undefined is returned if style does not exist.\n\t *\n\t * @param {String} property\n\t * @returns {String|undefined}\n\t */\n\tgetStyle( property ) {\n\t\treturn this._styles.get( property );\n\t}\n\n\t/**\n\t * Returns iterator that contains all style names.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetStyleNames() {\n\t\treturn this._styles.keys();\n\t}\n\n\t/**\n\t * Returns true if style keys are present.\n\t * If more then one style property is provided - returns true only when all properties are present.\n\t *\n\t *\t\telement.hasStyle( 'color' ); // Returns true if 'border-top' style is present.\n\t *\t\telement.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.\n\t *\n\t * @param {...String} property\n\t */\n\thasStyle( ...property ) {\n\t\tfor ( const name of property ) {\n\t\t\tif ( !this._styles.has( name ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns ancestor element that match specified pattern.\n\t * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.\n\t *\n\t * @see module:engine/view/matcher~Matcher\n\t * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.\n\t * See {@link module:engine/view/matcher~Matcher}.\n\t * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.\n\t */\n\tfindAncestor( ...patterns ) {\n\t\tconst matcher = new Matcher( ...patterns );\n\t\tlet parent = this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( matcher.match( parent ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the custom property value for the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @returns {*}\n\t */\n\tgetCustomProperty( key ) {\n\t\treturn this._customProperties.get( key );\n\t}\n\n\t/**\n\t * Returns an iterator which iterates over this element's custom properties.\n\t * Iterator provides `[ key, value ]` pairs for each stored property.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t* getCustomProperties() {\n\t\tyield* this._customProperties.entries();\n\t}\n\n\t/**\n\t * Returns identity string based on element's name, styles, classes and other attributes.\n\t * Two elements that {@link #isSimilar are similar} will have same identity string.\n\t * It has the following format:\n\t *\n\t *\t\t'name class=\"class1,class2\" style=\"style1:value1;style2:value2\" attr1=\"val1\" attr2=\"val2\"'\n \t *\n\t * For example:\n\t *\n\t *\t\tconst element = writer.createContainerElement( 'foo', {\n\t *\t\t\tbanana: '10',\n\t *\t\t\tapple: '20',\n\t *\t\t\tstyle: 'color: red; border-color: white;',\n\t *\t\t\tclass: 'baz'\n\t *\t\t} );\n\t *\n\t *\t\t// returns 'foo class=\"baz\" style=\"border-color:white;color:red\" apple=\"20\" banana=\"10\"'\n\t *\t\telement.getIdentity();\n\t *\n\t * NOTE: Classes, styles and other attributes are sorted alphabetically.\n\t *\n\t * @returns {String}\n\t */\n\tgetIdentity() {\n\t\tconst classes = Array.from( this._classes ).sort().join( ',' );\n\t\tconst styles = Array.from( this._styles ).map( i => `${ i[ 0 ] }:${ i[ 1 ] }` ).sort().join( ';' );\n\t\tconst attributes = Array.from( this._attrs ).map( i => `${ i[ 0 ] }=\"${ i[ 1 ] }\"` ).sort().join( ' ' );\n\n\t\treturn this.name +\n\t\t\t( classes == '' ? '' : ` class=\"${ classes }\"` ) +\n\t\t\t( styles == '' ? '' : ` style=\"${ styles }\"` ) +\n\t\t\t( attributes == '' ? '' : ` ${ attributes }` );\n\t}\n\n\t/**\n\t * Clones provided element.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any children.\n\t * @returns {module:engine/view/element~Element} Clone of this element.\n\t */\n\t_clone( deep = false ) {\n\t\tconst childrenClone = [];\n\n\t\tif ( deep ) {\n\t\t\tfor ( const child of this.getChildren() ) {\n\t\t\t\tchildrenClone.push( child._clone( deep ) );\n\t\t\t}\n\t\t}\n\n\t\t// ContainerElement and AttributeElement should be also cloned properly.\n\t\tconst cloned = new this.constructor( this.name, this._attrs, childrenClone );\n\n\t\t// Classes and styles are cloned separately - this solution is faster than adding them back to attributes and\n\t\t// parse once again in constructor.\n\t\tcloned._classes = new Set( this._classes );\n\t\tcloned._styles = new Map( this._styles );\n\n\t\t// Clone custom properties.\n\t\tcloned._customProperties = new Map( this._customProperties );\n\n\t\t// Clone filler offset method.\n\t\t// We can't define this method in a prototype because it's behavior which\n\t\t// is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.\n\t\tcloned.getFillerOffset = this.getFillerOffset;\n\n\t\treturn cloned;\n\t}\n\n\t/**\n\t * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node\n\t * and sets the parent of these nodes to this element.\n\t *\n\t * @see module:engine/view/writer~Writer#insert\n\t * @protected\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Number} Number of appended nodes.\n\t */\n\t_appendChild( items ) {\n\t\treturn this._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n\t * this element.\n\t *\n\t * @see module:engine/view/writer~Writer#insert\n\t * @protected\n\t * @param {Number} index Position where nodes should be inserted.\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Number} Number of inserted nodes.\n\t */\n\t_insertChild( index, items ) {\n\t\tthis._fireChange( 'children', this );\n\t\tlet count = 0;\n\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\n\t\t\tthis._children.splice( index, 0, node );\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n\t *\n\t * @see module:engine/view/writer~Writer#remove\n\t * @param {Number} index Number of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @fires module:engine/view/node~Node#change\n\t * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tthis._fireChange( 'children', this );\n\n\t\tfor ( let i = index; i < index + howMany; i++ ) {\n\t\t\tthis._children[ i ].parent = null;\n\t\t}\n\n\t\treturn this._children.splice( index, howMany );\n\t}\n\n\t/**\n\t * Adds or overwrite attribute with a specified key and value.\n\t *\n\t * @see module:engine/view/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_setAttribute( key, value ) {\n\t\tvalue = String( value );\n\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tif ( key == 'class' ) {\n\t\t\tparseClasses( this._classes, value );\n\t\t} else if ( key == 'style' ) {\n\t\t\tparseInlineStyles( this._styles, value );\n\t\t} else {\n\t\t\tthis._attrs.set( key, value );\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t * @see module:engine/view/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Attribute key.\n\t * @returns {Boolean} Returns true if an attribute existed and has been removed.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeAttribute( key ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\t// Remove class attribute.\n\t\tif ( key == 'class' ) {\n\t\t\tif ( this._classes.size > 0 ) {\n\t\t\t\tthis._classes.clear();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove style attribute.\n\t\tif ( key == 'style' ) {\n\t\t\tif ( this._styles.size > 0 ) {\n\t\t\t\tthis._styles.clear();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Remove other attributes.\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Adds specified class.\n\t *\n\t *\t\telement._addClass( 'foo' ); // Adds 'foo' class.\n\t *\t\telement._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.\n\t *\n\t * @see module:engine/view/writer~Writer#addClass\n\t * @protected\n\t * @param {Array.<String>|String} className\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_addClass( className ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tclassName = Array.isArray( className ) ? className : [ className ];\n\t\tclassName.forEach( name => this._classes.add( name ) );\n\t}\n\n\t/**\n\t * Removes specified class.\n\t *\n\t *\t\telement._removeClass( 'foo' );  // Removes 'foo' class.\n\t *\t\telement._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.\n\t *\n\t * @see module:engine/view/writer~Writer#removeClass\n\t * @param {Array.<String>|String} className\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeClass( className ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tclassName = Array.isArray( className ) ? className : [ className ];\n\t\tclassName.forEach( name => this._classes.delete( name ) );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\telement._setStyle( 'color', 'red' );\n\t *\t\telement._setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t} );\n\t *\n\t * @see module:engine/view/writer~Writer#setStyle\n\t * @protected\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_setStyle( property, value ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tif ( isPlainObject( property ) ) {\n\t\t\tconst keys = Object.keys( property );\n\n\t\t\tfor ( const key of keys ) {\n\t\t\t\tthis._styles.set( key, property[ key ] );\n\t\t\t}\n\t\t} else {\n\t\t\tthis._styles.set( property, value );\n\t\t}\n\t}\n\n\t/**\n\t * Removes specified style.\n\t *\n\t *\t\telement._removeStyle( 'color' );  // Removes 'color' style.\n\t *\t\telement._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * @see module:engine/view/writer~Writer#removeStyle\n\t * @protected\n\t * @param {Array.<String>|String} property\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_removeStyle( property ) {\n\t\tthis._fireChange( 'attributes', this );\n\n\t\tproperty = Array.isArray( property ) ? property : [ property ];\n\t\tproperty.forEach( name => this._styles.delete( name ) );\n\t}\n\n\t/**\n\t * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @see module:engine/view/writer~Writer#setCustomProperty\n\t * @protected\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t */\n\t_setCustomProperty( key, value ) {\n\t\tthis._customProperties.set( key, value );\n\t}\n\n\t/**\n\t * Removes the custom property stored under the given key.\n\t *\n\t * @see module:engine/view/writer~Writer#removeCustomProperty\n\t * @protected\n\t * @param {String|Symbol} key\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\t_removeCustomProperty( key ) {\n\t\treturn this._customProperties.delete( key );\n\t}\n\n\t/**\n\t * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n\t *\n\t * @abstract\n\t * @method module:engine/view/element~Element#getFillerOffset\n\t */\n}\n\n// Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed\n// as an object (instead of `Map`), the object is transformed to the map. Attributes with `null` value are removed.\n// Attributes with non-`String` value are converted to `String`.\n//\n// @param {Object|Map} attrs Attributes to parse.\n// @returns {Map} Parsed attributes.\nfunction parseAttributes( attrs ) {\n\tif ( isPlainObject( attrs ) ) {\n\t\tattrs = objectToMap( attrs );\n\t} else {\n\t\tattrs = new Map( attrs );\n\t}\n\n\tfor ( const [ key, value ] of attrs ) {\n\t\tif ( value === null ) {\n\t\t\tattrs.delete( key );\n\t\t} else if ( typeof value != 'string' ) {\n\t\t\tattrs.set( key, String( value ) );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n\n// Parses inline styles and puts property - value pairs into styles map.\n// Styles map is cleared before insertion.\n//\n// @param {Map.<String, String>} stylesMap Map to insert parsed properties and values.\n// @param {String} stylesString Styles to parse.\nfunction parseInlineStyles( stylesMap, stylesString ) {\n\t// `null` if no quote was found in input string or last found quote was a closing quote. See below.\n\tlet quoteType = null;\n\tlet propertyNameStart = 0;\n\tlet propertyValueStart = 0;\n\tlet propertyName = null;\n\n\tstylesMap.clear();\n\n\t// Do not set anything if input string is empty.\n\tif ( stylesString === '' ) {\n\t\treturn;\n\t}\n\n\t// Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\tif ( stylesString.charAt( stylesString.length - 1 ) != ';' ) {\n\t\tstylesString = stylesString + ';';\n\t}\n\n\t// Seek the whole string for \"special characters\".\n\tfor ( let i = 0; i < stylesString.length; i++ ) {\n\t\tconst char = stylesString.charAt( i );\n\n\t\tif ( quoteType === null ) {\n\t\t\t// No quote found yet or last found quote was a closing quote.\n\t\t\tswitch ( char ) {\n\t\t\t\tcase ':':\n\t\t\t\t\t// Most of time colon means that property name just ended.\n\t\t\t\t\t// Sometimes however `:` is found inside property value (for example in background image url).\n\t\t\t\t\tif ( !propertyName ) {\n\t\t\t\t\t\t// Treat this as end of property only if property name is not already saved.\n\t\t\t\t\t\t// Save property name.\n\t\t\t\t\t\tpropertyName = stylesString.substr( propertyNameStart, i - propertyNameStart );\n\t\t\t\t\t\t// Save this point as the start of property value.\n\t\t\t\t\t\tpropertyValueStart = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\t// Opening quote found (this is an opening quote, because `quoteType` is `null`).\n\t\t\t\t\tquoteType = char;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// eslint-disable-next-line no-case-declarations\n\t\t\t\tcase ';':\n\t\t\t\t\t// Property value just ended.\n\t\t\t\t\t// Use previously stored property value start to obtain property value.\n\t\t\t\t\tconst propertyValue = stylesString.substr( propertyValueStart, i - propertyValueStart );\n\n\t\t\t\t\tif ( propertyName ) {\n\t\t\t\t\t\t// Save parsed part.\n\t\t\t\t\t\tstylesMap.set( propertyName.trim(), propertyValue.trim() );\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName = null;\n\n\t\t\t\t\t// Save this point as property name start. Property name starts immediately after previous property value ends.\n\t\t\t\t\tpropertyNameStart = i + 1;\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ( char === quoteType ) {\n\t\t\t// If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n\t\t\tquoteType = null;\n\t\t}\n\t}\n}\n\n// Parses class attribute and puts all classes into classes set.\n// Classes set s cleared before insertion.\n//\n// @param {Set.<String>} classesSet Set to insert parsed classes.\n// @param {String} classesString String with classes to parse.\nfunction parseClasses( classesSet, classesString ) {\n\tconst classArray = classesString.split( /\\s+/ );\n\tclassesSet.clear();\n\tclassArray.forEach( name => classesSet.add( name ) );\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/containerelement\n */\n\nimport Element from './element';\n\n/**\n * Containers are elements which define document structure. They define boundaries for\n * {@link module:engine/view/attributeelement~AttributeElement attributes}. They are mostly use for block elements like `<p>` or `<div>`.\n *\n * Editing engine does not define fixed HTML DTD. This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer.\n *\n * Creating an element you should use `ContainerElement` class or {@link module:engine/view/attributeelement~AttributeElement}. This is\n * important to define the type of the element because of two reasons:\n *\n * Firstly, {@link module:engine/view/domconverter~DomConverter} needs the information what is an editable block to convert elements to\n * DOM properly. {@link module:engine/view/domconverter~DomConverter} will ensure that `ContainerElement` is editable and it is possible\n * to put caret inside it, even if the container is empty.\n *\n * Secondly, {@link module:engine/view/writer~Writer view writer} uses this information.\n * Nodes {@link module:engine/view/writer~Writer#breakAttributes breaking} and {@link module:engine/view/writer~Writer#mergeAttributes\n * merging}\n * is performed only in a bounds of a container nodes.\n *\n * For instance if `<p>` is an container and `<b>` is attribute:\n *\n *\t\t<p><b>fo^o</b></p>\n *\n * {@link module:engine/view/writer~Writer#breakAttributes breakAttributes} will create:\n *\n *\t\t<p><b>fo</b><b>o</b></p>\n *\n * There might be a need to mark `<span>` element as a container node, for example in situation when it will be a\n * container of an inline widget:\n *\n *\t\t<span color=\"red\">foobar</span>\t\t// attribute\n *\t\t<span data-widget>foobar</span>\t\t// container\n *\n * @extends module:engine/view/element~Element\n */\nexport default class ContainerElement extends Element {\n\t/**\n\t * Creates a container element.\n\t *\n\t * @see module:engine/view/element~Element\n\t * @see module:engine/view/writer~Writer#createContainerElement\n\t * @protected\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( name, attrs, children );\n\n\t\t/**\n\t\t * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n\t\t *\n\t\t * @method #getFillerOffset\n\t\t * @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n\t\t */\n\t\tthis.getFillerOffset = getFillerOffset;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'containerElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'containerElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n}\n\n// Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\nfunction getFillerOffset() {\n\tconst children = [ ...this.getChildren() ];\n\tconst lastChild = children[ this.childCount - 1 ];\n\n\t// Block filler is required after a `<br>` if it's the last element in its container. See #1422.\n\tif ( lastChild && lastChild.is( 'element', 'br' ) ) {\n\t\treturn this.childCount;\n\t}\n\n\tfor ( const child of children ) {\n\t\t// If there's any non-UI element – don't render the bogus.\n\t\tif ( !child.is( 'uiElement' ) ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// If there are only UI elements – render the bogus at the end of the element.\n\treturn this.childCount;\n}\n","import eq from './eq';\nimport isArrayLike from './isArrayLike';\nimport isIndex from './_isIndex';\nimport isObject from './isObject';\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nexport default isIterateeCall;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  var length = args.length;\n  switch (length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nexport default apply;\n","import isObjectLike from './isObjectLike';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import isFunction from './isFunction';\nimport isObject from './isObject';\nimport isSymbol from './isSymbol';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = isFunction(value.valueOf) ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import toNumber from './toNumber';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","import toFinite from './toFinite';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This function is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","import apply from './_apply';\nimport toInteger from './toInteger';\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as\n * an array.\n *\n * **Note:** This method is based on the\n * [rest parameter](https://mdn.io/rest_parameters).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.rest(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction rest(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, array);\n      case 1: return func.call(this, args[0], array);\n      case 2: return func.call(this, args[0], args[1], array);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\nexport default rest;\n","import isIterateeCall from './_isIterateeCall';\nimport rest from './rest';\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return rest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nexport default createAssigner;\n","import root from './_root';\n\n/** Built-in value references. */\nvar Reflect = root.Reflect;\n\nexport default Reflect;\n","/**\n * Converts `iterator` to an array.\n *\n * @private\n * @param {Object} iterator The iterator to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction iteratorToArray(iterator) {\n  var data,\n      result = [];\n\n  while (!(data = iterator.next()).done) {\n    result.push(data.value);\n  }\n  return result;\n}\n\nexport default iteratorToArray;\n","import Reflect from './_Reflect';\nimport iteratorToArray from './_iteratorToArray';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar enumerate = Reflect ? Reflect.enumerate : undefined,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * The base implementation of `_.keysIn` which doesn't skip the constructor\n * property of prototypes or treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  object = object == null ? object : Object(object);\n\n  var result = [];\n  for (var key in object) {\n    result.push(key);\n  }\n  return result;\n}\n\n// Fallback for IE < 9 with es6-shim.\nif (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {\n  baseKeysIn = function(object) {\n    return iteratorToArray(enumerate(object));\n  };\n}\n\nexport default baseKeysIn;\n","import baseKeysIn from './_baseKeysIn';\nimport indexKeys from './_indexKeys';\nimport isIndex from './_isIndex';\nimport isPrototype from './_isPrototype';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  var index = -1,\n      isProto = isPrototype(object),\n      props = baseKeysIn(object),\n      propsLength = props.length,\n      indexes = indexKeys(object),\n      skipIndexes = !!indexes,\n      result = indexes || [],\n      length = result.length;\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default keysIn;\n","import assignValue from './_assignValue';\nimport copyObject from './_copyObject';\nimport createAssigner from './_createAssigner';\nimport isArrayLike from './isArrayLike';\nimport isPrototype from './_isPrototype';\nimport keysIn from './keysIn';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */\nvar nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');\n\n/**\n * This method is like `_.assign` except that it iterates over own and\n * inherited source properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assign\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * function Bar() {\n *   this.d = 4;\n * }\n *\n * Foo.prototype.c = 3;\n * Bar.prototype.e = 5;\n *\n * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n */\nvar assignIn = createAssigner(function(object, source) {\n  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keysIn(source), object);\n    return;\n  }\n  for (var key in source) {\n    assignValue(object, key, source[key]);\n  }\n});\n\nexport default assignIn;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/observablemixin\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport extend from './lib/lodash/extend';\nimport isObject from './lib/lodash/isObject';\n\nconst observablePropertiesSymbol = Symbol( 'observableProperties' );\nconst boundObservablesSymbol = Symbol( 'boundObservables' );\nconst boundPropertiesSymbol = Symbol( 'boundProperties' );\n\n/**\n * Mixin that injects the \"observable properties\" and data binding functionality described in the\n * {@link ~Observable} interface.\n *\n * @mixin ObservableMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/observablemixin~Observable\n */\nconst ObservableMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\tset( name, value ) {\n\t\t// If the first parameter is an Object, iterate over its properties.\n\t\tif ( isObject( name ) ) {\n\t\t\tObject.keys( name ).forEach( property => {\n\t\t\t\tthis.set( property, name[ property ] );\n\t\t\t}, this );\n\n\t\t\treturn;\n\t\t}\n\n\t\tinitObservable( this );\n\n\t\tconst properties = this[ observablePropertiesSymbol ];\n\n\t\tif ( ( name in this ) && !properties.has( name ) ) {\n\t\t\t/**\n\t\t\t * Cannot override an existing property.\n\t\t\t *\n\t\t\t * This error is thrown when trying to {@link ~Observable#set set} an property with\n\t\t\t * a name of an already existing property. For example:\n\t\t\t *\n\t\t\t *\t\tlet observable = new Model();\n\t\t\t *\t\tobservable.property = 1;\n\t\t\t *\t\tobservable.set( 'property', 2 );\t\t\t// throws\n\t\t\t *\n\t\t\t *\t\tobservable.set( 'property', 1 );\n\t\t\t *\t\tobservable.set( 'property', 2 );\t\t\t// ok, because this is an existing property.\n\t\t\t *\n\t\t\t * @error observable-set-cannot-override\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-set-cannot-override: Cannot override an existing property.' );\n\t\t}\n\n\t\tObject.defineProperty( this, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget() {\n\t\t\t\treturn properties.get( name );\n\t\t\t},\n\n\t\t\tset( value ) {\n\t\t\t\tconst oldValue = properties.get( name );\n\n\t\t\t\t// Fire `set` event before the new value will be set to make it possible\n\t\t\t\t// to override observable property without affecting `change` event.\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5-utils/issues/171.\n\t\t\t\tlet newValue = this.fire( 'set:' + name, name, value, oldValue );\n\n\t\t\t\tif ( newValue === undefined ) {\n\t\t\t\t\tnewValue = value;\n\t\t\t\t}\n\n\t\t\t\t// Allow undefined as an initial value like A.define( 'x', undefined ) (#132).\n\t\t\t\t// Note: When properties map has no such own property, then its value is undefined.\n\t\t\t\tif ( oldValue !== newValue || !properties.has( name ) ) {\n\t\t\t\t\tproperties.set( name, newValue );\n\t\t\t\t\tthis.fire( 'change:' + name, name, newValue, oldValue );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tthis[ name ] = value;\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tbind( ...bindProperties ) {\n\t\tif ( !bindProperties.length || !isStringArray( bindProperties ) ) {\n\t\t\t/**\n\t\t\t * All properties must be strings.\n\t\t\t *\n\t\t\t * @error observable-bind-wrong-properties\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-wrong-properties: All properties must be strings.' );\n\t\t}\n\n\t\tif ( ( new Set( bindProperties ) ).size !== bindProperties.length ) {\n\t\t\t/**\n\t\t\t * Properties must be unique.\n\t\t\t *\n\t\t\t * @error observable-bind-duplicate-properties\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-duplicate-properties: Properties must be unique.' );\n\t\t}\n\n\t\tinitObservable( this );\n\n\t\tconst boundProperties = this[ boundPropertiesSymbol ];\n\n\t\tbindProperties.forEach( propertyName => {\n\t\t\tif ( boundProperties.has( propertyName ) ) {\n\t\t\t\t/**\n\t\t\t\t * Cannot bind the same property more that once.\n\t\t\t\t *\n\t\t\t\t * @error observable-bind-rebind\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'observable-bind-rebind: Cannot bind the same property more that once.' );\n\t\t\t}\n\t\t} );\n\n\t\tconst bindings = new Map();\n\n\t\t// @typedef {Object} Binding\n\t\t// @property {Array} property Property which is bound.\n\t\t// @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).\n\t\t// @property {Array} callback A function which processes `to` components.\n\t\tbindProperties.forEach( a => {\n\t\t\tconst binding = { property: a, to: [] };\n\n\t\t\tboundProperties.set( a, binding );\n\t\t\tbindings.set( a, binding );\n\t\t} );\n\n\t\t// @typedef {Object} BindChain\n\t\t// @property {Function} to See {@link ~ObservableMixin#_bindTo}.\n\t\t// @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.\n\t\t// @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.\n\t\t// @property {Array} _bindProperties Array of `_observable` properties to be bound.\n\t\t// @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).\n\t\t// @property {Map} _bindings Stores bindings to be kept in\n\t\t// {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}\n\t\t// initiated in this binding chain.\n\t\treturn {\n\t\t\tto: bindTo,\n\t\t\ttoMany: bindToMany,\n\n\t\t\t_observable: this,\n\t\t\t_bindProperties: bindProperties,\n\t\t\t_to: [],\n\t\t\t_bindings: bindings\n\t\t};\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tunbind( ...unbindProperties ) {\n\t\t// Nothing to do here if not inited yet.\n\t\tif ( !( observablePropertiesSymbol in this ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundProperties = this[ boundPropertiesSymbol ];\n\t\tconst boundObservables = this[ boundObservablesSymbol ];\n\n\t\tif ( unbindProperties.length ) {\n\t\t\tif ( !isStringArray( unbindProperties ) ) {\n\t\t\t\t/**\n\t\t\t\t * Properties must be strings.\n\t\t\t\t *\n\t\t\t\t * @error observable-unbind-wrong-properties\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'observable-unbind-wrong-properties: Properties must be strings.' );\n\t\t\t}\n\n\t\t\tunbindProperties.forEach( propertyName => {\n\t\t\t\tconst binding = boundProperties.get( propertyName );\n\n\t\t\t\t// Nothing to do if the binding is not defined\n\t\t\t\tif ( !binding ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet toObservable, toProperty, toProperties, toPropertyBindings;\n\n\t\t\t\tbinding.to.forEach( to => {\n\t\t\t\t\t// TODO: ES6 destructuring.\n\t\t\t\t\ttoObservable = to[ 0 ];\n\t\t\t\t\ttoProperty = to[ 1 ];\n\t\t\t\t\ttoProperties = boundObservables.get( toObservable );\n\t\t\t\t\ttoPropertyBindings = toProperties[ toProperty ];\n\n\t\t\t\t\ttoPropertyBindings.delete( binding );\n\n\t\t\t\t\tif ( !toPropertyBindings.size ) {\n\t\t\t\t\t\tdelete toProperties[ toProperty ];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !Object.keys( toProperties ).length ) {\n\t\t\t\t\t\tboundObservables.delete( toObservable );\n\t\t\t\t\t\tthis.stopListening( toObservable, 'change' );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tboundProperties.delete( propertyName );\n\t\t\t} );\n\t\t} else {\n\t\t\tboundObservables.forEach( ( bindings, boundObservable ) => {\n\t\t\t\tthis.stopListening( boundObservable, 'change' );\n\t\t\t} );\n\n\t\t\tboundObservables.clear();\n\t\t\tboundProperties.clear();\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdecorate( methodName ) {\n\t\tconst originalMethod = this[ methodName ];\n\n\t\tif ( !originalMethod ) {\n\t\t\t/**\n\t\t\t * Cannot decorate an undefined method.\n\t\t\t *\n\t\t\t * @error observablemixin-cannot-decorate-undefined\n\t\t\t * @param {Object} object The object which method should be decorated.\n\t\t\t * @param {String} methodName Name of the method which does not exist.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.',\n\t\t\t\t{ object: this, methodName }\n\t\t\t);\n\t\t}\n\n\t\tthis.on( methodName, ( evt, args ) => {\n\t\t\tevt.return = originalMethod.apply( this, args );\n\t\t} );\n\n\t\tthis[ methodName ] = function( ...args ) {\n\t\t\treturn this.fire( methodName, args );\n\t\t};\n\t}\n};\n\nextend( ObservableMixin, EmitterMixin );\n\nexport default ObservableMixin;\n\n// Init symbol properties needed to for the observable mechanism to work.\n//\n// @private\n// @param {module:utils/observablemixin~ObservableMixin} observable\nfunction initObservable( observable ) {\n\t// Do nothing if already inited.\n\tif ( observablePropertiesSymbol in observable ) {\n\t\treturn;\n\t}\n\n\t// The internal hash containing the observable's state.\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, observablePropertiesSymbol, {\n\t\tvalue: new Map()\n\t} );\n\n\t// Map containing bindings to external observables. It shares the binding objects\n\t// (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and\n\t// it is used to observe external observables to update own properties accordingly.\n\t// See {@link module:utils/observablemixin~ObservableMixin#bind}.\n\t//\n\t//\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n\t//\t\tconsole.log( A._boundObservables );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\tB: {\n\t//\t\t\t\t\tx: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\ty: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t}\n\t//\t\t\t} )\n\t//\n\t//\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n\t//\t\tconsole.log( A._boundObservables );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\tB: {\n\t//\t\t\t\t\tx: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\t\t\t{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\ty: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\t\t] ),\n\t//\t\t\t\t\tz: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t},\n\t//\t\t\t\tC: {\n\t//\t\t\t\t\tw: Set( [\n\t//\t\t\t\t\t\t{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t\t\t] )\n\t//\t\t\t\t}\n\t//\t\t\t} )\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, boundObservablesSymbol, {\n\t\tvalue: new Map()\n\t} );\n\n\t// Object that stores which properties of this observable are bound and how. It shares\n\t// the binding objects (`{ observable: A, property: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundObservables}.\n\t// This data structure is a reverse of {@link utils.ObservableMixin#_boundObservables} and it is helpful for\n\t// {@link utils.ObservableMixin#unbind}.\n\t//\n\t// See {@link utils.ObservableMixin#bind}.\n\t//\n\t//\t\tA.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );\n\t//\t\tconsole.log( A._boundProperties );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }\n\t//\t\t\t} )\n\t//\n\t//\t\tA.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );\n\t//\t\tconsole.log( A._boundProperties );\n\t//\n\t//\t\t\tMap( {\n\t//\t\t\t\ta: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\tb: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n\t//\t\t\t\tc: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },\n\t//\t\t\t\td: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }\n\t//\t\t\t} )\n\t//\n\t// @private\n\t// @type {Map}\n\tObject.defineProperty( observable, boundPropertiesSymbol, {\n\t\tvalue: new Map()\n\t} );\n}\n\n// A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.\n//\n// @private\n// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.\nfunction bindTo( ...args ) {\n\tconst parsedArgs = parseBindToArgs( ...args );\n\tconst bindingsKeys = Array.from( this._bindings.keys() );\n\tconst numberOfBindings = bindingsKeys.length;\n\n\t// Eliminate A.bind( 'x' ).to( B, C )\n\tif ( !parsedArgs.callback && parsedArgs.to.length > 1 ) {\n\t\t/**\n\t\t * Binding multiple observables only possible with callback.\n\t\t *\n\t\t * @error observable-bind-no-callback\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-no-callback: Binding multiple observables only possible with callback.' );\n\t}\n\n\t// Eliminate A.bind( 'x', 'y' ).to( B, callback )\n\tif ( numberOfBindings > 1 && parsedArgs.callback ) {\n\t\t/**\n\t\t * Cannot bind multiple properties and use a callback in one binding.\n\t\t *\n\t\t * @error observable-bind-to-extra-callback\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.' );\n\t}\n\n\tparsedArgs.to.forEach( to => {\n\t\t// Eliminate A.bind( 'x', 'y' ).to( B, 'a' )\n\t\tif ( to.properties.length && to.properties.length !== numberOfBindings ) {\n\t\t\t/**\n\t\t\t * The number of properties must match.\n\t\t\t *\n\t\t\t * @error observable-bind-to-properties-length\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'observable-bind-to-properties-length: The number of properties must match.' );\n\t\t}\n\n\t\t// When no to.properties specified, observing source properties instead i.e.\n\t\t// A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y\n\t\tif ( !to.properties.length ) {\n\t\t\tto.properties = this._bindProperties;\n\t\t}\n\t} );\n\n\tthis._to = parsedArgs.to;\n\n\t// Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.\n\tif ( parsedArgs.callback ) {\n\t\tthis._bindings.get( bindingsKeys[ 0 ] ).callback = parsedArgs.callback;\n\t}\n\n\tattachBindToListeners( this._observable, this._to );\n\n\t// Update observable._boundProperties and observable._boundObservables.\n\tupdateBindToBound( this );\n\n\t// Set initial values of bound properties.\n\tthis._bindProperties.forEach( propertyName => {\n\t\tupdateBoundObservableProperty( this._observable, propertyName );\n\t} );\n}\n\n// Binds to an attribute in a set of iterable observables.\n//\n// @private\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @param {Function} callback\nfunction bindToMany( observables, attribute, callback ) {\n\tif ( this._bindings.size > 1 ) {\n\t\t/**\n\t\t * Binding one attribute to many observables only possible with one attribute.\n\t\t *\n\t\t * @error observable-bind-to-many-not-one-binding\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().' );\n\t}\n\n\tthis.to(\n\t\t// Bind to #attribute of each observable...\n\t\t...getBindingTargets( observables, attribute ),\n\t\t// ...using given callback to parse attribute values.\n\t\tcallback\n\t);\n}\n\n// Returns an array of binding components for\n// {@link Observable#bind} from a set of iterable observables.\n//\n// @param {Array.<Observable>} observables\n// @param {String} attribute\n// @returns {Array.<String|Observable>}\nfunction getBindingTargets( observables, attribute ) {\n\tconst observableAndAttributePairs = observables.map( observable => [ observable, attribute ] );\n\n\t// Merge pairs to one-dimension array of observables and attributes.\n\treturn Array.prototype.concat.apply( [], observableAndAttributePairs );\n}\n\n// Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\nfunction isStringArray( arr ) {\n\treturn arr.every( a => typeof a == 'string' );\n}\n\n// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns\n// an object with a parsed structure. For example\n//\n//\t\tA.bind( 'x' ).to( B, 'a', C, 'b', call );\n//\n// becomes\n//\n//\t\t{\n//\t\t\tto: [\n//\t\t\t\t{ observable: B, properties: [ 'a' ] },\n//\t\t\t\t{ observable: C, properties: [ 'b' ] },\n//\t\t\t],\n//\t\t\tcallback: call\n// \t\t}\n//\n// @private\n// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.\n// @returns {Object}\nfunction parseBindToArgs( ...args ) {\n\t// Eliminate A.bind( 'x' ).to()\n\tif ( !args.length ) {\n\t\t/**\n\t\t * Invalid argument syntax in `to()`.\n\t\t *\n\t\t * @error observable-bind-to-parse-error\n\t\t */\n\t\tthrow new CKEditorError( 'observable-bind-to-parse-error: Invalid argument syntax in `to()`.' );\n\t}\n\n\tconst parsed = { to: [] };\n\tlet lastObservable;\n\n\tif ( typeof args[ args.length - 1 ] == 'function' ) {\n\t\tparsed.callback = args.pop();\n\t}\n\n\targs.forEach( a => {\n\t\tif ( typeof a == 'string' ) {\n\t\t\tlastObservable.properties.push( a );\n\t\t} else if ( typeof a == 'object' ) {\n\t\t\tlastObservable = { observable: a, properties: [] };\n\t\t\tparsed.to.push( lastObservable );\n\t\t} else {\n\t\t\tthrow new CKEditorError( 'observable-bind-to-parse-error: Invalid argument syntax in `to()`.' );\n\t\t}\n\t} );\n\n\treturn parsed;\n}\n\n// Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.\n//\n// @private\n// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.\n// @param {Observable} toObservable A observable, which is a new component of `binding`.\n// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.\nfunction updateBoundObservables( observable, binding, toObservable, toPropertyName ) {\n\tconst boundObservables = observable[ boundObservablesSymbol ];\n\tconst bindingsToObservable = boundObservables.get( toObservable );\n\tconst bindings = bindingsToObservable || {};\n\n\tif ( !bindings[ toPropertyName ] ) {\n\t\tbindings[ toPropertyName ] = new Set();\n\t}\n\n\t// Pass the binding to a corresponding Set in `observable._boundObservables`.\n\tbindings[ toPropertyName ].add( binding );\n\n\tif ( !bindingsToObservable ) {\n\t\tboundObservables.set( toObservable, bindings );\n\t}\n}\n\n// Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}\n// with {@link BindChain}.\n//\n// Assuming the following binding being created\n//\n// \t\tA.bind( 'a', 'b' ).to( B, 'x', 'y' );\n//\n// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [] },\n// \t\t\tb: { observable: A, property: 'b', to: [] },\n// \t\t}\n//\n// Iterate over all bindings in this chain and fill their `to` properties with\n// corresponding to( ... ) arguments (components of the binding), so\n//\n// \t\t{\n// \t\t\ta: { observable: A, property: 'a', to: [ B, 'x' ] },\n// \t\t\tb: { observable: A, property: 'b', to: [ B, 'y' ] },\n// \t\t}\n//\n// Then update the structure of {@link Observable#_boundObservables} with updated\n// binding, so it becomes:\n//\n// \t\tMap( {\n// \t\t\tB: {\n// \t\t\t\tx: Set( [\n// \t\t\t\t\t{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }\n// \t\t\t\t] ),\n// \t\t\t\ty: Set( [\n// \t\t\t\t\t{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },\n// \t\t\t\t] )\n//\t\t\t}\n// \t\t} )\n//\n// @private\n// @param {BindChain} chain The binding initialized by {@link Observable#bind}.\nfunction updateBindToBound( chain ) {\n\tlet toProperty;\n\n\tchain._bindings.forEach( ( binding, propertyName ) => {\n\t\t// Note: For a binding without a callback, this will run only once\n\t\t// like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )\n\t\t// TODO: ES6 destructuring.\n\t\tchain._to.forEach( to => {\n\t\t\ttoProperty = to.properties[ binding.callback ? 0 : chain._bindProperties.indexOf( propertyName ) ];\n\n\t\t\tbinding.to.push( [ to.observable, toProperty ] );\n\t\t\tupdateBoundObservables( chain._observable, binding, to.observable, toProperty );\n\t\t} );\n\t} );\n}\n\n// Updates an property of a {@link Observable} with a value\n// determined by an entry in {@link Observable#_boundProperties}.\n//\n// @private\n// @param {Observable} observable A observable which property is to be updated.\n// @param {String} propertyName An property to be updated.\nfunction updateBoundObservableProperty( observable, propertyName ) {\n\tconst boundProperties = observable[ boundPropertiesSymbol ];\n\tconst binding = boundProperties.get( propertyName );\n\tlet propertyValue;\n\n\t// When a binding with callback is created like\n\t//\n\t// \t\tA.bind( 'a' ).to( B, 'b', C, 'c', callback );\n\t//\n\t// collect B.b and C.c, then pass them to callback to set A.a.\n\tif ( binding.callback ) {\n\t\tpropertyValue = binding.callback.apply( observable, binding.to.map( to => to[ 0 ][ to[ 1 ] ] ) );\n\t} else {\n\t\tpropertyValue = binding.to[ 0 ];\n\t\tpropertyValue = propertyValue[ 0 ][ propertyValue[ 1 ] ];\n\t}\n\n\tif ( observable.hasOwnProperty( propertyName ) ) {\n\t\tobservable[ propertyName ] = propertyValue;\n\t} else {\n\t\tobservable.set( propertyName, propertyValue );\n\t}\n}\n\n// Starts listening to changes in {@link BindChain._to} observables to update\n// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the\n// initial state of {@link BindChain._observable}.\n//\n// @private\n// @param {BindChain} chain The chain initialized by {@link Observable#bind}.\nfunction attachBindToListeners( observable, toBindings ) {\n\ttoBindings.forEach( to => {\n\t\tconst boundObservables = observable[ boundObservablesSymbol ];\n\t\tlet bindings;\n\n\t\t// If there's already a chain between the observables (`observable` listens to\n\t\t// `to.observable`), there's no need to create another `change` event listener.\n\t\tif ( !boundObservables.get( to.observable ) ) {\n\t\t\tobservable.listenTo( to.observable, 'change', ( evt, propertyName ) => {\n\t\t\t\tbindings = boundObservables.get( to.observable )[ propertyName ];\n\n\t\t\t\t// Note: to.observable will fire for any property change, react\n\t\t\t\t// to changes of properties which are bound only.\n\t\t\t\tif ( bindings ) {\n\t\t\t\t\tbindings.forEach( binding => {\n\t\t\t\t\t\tupdateBoundObservableProperty( observable, binding.property );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n}\n\n/**\n * Interface which adds \"observable properties\" and data binding functionality.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/observablemixin~ObservableMixin} mixin.\n *\n * @interface Observable\n * @extends module:utils/emittermixin~Emitter\n */\n\n/**\n * Fired when a property changed value.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `${ propertyName } has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'prop has changed from 1 to 2'\n *\n * @event change:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Fired when a property value is going to be set but is not set yet (before the `change` event is fired).\n *\n * You can control the final value of the property by using\n * the {@link module:utils/eventinfo~EventInfo#return event's `return` property}.\n *\n *\t\tobservable.set( 'prop', 1 );\n *\n *\t\tobservable.on( 'set:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value is going to be changed from ${ oldValue } to ${ newValue }` );\n *\t\t\tconsole.log( `Current property value is ${ observable[ propertyName ] }` );\n *\n *\t\t\t// Let's override the value.\n *\t\t\tevt.return = 3;\n *\t\t} );\n *\n *\t\tobservable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {\n *\t\t\tconsole.log( `Value has changed from ${ oldValue } to ${ newValue }` );\n *\t\t} );\n *\n *\t\tobservable.prop = 2; // -> 'Value is going to be changed from 1 to 2'\n *\t\t                     // -> 'Current property value is 1'\n *\t\t                     // -> 'Value has changed from 1 to 3'\n *\n * **Note:** Event is fired even when the new value is the same as the old value.\n *\n * @event set:{property}\n * @param {String} name The property name.\n * @param {*} value The new property value.\n * @param {*} oldValue The previous property value.\n */\n\n/**\n * Creates and sets the value of an observable property of this object. Such an property becomes a part\n * of the state and is be observable.\n *\n * It accepts also a single object literal containing key/value pairs with properties to be set.\n *\n * This method throws the `observable-set-cannot-override` error if the observable instance already\n * have a property with the given property name. This prevents from mistakenly overriding existing\n * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.\n *\n * @method #set\n * @param {String|Object} name The property's name or object with `name=>value` pairs.\n * @param {*} [value] The property's value (if `name` was passed in the first parameter).\n */\n\n/**\n * Binds observable properties to another objects implementing {@link module:utils/observablemixin~Observable}\n * interface (like {@link module:ui/model~Model}).\n *\n * Once bound, the observable will immediately share the current state of properties\n * of the observable it is bound to and react to the changes to these properties\n * in the future.\n *\n * **Note**: To release the binding use {@link module:utils/observablemixin~Observable#unbind}.\n *\n * Using `bind().to()` chain:\n *\n *\t\tA.bind( 'a' ).to( B );\n *\t\tA.bind( 'a' ).to( B, 'b' );\n *\t\tA.bind( 'a', 'b' ).to( B, 'c', 'd' );\n *\t\tA.bind( 'a' ).to( B, 'b', C, 'd', ( b, d ) => b + d );\n *\n * It is also possible to bind to the same property in a observables collection using `bind().toMany()` chain:\n *\n *\t\tA.bind( 'a' ).toMany( [ B, C, D ], 'x', ( a, b, c ) => a + b + c );\n *\t\tA.bind( 'a' ).toMany( [ B, C, D ], 'x', ( ...x ) => x.every( x => x ) );\n *\n * @method #bind\n * @param {...String} bindProperties Observable properties that will be bound to another observable(s).\n * @returns {Object} The bind chain with the `to()` and `toMany()` methods.\n */\n\n/**\n * Removes the binding created with {@link #bind}.\n *\n *\t\tA.unbind( 'a' );\n *\t\tA.unbind();\n *\n * @method #unbind\n * @param {...String} [unbindProperties] Observable properties to be unbound. All the bindings will\n * be released if no properties provided.\n */\n\n/**\n * Turns the given methods of this object into event-based ones. This means that the new method will fire an event\n * (named after the method) and the original action will be plugged as a listener to that event.\n *\n * This is a very simplified method decoration. Itself it doesn't change the behavior of a method (expect adding the event),\n * but it allows to modify it later on by listening to the method's event.\n *\n * For example, in order to cancel the method execution one can stop the event:\n *\n *\t\tclass Foo {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.decorate( 'method' );\n *\t\t\t}\n *\n *\t\t\tmethod() {\n *\t\t\t\tconsole.log( 'called!' );\n *\t\t\t}\n *\t\t}\n *\n *\t\tconst foo = new Foo();\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.stop();\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method(); // Nothing is logged.\n *\n *\n * Note: we used a high priority listener here to execute this callback before the one which\n * calls the original method (which used the default priority).\n *\n * It's also possible to change the return value:\n *\n *\t\tfoo.on( 'method', ( evt ) => {\n *\t\t\tevt.return = 'Foo!';\n *\t\t} );\n *\n *\t\tfoo.method(); // -> 'Foo'\n *\n * Finally, it's possible to access and modify the parameters:\n *\n *\t\tmethod( a, b ) {\n *\t\t\tconsole.log( `${ a }, ${ b }`  );\n *\t\t}\n *\n *\t\t// ...\n *\n *\t\tfoo.on( 'method', ( evt, args ) => {\n *\t\t\targs[ 0 ] = 3;\n *\n *\t\t\tconsole.log( args[ 1 ] ); // -> 2\n *\t\t}, { priority: 'high' } );\n *\n *\t\tfoo.method( 1, 2 ); // -> '3, 2'\n *\n * @method #decorate\n * @param {String} methodName Name of the method to decorate.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/editableelement\n */\n\nimport ContainerElement from './containerelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n\nconst documentSymbol = Symbol( 'document' );\n\n/**\n * Editable element which can be a {@link module:engine/view/rooteditableelement~RootEditableElement root}\n * or nested editable area in the editor.\n *\n * Editable is automatically read-only when its {module:engine/view/document~Document Document} is read-only.\n *\n * @extends module:engine/view/containerelement~ContainerElement\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class EditableElement extends ContainerElement {\n\t/**\n\t * Creates an editable element.\n\t *\n\t * @see module:engine/view/writer~Writer#createEditableElement\n\t * @protected\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( name, attrs, children );\n\n\t\t/**\n\t\t * Whether the editable is in read-write or read-only mode.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/editableelement~EditableElement#isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * Whether the editable is focused.\n\t\t *\n\t\t * This property updates when {@link module:engine/view/document~Document#isFocused document.isFocused} or view\n\t\t * selection is changed.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/editableelement~EditableElement#isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * The {@link module:engine/view/document~Document} which is an owner of this root.\n\t\t * Can only by set once.\n\t\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-editableelement-document-already-set`\n\t\t * when document is already set.\n\t\t *\n\t\t * @member {module:engine/view/document~Document} #document\n\t\t */\n\t}\n\n\t/**\n\t * Returns document associated with the editable.\n\t *\n\t * @readonly\n\t * @returns {module:engine/view/document~Document}\n\t */\n\tget document() {\n\t\treturn this.getCustomProperty( documentSymbol );\n\t}\n\n\t/**\n\t * Sets document of this editable element.\n\t *\n\t * @protected\n\t * @param {module:engine/view/document~Document} document\n\t */\n\tset _document( document ) {\n\t\tif ( this.getCustomProperty( documentSymbol ) ) {\n\t\t\t/**\n\t\t\t * View document is already set. It can only be set once.\n\t\t\t *\n\t\t\t * @error view-editableelement-document-already-set\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-editableelement-document-already-set: View document is already set.' );\n\t\t}\n\n\t\tthis._setCustomProperty( documentSymbol, document );\n\n\t\tthis.bind( 'isReadOnly' ).to( document );\n\n\t\tthis.bind( 'isFocused' ).to(\n\t\t\tdocument,\n\t\t\t'isFocused',\n\t\t\tisFocused => isFocused && document.selection.editableElement == this\n\t\t);\n\n\t\t// Update focus state based on selection changes.\n\t\tthis.listenTo( document.selection, 'change', () => {\n\t\t\tthis.isFocused = document.isFocused && document.selection.editableElement == this;\n\t\t} );\n\t}\n}\n\nmix( EditableElement, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/rooteditableelement\n */\n\nimport EditableElement from './editableelement';\n\nconst rootNameSymbol = Symbol( 'rootName' );\n\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\nexport default class RootEditableElement extends EditableElement {\n\t/**\n\t * Creates root editable element.\n\t *\n\t * @param {String} name Node name.\n\t */\n\tconstructor( name ) {\n\t\tsuper( name );\n\n\t\t/**\n\t\t * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n\t\t * other name is set, `main` name is used.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.rootName = 'main';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'rootElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'rootElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\tget rootName() {\n\t\treturn this.getCustomProperty( rootNameSymbol );\n\t}\n\n\tset rootName( rootName ) {\n\t\tthis._setCustomProperty( rootNameSymbol, rootName );\n\t}\n\n\t/**\n\t * Overrides old element name and sets new one.\n\t * This is needed because view roots are created before they are attached to the DOM.\n\t * The name of the root element is temporary at this stage. It has to be changed when the\n\t * view root element is attached to the DOM element.\n\t *\n\t * @protected\n\t * @param {String} name The new name of element.\n\t */\n\tset _name( name ) {\n\t\tthis.name = name;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/treewalker\n */\n\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} options Object with configuration.\n\t * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/view/position~Position} [options.startPosition] Starting position.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from\n\t * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as\n\t * {@link module:engine/view/textproxy~TextProxy} (`true`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position have been defined.\n\t\t\t *\n\t\t\t * @error view-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.' );\n\t\t}\n\n\t\tif ( options.direction && options.direction != 'forward' && options.direction != 'backward' ) {\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',\n\t\t\t\t{ direction: options.direction }\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n\t\t * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = Position.createFromPosition( options.startPosition );\n\t\t} else {\n\t\t\tthis.position = Position.createFromPosition( options.boundaries[ options.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = options.direction || 'forward';\n\n\t\t/**\n\t\t * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n\t\t * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n\t\t * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n\t\t * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n\t * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n\t * \t\twalker.skip( value => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n\t * information about taken step.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tlet position = Position.createFromPosition( this.position );\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.childCount ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just after current position.\n\t\tlet node;\n\n\t\t// Text is a specific parent because it contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtEnd ) {\n\t\t\t\t// Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position.createAfter( parent );\n\n\t\t\t\treturn this._next();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap by TextProxy.\n\t\t\t\tif ( node == this._boundaryEndParent ) {\n\t\t\t\t\tcharactersCount = this.boundaries.end.offset;\n\t\t\t\t\titem = new TextProxy( node, 0, charactersCount );\n\t\t\t\t\tposition = Position.createAfter( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving forward.\n\t\t\t\t\tposition.offset++;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\ttextLength = 1;\n\t\t\t} else {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n\n\t\t\t\ttextLength = endOffset - position.offset;\n\t\t\t}\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tposition.offset += textLength;\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition = Position.createAfter( parent );\n\t\t\tthis.position = position;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn this._formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tlet position = Position.createFromPosition( this.position );\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before current position.\n\t\tlet node;\n\n\t\t// Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtStart ) {\n\t\t\t\t// Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position.createBefore( parent );\n\n\t\t\t\treturn this._previous();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset - 1 ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset - 1 );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, node.childCount );\n\t\t\t\tthis.position = position;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn this._formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tposition.offset--;\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, node.data.length );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._previous();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap by TextProxy.\n\t\t\t\tif ( node == this._boundaryStartParent ) {\n\t\t\t\t\tconst offset = this.boundaries.start.offset;\n\n\t\t\t\t\titem = new TextProxy( node, offset, node.data.length - offset );\n\t\t\t\t\tcharactersCount = item.data.length;\n\t\t\t\t\tposition = Position.createBefore( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving backward.\n\t\t\t\t\tposition.offset--;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( !this.singleCharacters ) {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n\n\t\t\t\ttextLength = position.offset - startOffset;\n\t\t\t} else {\n\t\t\t\ttextLength = 1;\n\t\t\t}\n\n\t\t\tposition.offset -= textLength;\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition = Position.createBefore( parent );\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n\n\t/**\n\t * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n\t *\n\t * @private\n\t * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n\t * @param {module:engine/view/item~Item} item Item between old and new position.\n\t * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n\t * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n\t * @param {Number} [length] Length of the item.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue}\n\t */\n\t_formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\t\t// Text is a specific parent, because contains string instead of children.\n\t\t// Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n\t\t// or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n\t\t// we move it just before or just after Text.\n\t\tif ( item instanceof TextProxy ) {\n\t\t\t// Position is at the end of Text.\n\t\t\tif ( item.offsetInText + item.data.length == item.textNode.data.length ) {\n\t\t\t\tif ( this.direction == 'forward' && !( this.boundaries && this.boundaries.end.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position.createAfter( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position.createAfter( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Position is at the begining ot the text.\n\t\t\tif ( item.offsetInText === 0 ) {\n\t\t\t\tif ( this.direction == 'backward' && !( this.boundaries && this.boundaries.start.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position.createBefore( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position.createBefore( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: {\n\t\t\t\ttype,\n\t\t\t\titem,\n\t\t\t\tpreviousPosition,\n\t\t\t\tnextPosition,\n\t\t\t\tlength\n\t\t\t}\n\t\t};\n\t}\n}\n\n/**\n * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end\n * of node, or `'text'` if walker traversed over single and multiple characters.\n * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.\n *\n * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.\n *\n * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue\n * @property {module:engine/view/treewalker~TreeWalkerValueType} type\n * @property {module:engine/view/item~Item} item Item between old and new positions of {@link module:engine/view/treewalker~TreeWalker}.\n * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item. Note that it is more efficient to use this position then calculate the position before\n * the node using {@link module:engine/view/position~Position.createBefore}.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the Text to its parent just before or just after Text.\n * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the Text to its parent just before or just after Text.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is undefined.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/position\n */\n\nimport TreeWalker from './treewalker';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EditableElement from './editableelement';\n\n/**\n * Position in the tree. Position is always located before or after a node.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.\n\t * @param {Number} offset Position offset.\n\t */\n\tconstructor( parent, offset ) {\n\t\t/**\n\t\t * Position parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t\t * module:engine/view/position~Position#parent\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * Position offset.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} module:engine/view/position~Position#offset\n\t\t */\n\t\tthis.offset = offset;\n\t}\n\n\t/**\n\t * Node directly after the position. Equals `null` when there is no node after position or position is located\n\t * inside text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\tif ( this.parent.is( 'text' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.parent.getChild( this.offset ) || null;\n\t}\n\n\t/**\n\t * Node directly before the position. Equals `null` when there is no node before position or position is located\n\t * inside text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|null}\n\t */\n\tget nodeBefore() {\n\t\tif ( this.parent.is( 'text' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.parent.getChild( this.offset - 1 ) || null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\tconst endOffset = this.parent.is( 'text' ) ? this.parent.data.length : this.parent.childCount;\n\n\t\treturn this.offset === endOffset;\n\t}\n\n\t/**\n\t * Position's root, that is the root of the position's parent element.\n\t *\n\t * @readonly\n\t * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.parent.root;\n\t}\n\n\t/**\n\t * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if\n\t * position is not inside an editable element.\n\t *\n\t * @type {module:engine/view/editableelement~EditableElement|null}\n\t */\n\tget editableElement() {\n\t\tlet editable = this.parent;\n\n\t\twhile ( !( editable instanceof EditableElement ) ) {\n\t\t\tif ( editable.parent ) {\n\t\t\t\teditable = editable.parent;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn editable;\n\t}\n\n\t/**\n\t * Returns a new instance of Position with offset incremented by `shift` value.\n\t *\n\t * @param {Number} shift How position offset should get changed. Accepts negative values.\n\t * @returns {module:engine/view/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = Position.createFromPosition( this );\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>\n\t * \t\tgetLastMatchingPosition( value => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and it's ancestors.\n\t *\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions.\n\t *\n\t * @param {module:engine/view/position~Position} position\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Checks whether this position equals given position.\n\t *\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn ( this.parent == otherPosition.parent && this.offset == otherPosition.offset );\n\t}\n\n\t/**\n\t * Checks whether this position is located before given position. When method returns `false` it does not mean that\n\t * this position is after give one. Two positions may be located inside separate roots and in that situation this\n\t * method will still return `false`.\n\t *\n\t * @see module:engine/view/position~Position#isAfter\n\t * @see module:engine/view/position~Position#compareWith\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} Returns `true` if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is located after given position. When method returns `false` it does not mean that\n\t * this position is before give one. Two positions may be located inside separate roots and in that situation this\n\t * method will still return `false`.\n\t *\n\t * @see module:engine/view/position~Position#isBefore\n\t * @see module:engine/view/position~Position#compareWith\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} Returns `true` if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before, after or in same position that other position. Two positions may be also\n\t * different when they are located in separate roots.\n\t *\n\t * @param {module:engine/view/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/view/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root !== otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tif ( this.isEqual( otherPosition ) ) {\n\t\t\treturn 'same';\n\t\t}\n\n\t\t// Get path from root to position's parent element.\n\t\tconst thisPath = this.parent.is( 'node' ) ? this.parent.getPath() : [];\n\t\tconst otherPath = otherPosition.parent.is( 'node' ) ? otherPosition.parent.getPath() : [];\n\n\t\t// Add the positions' offsets to the parents offsets.\n\t\tthisPath.push( this.offset );\n\t\totherPath.push( otherPosition.offset );\n\n\t\t// Compare both path arrays to find common ancestor.\n\t\tconst result = compareArrays( thisPath, otherPath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < otherPath[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link module:engine/view/position~Position.createBefore},\n\t * * {@link module:engine/view/position~Position.createAfter},\n\t * * {@link module:engine/view/position~Position.createFromPosition}.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tstatic createAt( itemOrPosition, offset ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn this.createFromPosition( itemOrPosition );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.is( 'text' ) ? node.data.length : node.childCount;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this.createBefore( node );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this.createAfter( node );\n\t\t\t} else if ( !offset ) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\treturn new Position( node, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tstatic createAfter( item ) {\n\t\t// TextProxy is not a instance of Node so we need do handle it in specific way.\n\t\tif ( item.is( 'textProxy' ) ) {\n\t\t\treturn new Position( item.textNode, item.offsetInText + item.data.length );\n\t\t}\n\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root.\n\t\t\t *\n\t\t\t * @error view-position-after-root\n\t\t\t * @param {module:engine/view/node~Node} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-position-after-root: You can not make position after root.', { root: item } );\n\t\t}\n\n\t\treturn new Position( item.parent, item.index + 1 );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tstatic createBefore( item ) {\n\t\t// TextProxy is not a instance of Node so we need do handle it in specific way.\n\t\tif ( item.is( 'textProxy' ) ) {\n\t\t\treturn new Position( item.textNode, item.offsetInText );\n\t\t}\n\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You cannot make a position before a root.\n\t\t\t *\n\t\t\t * @error view-position-before-root\n\t\t\t * @param {module:engine/view/node~Node} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-position-before-root: You can not make position before root.', { root: item } );\n\t\t}\n\n\t\treturn new Position( item.parent, item.index );\n\t}\n\n\t/**\n\t * Creates and returns a new instance of `Position`, which is equal to the passed position.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to be cloned.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tstatic createFromPosition( position ) {\n\t\treturn new this( position.parent, position.offset );\n\t}\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/view/position~PositionRelation\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\n\n/**\n * Tree view range.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.start = Position.createFromPosition( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.end = end ? Position.createFromPosition( end ) : Position.createFromPosition( start );\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/view/position~Position positions},\n\t * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n\t * `ignoreElementEnd` option\n\t * set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is it start and end positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n\t * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t * \t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n\t * \t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n\t *\n\t * Note that in the sample above:\n\t *  - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t *  - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t *  - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Enlarged range.\n\t */\n\tgetEnlarged() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\t// Fix positions, in case if they are in Text node.\n\t\tif ( start.parent.is( 'text' ) && start.isAtStart ) {\n\t\t\tstart = Position.createBefore( start.parent );\n\t\t}\n\n\t\tif ( end.parent.is( 'text' ) && end.isAtEnd ) {\n\t\t\tend = Position.createAfter( end.parent );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t * \t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n\t * \t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n\t *\n\t * Note that in the sample above:\n\t *  - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t *  - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t *  - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Shrink range.\n\t */\n\tgetTrimmed() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\tif ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {\n\t\t\treturn new Range( start, start );\n\t\t}\n\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tconst nodeAfterStart = start.nodeAfter;\n\t\tconst nodeBeforeEnd = end.nodeBefore;\n\n\t\t// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'text' ) ) {\n\t\t\tstart = new Position( nodeAfterStart, 0 );\n\t\t}\n\n\t\tif ( nodeBeforeEnd && nodeBeforeEnd.is( 'text' ) ) {\n\t\t\tend = new Position( nodeBeforeEnd, nodeBeforeEnd.data.length );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Two ranges are equal if their start and end positions are equal.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n\t * `false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n\t * otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n\t * {@link module:engine/view/range~Range range}.\n\t * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = new Text( 'foo' );\n\t *\t\tlet img = new ContainerElement( 'img' );\n\t *\t\tlet bar = new Text( 'bar' );\n\t *\t\tlet p = new ContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = new Range( new Position( foo, 1 ), new Position( bar, 2 ); \"oo\", img, \"ba\" are in range.\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // \"oo\", img are in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n\t *\n\t *\t\totherRange = new Range( new Position( p, 1 ), new Position( p, 2 ) ); // img is in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( Range.createFromRange( this ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = new Text( 'foo' );\n\t *\t\tlet img = new ContainerElement( 'img' );\n\t *\t\tlet bar = new Text( 'bar' );\n\t *\t\tlet p = new ContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // \"oo\", img are in range.\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n\t *\n\t *\t\totherRange = new Range( new Position( bar, 1 ), new Position( bar, 3 ); \"ar\" is in range.\n\t *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @param {module:engine/view/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n\t * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} True if ranges intersect.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Creates a range from given parents and offsets.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n\t * parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n\t * parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/view/range~Range} Created range.\n\t */\n\tstatic createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tnew Position( startElement, startOffset ),\n\t\t\tnew Position( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates and returns a new instance of Range which is equal to passed range.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clone.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic createFromRange( range ) {\n\t\treturn new this( range.start, range.end );\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @param {module:engine/view/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic createIn( element ) {\n\t\treturn this.createFromParentsAndOffsets( element, 0, element, element.childCount );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic createOn( item ) {\n\t\tconst size = item.is( 'textProxy' ) ? item.offsetSize : 1;\n\n\t\treturn this.createFromPositionAndShift( Position.createBefore( item ), size );\n\t}\n\n\t/**\n\t * Creates a collapsed range at given {@link module:engine/view/position~Position position}\n\t * or on the given {@link module:engine/view/item~Item item}.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tstatic createCollapsedAt( itemOrPosition, offset ) {\n\t\tconst start = Position.createAt( itemOrPosition, offset );\n\t\tconst end = Position.createFromPosition( start );\n\n\t\treturn new Range( start, end );\n\t}\n}\n\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip( value ) {\n\tif ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/count\n */\n\n/**\n * Returns the number of items return by the iterator.\n *\n *\t\tcount( [ 1, 2, 3, 4, 5 ] ); // 5;\n *\n * @param {Iterable.<*>} iterator Any iterator.\n * @returns {Number} Number of items returned by that iterator.\n */\nexport default function count( iterator ) {\n\tlet count = 0;\n\n\tfor ( const _ of iterator ) { // eslint-disable-line no-unused-vars\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/selection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Range from './range';\nimport Position from './position';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Node from './node';\nimport Element from './element';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport DocumentSelection from './documentselection';\n\n/**\n * Class representing selection in tree view.\n *\n * Selection can consist of {@link module:engine/view/range~Range ranges} that can be set using\n * {@link module:engine/view/selection~Selection#setTo setTo} method.\n * That method create copies of provided ranges and store those copies internally. Further modifications to passed\n * ranges will not change selection's state.\n * Selection's ranges can be obtained via {@link module:engine/view/selection~Selection#getRanges getRanges},\n * {@link module:engine/view/selection~Selection#getFirstRange getFirstRange} and\n * {@link module:engine/view/selection~Selection#getLastRange getLastRange} methods, which return copies of ranges\n * stored inside selection. Modifications made on these copies will not change selection's state. Similar situation\n * occurs when getting {@link module:engine/view/selection~Selection#anchor anchor},\n * {@link module:engine/view/selection~Selection#focus focus}, {@link module:engine/view/selection~Selection#getFirstPosition first}\n * and {@link module:engine/view/selection~Selection#getLastPosition last} positions - all will return\n * copies of requested positions.\n */\nexport default class Selection {\n\t/**\n\t * Creates new selection instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = new Selection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tconst selection = new Selection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tconst selection = new Selection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tconst selection = new Selection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = new Selection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tconst selection = new Selection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n\t *\t\tconst selection = new Selection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = new Selection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = new Selection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = new Selection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = new Selection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection|\n\t * module:engine/view/position~Position|Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range|\n\t * module:engine/view/item~Item|null} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tconstructor( selectable = null, placeOrOffset, options ) {\n\t\t/**\n\t\t * Stores all ranges that are selected.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/range~Range>}\n\t\t */\n\t\tthis._ranges = [];\n\n\t\t/**\n\t\t * Specifies whether the last added range was added as a backward or forward range.\n\t\t *\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._lastRangeBackward = false;\n\n\t\t/**\n\t\t * Specifies whether selection instance is fake.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isFake = false;\n\n\t\t/**\n\t\t * Fake selection's label.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._fakeSelectionLabel = '';\n\n\t\tthis.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Returns true if selection instance is marked as `fake`.\n\t *\n\t * @see #setTo\n\t * @returns {Boolean}\n\t */\n\tget isFake() {\n\t\treturn this._isFake;\n\t}\n\n\t/**\n\t * Returns fake selection label.\n\t *\n\t * @see #setTo\n\t * @returns {String}\n\t */\n\tget fakeSelectionLabel() {\n\t\treturn this._fakeSelectionLabel;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n\t * {@link #focus focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n\t * It may be a bit unintuitive when there are multiple ranges in selection.\n\t *\n\t * @see #focus\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget anchor() {\n\t\tif ( !this._ranges.length ) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\t\tconst anchor = this._lastRangeBackward ? range.end : range.start;\n\n\t\treturn Position.createFromPosition( anchor );\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * @see #anchor\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget focus() {\n\t\tif ( !this._ranges.length ) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\t\tconst focus = this._lastRangeBackward ? range.start : range.end;\n\n\t\treturn Position.createFromPosition( focus );\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.rangeCount === 1 && this._ranges[ 0 ].isCollapsed;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._ranges.length;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus} precedes {@link #anchor}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn !this.isCollapsed && this._lastRangeBackward;\n\t}\n\n\t/**\n\t * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n\t * if the selection is not inside an editable element.\n\t *\n\t * @type {module:engine/view/editableelement~EditableElement|null}\n\t */\n\tget editableElement() {\n\t\tif ( this.anchor ) {\n\t\t\treturn this.anchor.editableElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns an iterable that contains copies of all ranges added to the selection.\n\t *\n\t * @returns {Iterable.<module:engine/view/range~Range>}\n\t */\n\t* getRanges() {\n\t\tfor ( const range of this._ranges ) {\n\t\t\tyield Range.createFromRange( range );\n\t\t}\n\t}\n\n\t/**\n\t * Returns copy of the first range in the selection. First range is the one which\n\t * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n\t * position of all other ranges (not to confuse with the first range added to the selection).\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\tlet first = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !first || range.start.isBefore( first.start ) ) {\n\t\t\t\tfirst = range;\n\t\t\t}\n\t\t}\n\n\t\treturn first ? Range.createFromRange( first ) : null;\n\t}\n\n\t/**\n\t * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n\t * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n\t * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\tlet last = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !last || range.end.isAfter( last.end ) ) {\n\t\t\t\tlast = range;\n\t\t\t}\n\t\t}\n\n\t\treturn last ? Range.createFromRange( last ) : null;\n\t}\n\n\t/**\n\t * Returns copy of the first position in the selection. First position is the position that\n\t * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\tconst firstRange = this.getFirstRange();\n\n\t\treturn firstRange ? Position.createFromPosition( firstRange.start ) : null;\n\t}\n\n\t/**\n\t * Returns copy of the last position in the selection. Last position is the position that\n\t * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\tconst lastRange = this.getLastRange();\n\n\t\treturn lastRange ? Position.createFromPosition( lastRange.end ) : null;\n\t}\n\n\t/**\n\t * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n\t * same number of ranges and all ranges from one selection equal to a range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\tif ( this.isFake != otherSelection.isFake ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.rangeCount != otherSelection.rangeCount ) {\n\t\t\treturn false;\n\t\t} else if ( this.rangeCount === 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const thisRange of this._ranges ) {\n\t\t\tlet found = false;\n\n\t\t\tfor ( const otherRange of otherSelection._ranges ) {\n\t\t\t\tif ( thisRange.isEqual( otherRange ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n\t * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n\t * equal to any trimmed range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n\t */\n\tisSimilar( otherSelection ) {\n\t\tif ( this.isBackward != otherSelection.isBackward ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst numOfRangesA = count( this.getRanges() );\n\t\tconst numOfRangesB = count( otherSelection.getRanges() );\n\n\t\t// If selections have different number of ranges, they cannot be similar.\n\t\tif ( numOfRangesA != numOfRangesB ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If both selections have no ranges, they are similar.\n\t\tif ( numOfRangesA == 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check if each range in one selection has a similar range in other selection.\n\t\tfor ( let rangeA of this.getRanges() ) {\n\t\t\trangeA = rangeA.getTrimmed();\n\n\t\t\tlet found = false;\n\n\t\t\tfor ( let rangeB of otherSelection.getRanges() ) {\n\t\t\t\trangeB = rangeB.getTrimmed();\n\n\t\t\t\tif ( rangeA.start.isEqual( rangeB.start ) && rangeA.end.isEqual( rangeB.end ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// There were no ranges that weren't matched. Selections are similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\tif ( this.rangeCount !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = this.getFirstRange();\n\t\tconst nodeAfterStart = range.start.nodeAfter;\n\t\tconst nodeBeforeEnd = range.end.nodeBefore;\n\n\t\treturn ( nodeAfterStart instanceof Element && nodeAfterStart == nodeBeforeEnd ) ? nodeAfterStart : null;\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection},\n\t * {@link module:engine/view/selection~Selection selection}, {@link module:engine/view/position~Position position},\n\t * {@link module:engine/view/item~Item item}, {@link module:engine/view/range~Range range},\n\t * an iterable of {@link module:engine/view/range~Range ranges} or null.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tselection.setTo( otherSelection );\n\t *\n\t *\t \t// Sets selection to contents of DocumentSelection.\n\t *\t\tselection.setTo( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tselection.setTo( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tselection.setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t *\t\tselection.setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tselection.setTo( paragraph, 'on' );\n\t *\n\t * \t\t// Clears selection. Removes all ranges.\n\t *\t\tselection.setTo( null );\n\t *\n\t * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\tselection.setTo( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tselection.setTo( range, { fake: true, label: 'foo' } );\n\t *\n\t * @fires change\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection|\n\t * module:engine/view/position~Position|Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range|\n\t * module:engine/view/item~Item|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetTo( selectable, placeOrOffset, options ) {\n\t\tif ( selectable === null ) {\n\t\t\tthis._setRanges( [] );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Selection || selectable instanceof DocumentSelection ) {\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t\tthis._setFakeOptions( { fake: selectable.isFake, label: selectable.fakeSelectionLabel } );\n\t\t} else if ( selectable instanceof Range ) {\n\t\t\tthis._setRanges( [ selectable ], placeOrOffset && placeOrOffset.backward );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Position ) {\n\t\t\tthis._setRanges( [ new Range( selectable ) ] );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else if ( selectable instanceof Node ) {\n\t\t\tconst backward = !!options && !!options.backward;\n\t\t\tlet range;\n\n\t\t\tif ( placeOrOffset === undefined ) {\n\t\t\t\t/**\n\t\t\t\t * selection.setTo requires the second parameter when the first parameter is a node.\n\t\t\t\t *\n\t\t\t\t * @error view-selection-setTo-required-second-parameter\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'view-selection-setTo-required-second-parameter: ' +\n\t\t\t\t\t'selection.setTo requires the second parameter when the first parameter is a node.'\n\t\t\t\t);\n\t\t\t} else if ( placeOrOffset == 'in' ) {\n\t\t\t\trange = Range.createIn( selectable );\n\t\t\t} else if ( placeOrOffset == 'on' ) {\n\t\t\t\trange = Range.createOn( selectable );\n\t\t\t} else {\n\t\t\t\trange = Range.createCollapsedAt( selectable, placeOrOffset );\n\t\t\t}\n\n\t\t\tthis._setRanges( [ range ], backward );\n\t\t\tthis._setFakeOptions( options );\n\t\t} else if ( isIterable( selectable ) ) {\n\t\t\t// We assume that the selectable is an iterable of ranges.\n\t\t\t// Array.from() is used to prevent setting ranges to the old iterable\n\t\t\tthis._setRanges( selectable, placeOrOffset && placeOrOffset.backward );\n\t\t\tthis._setFakeOptions( placeOrOffset );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Cannot set selection to given place.\n\t\t\t *\n\t\t\t * @error view-selection-setTo-not-selectable\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-selection-setTo-not-selectable: Cannot set selection to given place.' );\n\t\t}\n\n\t\tthis.fire( 'change' );\n\t}\n\n\t/**\n\t * Moves {@link #focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/position~Position.createAt} parameters.\n\t *\n\t * @fires change\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetFocus( itemOrPosition, offset ) {\n\t\tif ( this.anchor === null ) {\n\t\t\t/**\n\t\t\t * Cannot set selection focus if there are no ranges in selection.\n\t\t\t *\n\t\t\t * @error view-selection-setFocus-no-ranges\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.'\n\t\t\t);\n\t\t}\n\n\t\tconst newFocus = Position.createAt( itemOrPosition, offset );\n\n\t\tif ( newFocus.compareWith( this.focus ) == 'same' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst anchor = this.anchor;\n\n\t\tthis._ranges.pop();\n\n\t\tif ( newFocus.compareWith( anchor ) == 'before' ) {\n\t\t\tthis._addRange( new Range( newFocus, anchor ), true );\n\t\t} else {\n\t\t\tthis._addRange( new Range( anchor, newFocus ) );\n\t\t}\n\n\t\tthis.fire( 'change' );\n\t}\n\n\t/**\n\t * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n\t * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.\n\t * Accepts a flag describing in which way the selection is made.\n\t *\n\t * @private\n\t * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.\n\t * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end\n\t * (`false`) or backward - from end to start (`true`). Defaults to `false`.\n\t */\n\t_setRanges( newRanges, isLastBackward = false ) {\n\t\t// New ranges should be copied to prevent removing them by setting them to `[]` first.\n\t\t// Only applies to situations when selection is set to the same selection or same selection's ranges.\n\t\tnewRanges = Array.from( newRanges );\n\n\t\tthis._ranges = [];\n\n\t\tfor ( const range of newRanges ) {\n\t\t\tthis._addRange( range );\n\t\t}\n\n\t\tthis._lastRangeBackward = !!isLastBackward;\n\t}\n\n\t/**\n\t * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection\n\t * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to\n\t * the user and selection over elements can be represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be\n\t * properly handled by screen readers).\n\t *\n\t * @private\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.\n\t * @param {String} [options.label=''] Fake selection label.\n\t */\n\t_setFakeOptions( options = {} ) {\n\t\tthis._isFake = !!options.fake;\n\t\tthis._fakeSelectionLabel = options.fake ? options.label || '' : '';\n\t}\n\n\t/**\n\t * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the\n\t * selection instance and you can safely operate on it.\n\t *\n\t * Accepts a flag describing in which way the selection is made - passed range might be selected from\n\t * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}\n\t * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.\n\t * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n\t * with ranges already stored in Selection instance.\n\t *\n\t * @private\n\t * @fires change\n\t * @param {module:engine/view/range~Range} range\n\t * @param {Boolean} [isBackward]\n\t */\n\t_addRange( range, isBackward = false ) {\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\tthrow new CKEditorError( 'view-selection-invalid-range: Invalid Range.' );\n\t\t}\n\n\t\tthis._pushRange( range );\n\t\tthis._lastRangeBackward = !!isBackward;\n\t}\n\n\t/**\n\t * Adds range to selection - creates copy of given range so it can be safely used and modified.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects\n\t * with ranges already stored in selection instance.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t */\n\t_pushRange( range ) {\n\t\tfor ( const storedRange of this._ranges ) {\n\t\t\tif ( range.isIntersecting( storedRange ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to add a range that intersects with another range from selection.\n\t\t\t\t *\n\t\t\t\t * @error view-selection-range-intersects\n\t\t\t\t * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.\n\t\t\t\t * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'view-selection-range-intersects: Trying to add a range that intersects with another range from selection.',\n\t\t\t\t\t{ addedRange: range, intersectingRange: storedRange }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis._ranges.push( Range.createFromRange( range ) );\n\t}\n\n\t/**\n\t * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.\n\t *\n\t * @event change\n\t */\n}\n\nmix( Selection, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/documentselection\n */\n\nimport Selection from './selection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\n/**\n * Class representing document selection in tree view. It's instance is stored at\n * {@link module:engine/view/document~Document#selection}. It is similar to {@link module:engine/view/selection~Selection} but\n * it has read-only API and can be modified only by writer obtained from {@link module:engine/view/view~View#change} method.\n *\n * Selection can consist of {@link module:engine/view/range~Range ranges}.\n * Selection's ranges can be obtained via {@link module:engine/view/documentselection~DocumentSelection#getRanges getRanges},\n * {@link module:engine/view/documentselection~DocumentSelection#getFirstRange getFirstRange}\n * and {@link module:engine/view/documentselection~DocumentSelection#getLastRange getLastRange}\n * methods, which return copies of ranges stored inside selection. Modifications made on these copies will not change\n * selection's state. Similar situation occurs when getting {@link module:engine/view/documentselection~DocumentSelection#anchor anchor},\n * {@link module:engine/view/documentselection~DocumentSelection#focus focus},\n * {@link module:engine/view/documentselection~DocumentSelection#getFirstPosition first} and\n * {@link module:engine/view/documentselection~DocumentSelection#getLastPosition last} positions - all will return\n * copies of requested positions.\n */\nexport default class DocumentSelection {\n\t/**\n\t * Creates new DocumentSelection instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = new DocumentSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tconst selection = new DocumentSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tconst selection = new DocumentSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tconst selection = new DocumentSelection( otherSelection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tconst selection = new DocumentSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n\t *\t\tconst selection = new DocumentSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = new DocumentSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = new DocumentSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = new DocumentSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = new DocumentSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/position~Position|\n\t * Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range|\n\t * module:engine/view/item~Item|null} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tconstructor( selectable = null, placeOrOffset, options ) {\n\t\t/**\n\t\t * Selection is used internally (`DocumentSelection` is a proxy to that selection).\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/selection~Selection}\n\t\t */\n\t\tthis._selection = new Selection();\n\n\t\t// Delegate change event to be fired on DocumentSelection instance.\n\t\tthis._selection.delegate( 'change' ).to( this );\n\n\t\t// Set selection data.\n\t\tthis._selection.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Returns true if selection instance is marked as `fake`.\n\t *\n\t * @see #_setTo\n\t * @returns {Boolean}\n\t */\n\tget isFake() {\n\t\treturn this._selection.isFake;\n\t}\n\n\t/**\n\t * Returns fake selection label.\n\t *\n\t * @see #_setTo\n\t * @returns {String}\n\t */\n\tget fakeSelectionLabel() {\n\t\treturn this._selection.fakeSelectionLabel;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the selection starts. Together with\n\t * {@link #focus focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.\n\t * It may be a bit unintuitive when there are multiple ranges in selection.\n\t *\n\t * @see #focus\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget anchor() {\n\t\treturn this._selection.anchor;\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * @see #anchor\n\t * @type {module:engine/view/position~Position}\n\t */\n\tget focus() {\n\t\treturn this._selection.focus;\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this._selection.isCollapsed;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._selection.rangeCount;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus} precedes {@link #anchor}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn this._selection.isBackward;\n\t}\n\n\t/**\n\t * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`\n\t * if the selection is not inside an editable element.\n\t *\n\t * @type {module:engine/view/editableelement~EditableElement|null}\n\t */\n\tget editableElement() {\n\t\treturn this._selection.editableElement;\n\t}\n\n\t/**\n\t * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.\n\t *\n\t * @protected\n\t */\n\tget _ranges() {\n\t\treturn this._selection._ranges;\n\t}\n\n\t/**\n\t * Returns an iterable that contains copies of all ranges added to the selection.\n\t *\n\t * @returns {Iterable.<module:engine/view/range~Range>}\n\t */\n\t* getRanges() {\n\t\tyield* this._selection.getRanges();\n\t}\n\n\t/**\n\t * Returns copy of the first range in the selection. First range is the one which\n\t * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start\n\t * position of all other ranges (not to confuse with the first range added to the selection).\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\treturn this._selection.getFirstRange();\n\t}\n\n\t/**\n\t * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}\n\t * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse\n\t * with the last range added to the selection). Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\treturn this._selection.getLastRange();\n\t}\n\n\t/**\n\t * Returns copy of the first position in the selection. First position is the position that\n\t * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\treturn this._selection.getFirstPosition();\n\t}\n\n\t/**\n\t * Returns copy of the last position in the selection. Last position is the position that\n\t * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.\n\t * Returns `null` if no ranges are added to selection.\n\t *\n\t * @returns {module:engine/view/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\treturn this._selection.getLastPosition();\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\treturn this._selection.getSelectedElement();\n\t}\n\n\t/**\n\t * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,\n\t * same number of ranges and all ranges from one selection equal to a range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\treturn this._selection.isEqual( otherSelection );\n\t}\n\n\t/**\n\t * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same\n\t * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are\n\t * equal to any trimmed range from other selection.\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are similar, `false` otherwise.\n\t */\n\tisSimilar( otherSelection ) {\n\t\treturn this._selection.isSimilar( otherSelection );\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection},\n\t * {@link module:engine/view/selection~Selection selection}, {@link module:engine/view/position~Position position},\n\t * {@link module:engine/view/item~Item item}, {@link module:engine/view/range~Range range},\n\t * an iterable of {@link module:engine/view/range~Range ranges} or null.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tdocumentSelection._setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tdocumentSelection._setTo( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tdocumentSelection._setTo( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tdocumentSelection._setTo( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tdocumentSelection._setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t *\t\tdocumentSelection._setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tdocumentSelection._setTo( paragraph, 'on' );\n\t *\n\t * \t\t// Clears selection. Removes all ranges.\n\t *\t\tdocumentSelection._setTo( null );\n\t *\n\t * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\tdocumentSelection._setTo( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tdocumentSelection._setTo( range, { fake: true, label: 'foo' } );\n\t *\n\t * @protected\n\t * @fires change\n\t * @param {module:engine/view/selection~Selection|module:engine/view/position~Position|\n\t * Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range|module:engine/view/item~Item|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\t_setTo( selectable, placeOrOffset, options ) {\n\t\tthis._selection.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link #focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/position~Position.createAt} parameters.\n\t *\n\t * @protected\n\t * @fires change\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\t_setFocus( itemOrPosition, offset ) {\n\t\tthis._selection.setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Fired whenever selection ranges are changed through {@link ~DocumentSelection Selection API}.\n\t *\n\t * @event change\n\t */\n}\n\nmix( DocumentSelection, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/collection\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport mix from './mix';\n\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection {\n\t/**\n\t * Creates a new Collection instance.\n\t *\n\t * @param {Object} [options={}] The options object.\n\t * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.\n\t */\n\tconstructor( options = {} ) {\n\t\t/**\n\t\t * The internal list of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * The internal map of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._itemMap = new Map();\n\n\t\t/**\n\t\t * The name of the property which is considered to identify an item.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._idProperty = options.idProperty || 'id';\n\n\t\t/**\n\t\t * A helper mapping external items of a bound collection ({@link #bindTo})\n\t\t * and actual items of this collection. It provides information\n\t\t * necessary to properly remove items bound to another collection.\n\t\t *\n\t\t * See {@link #_bindToInternalToExternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToExternalToInternalMap = new WeakMap();\n\n\t\t/**\n\t\t * A helper mapping items of this collection to external items of a bound collection\n\t\t * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n\t\t * to avoid loops in two–way bindings.\n\t\t *\n\t\t * See {@link #_bindToExternalToInternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToInternalToExternalMap = new WeakMap();\n\n\t\t/**\n\t\t * Stores indexes of skipped items from bound external collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Array}\n\t\t */\n\t\tthis._skippedIndexesFromExternal = [];\n\n\t\t/**\n\t\t * A collection instance this collection is bound to as a result\n\t\t * of calling {@link #bindTo} method.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/collection~Collection} #_bindToCollection\n\t\t */\n\t}\n\n\t/**\n\t * The number of items available in the collection.\n\t *\n\t * @member {Number} #length\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * Returns the first item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The first item or `null` if collection is empty.\n\t */\n\tget first() {\n\t\treturn this._items[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the last item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The last item or `null` if collection is empty.\n\t */\n\tget last() {\n\t\treturn this._items[ this.length - 1 ] || null;\n\t}\n\n\t/**\n\t * Adds an item into the collection.\n\t *\n\t * If the item does not have an id, then it will be automatically generated and set on the item.\n\t *\n\t * @chainable\n\t * @param {Object} item\n\t * @param {Number} [index] The position of the item in the collection. The item\n\t * is pushed to the collection when `index` not specified.\n\t * @fires add\n\t */\n\tadd( item, index ) {\n\t\tlet itemId;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( ( idProperty in item ) ) {\n\t\t\titemId = item[ idProperty ];\n\n\t\t\tif ( typeof itemId != 'string' ) {\n\t\t\t\t/**\n\t\t\t\t * This item's id should be a string.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-invalid-id\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-invalid-id' );\n\t\t\t}\n\n\t\t\tif ( this.get( itemId ) ) {\n\t\t\t\t/**\n\t\t\t\t * This item already exists in the collection.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-item-already-exists\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-item-already-exists' );\n\t\t\t}\n\t\t} else {\n\t\t\titem[ idProperty ] = itemId = uid();\n\t\t}\n\n\t\t// TODO: Use ES6 default function argument.\n\t\tif ( index === undefined ) {\n\t\t\tindex = this._items.length;\n\t\t} else if ( index > this._items.length || index < 0 ) {\n\t\t\t/**\n\t\t\t * The index number has invalid value.\n\t\t\t *\n\t\t\t * @error collection-add-item-bad-index\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-add-item-invalid-index' );\n\t\t}\n\n\t\tthis._items.splice( index, 0, item );\n\n\t\tthis._itemMap.set( itemId, item );\n\n\t\tthis.fire( 'add', item, index );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets item by its id or index.\n\t *\n\t * @param {String|Number} idOrIndex The item id or index in the collection.\n\t * @returns {Object|null} The requested item or `null` if such item does not exist.\n\t */\n\tget( idOrIndex ) {\n\t\tlet item;\n\n\t\tif ( typeof idOrIndex == 'string' ) {\n\t\t\titem = this._itemMap.get( idOrIndex );\n\t\t} else if ( typeof idOrIndex == 'number' ) {\n\t\t\titem = this._items[ idOrIndex ];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Index or id must be given.\n\t\t\t *\n\t\t\t * @error collection-get-invalid-arg\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-get-invalid-arg: Index or id must be given.' );\n\t\t}\n\n\t\treturn item || null;\n\t}\n\n\t/**\n\t * Gets index of item in the collection.\n\t * When item is not defined in the collection then index will be equal -1.\n\t *\n\t * @param {String|Object} idOrItem The item or its id in the collection.\n\t * @returns {Number} Index of given item.\n\t */\n\tgetIndex( idOrItem ) {\n\t\tlet item;\n\n\t\tif ( typeof idOrItem == 'string' ) {\n\t\t\titem = this._itemMap.get( idOrItem );\n\t\t} else {\n\t\t\titem = idOrItem;\n\t\t}\n\n\t\treturn this._items.indexOf( item );\n\t}\n\n\t/**\n\t * Removes an item from the collection.\n\t *\n\t * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n\t * @returns {Object} The removed item.\n\t * @fires remove\n\t */\n\tremove( subject ) {\n\t\tlet index, id, item;\n\t\tlet itemDoesNotExist = false;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( typeof subject == 'string' ) {\n\t\t\tid = subject;\n\t\t\titem = this._itemMap.get( id );\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tindex = this._items.indexOf( item );\n\t\t\t}\n\t\t} else if ( typeof subject == 'number' ) {\n\t\t\tindex = subject;\n\t\t\titem = this._items[ index ];\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tid = item[ idProperty ];\n\t\t\t}\n\t\t} else {\n\t\t\titem = subject;\n\t\t\tid = item[ idProperty ];\n\t\t\tindex = this._items.indexOf( item );\n\t\t\titemDoesNotExist = ( index == -1 || !this._itemMap.get( id ) );\n\t\t}\n\n\t\tif ( itemDoesNotExist ) {\n\t\t\t/**\n\t\t\t * Item not found.\n\t\t\t *\n\t\t\t * @error collection-remove-404\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-remove-404: Item not found.' );\n\t\t}\n\n\t\tthis._items.splice( index, 1 );\n\t\tthis._itemMap.delete( id );\n\n\t\tconst externalItem = this._bindToInternalToExternalMap.get( item );\n\t\tthis._bindToInternalToExternalMap.delete( item );\n\t\tthis._bindToExternalToInternalMap.delete( externalItem );\n\n\t\tthis.fire( 'remove', item, index );\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @params {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Array} The result of mapping.\n\t */\n\tmap( callback, ctx ) {\n\t\treturn this._items.map( callback, ctx );\n\t}\n\n\t/**\n\t * Finds the first item in the collection for which the `callback` returns a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @returns {Object} The item for which `callback` returned a true value.\n\t * @params {Object} ctx Context in which the `callback` will be called.\n\t */\n\tfind( callback, ctx ) {\n\t\treturn this._items.find( callback, ctx );\n\t}\n\n\t/**\n\t * Returns an array with items for which the `callback` returned a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @params {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object[]} The array with matching items.\n\t */\n\tfilter( callback, ctx ) {\n\t\treturn this._items.filter( callback, ctx );\n\t}\n\n\t/**\n\t * Removes all items from the collection and destroys the binding created using\n\t * {@link #bindTo}.\n\t */\n\tclear() {\n\t\tif ( this._bindToCollection ) {\n\t\t\tthis.stopListening( this._bindToCollection );\n\t\t\tthis._bindToCollection = null;\n\t\t}\n\n\t\twhile ( this.length ) {\n\t\t\tthis.remove( 0 );\n\t\t}\n\t}\n\n\t/**\n\t * Binds and synchronizes the collection with another one.\n\t *\n\t * The binding can be a simple factory:\n\t *\n\t *\t\tclass FactoryClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).as( FactoryClass );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n\t *\n\t *\t\tsource.remove( 0 );\n\t *\t\tconsole.log( target.length ); // 1\n\t *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n\t *\n\t * or the factory driven by a custom callback:\n\t *\n\t *\t\tclass FooClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tclass BarClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( ( item ) => {\n\t *\t\t\tif ( item.label == 'foo' ) {\n\t *\t\t\t\treturn new FooClass( item );\n\t *\t\t\t} else {\n\t *\t\t\t\treturn new BarClass( item );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n\t *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n\t *\n\t * or the factory out of property name:\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( 'label' );\n\t *\n\t *\t\tsource.add( { label: { value: 'foo' } } );\n\t *\t\tsource.add( { label: { value: 'bar' } } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n\t *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n\t *\n\t * It's possible to skip specified items by returning falsy value:\n\t *\n\t *\t\tconst source = new Collection();\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( item => {\n\t *\t\t\tif ( item.hidden ) {\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn item;\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { hidden: true } );\n\t *\t\tsource.add( { hidden: false } );\n\t *\n\t *\t\tconsole.log( source.length ); // 2\n\t *\t\tconsole.log( target.length ); // 1\n\t *\n\t * **Note**: {@link #clear} can be used to break the binding.\n\t *\n\t * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n\t * @returns {Object}\n\t * @returns {module:utils/collection~Collection#bindTo#as} return.as\n\t * @returns {module:utils/collection~Collection#bindTo#using} return.using\n\t */\n\tbindTo( externalCollection ) {\n\t\tif ( this._bindToCollection ) {\n\t\t\t/**\n\t\t\t * The collection cannot be bound more than once.\n\t\t\t *\n\t\t\t * @error collection-bind-to-rebind\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-bind-to-rebind: The collection cannot be bound more than once.' );\n\t\t}\n\n\t\tthis._bindToCollection = externalCollection;\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Creates the class factory binding.\n\t\t\t *\n\t\t\t * @static\n\t\t\t * @param {Function} Class Specifies which class factory is to be initialized.\n\t\t\t */\n\t\t\tas: Class => {\n\t\t\t\tthis._setUpBindToBinding( item => new Class( item ) );\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates callback or property binding.\n\t\t\t *\n\t\t\t * @static\n\t\t\t * @param {Function|String} callbackOrProperty When the function is passed, it is used to\n\t\t\t * produce the items. When the string is provided, the property value is used to create\n\t\t\t * the bound collection items.\n\t\t\t */\n\t\t\tusing: callbackOrProperty => {\n\t\t\t\tif ( typeof callbackOrProperty == 'function' ) {\n\t\t\t\t\tthis._setUpBindToBinding( item => callbackOrProperty( item ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis._setUpBindToBinding( item => item[ callbackOrProperty ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Finalizes and activates a binding initiated by {#bindTo}.\n\t *\n\t * @protected\n\t * @param {Function} factory A function which produces collection items.\n\t */\n\t_setUpBindToBinding( factory ) {\n\t\tconst externalCollection = this._bindToCollection;\n\n\t\t// Adds the item to the collection once a change has been done to the external collection.\n\t\t//\n\t\t// @private\n\t\tconst addItem = ( evt, externalItem, index ) => {\n\t\t\tconst isExternalBoundToThis = externalCollection._bindToCollection == this;\n\t\t\tconst externalItemBound = externalCollection._bindToInternalToExternalMap.get( externalItem );\n\n\t\t\t// If an external collection is bound to this collection, which makes it a 2–way binding,\n\t\t\t// and the particular external collection item is already bound, don't add it here.\n\t\t\t// The external item has been created **out of this collection's item** and (re)adding it will\n\t\t\t// cause a loop.\n\t\t\tif ( isExternalBoundToThis && externalItemBound ) {\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, externalItemBound );\n\t\t\t\tthis._bindToInternalToExternalMap.set( externalItemBound, externalItem );\n\t\t\t} else {\n\t\t\t\tconst item = factory( externalItem );\n\n\t\t\t\t// When there is no item we need to remember skipped index first and then we can skip this item.\n\t\t\t\tif ( !item ) {\n\t\t\t\t\tthis._skippedIndexesFromExternal.push( index );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Lets try to put item at the same index as index in external collection\n\t\t\t\t// but when there are a skipped items in one or both collections we need to recalculate this index.\n\t\t\t\tlet finalIndex = index;\n\n\t\t\t\t// When we try to insert item after some skipped items from external collection we need\n\t\t\t\t// to include this skipped items and decrease index.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n\t\t\t\t// internal -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We can't just add 'D' to internal at the same index as index in external because\n\t\t\t\t// this will produce empty indexes what is invalid:\n\t\t\t\t// internal -> [ 'A', empty, empty, 'D' ]\n\t\t\t\t//\n\t\t\t\t// So we need to include skipped items and decrease index\n\t\t\t\t// internal -> [ 'A', 'D' ]\n\t\t\t\tfor ( const skipped of this._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\t\tfinalIndex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration that external collection could skip some items from\n\t\t\t\t// internal collection.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n\t\t\t\t// external -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We need to include skipped items and place new item after them:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\t\t\t\tfor ( const skipped of externalCollection._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( finalIndex >= skipped ) {\n\t\t\t\t\t\tfinalIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, item );\n\t\t\t\tthis._bindToInternalToExternalMap.set( item, externalItem );\n\t\t\t\tthis.add( item, finalIndex );\n\n\t\t\t\t// After adding new element to internal collection we need update indexes\n\t\t\t\t// of skipped items in external collection.\n\t\t\t\tfor ( let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++ ) {\n\t\t\t\t\tif ( finalIndex <= externalCollection._skippedIndexesFromExternal[ i ] ) {\n\t\t\t\t\t\texternalCollection._skippedIndexesFromExternal[ i ]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Load the initial content of the collection.\n\t\tfor ( const externalItem of externalCollection ) {\n\t\t\taddItem( null, externalItem, externalCollection.getIndex( externalItem ) );\n\t\t}\n\n\t\t// Synchronize the with collection as new items are added.\n\t\tthis.listenTo( externalCollection, 'add', addItem );\n\n\t\t// Synchronize the with collection as new items are removed.\n\t\tthis.listenTo( externalCollection, 'remove', ( evt, externalItem, index ) => {\n\t\t\tconst item = this._bindToExternalToInternalMap.get( externalItem );\n\n\t\t\tif ( item ) {\n\t\t\t\tthis.remove( item );\n\t\t\t}\n\n\t\t\t// After removing element from external collection we need update/remove indexes\n\t\t\t// of skipped items in internal collection.\n\t\t\tthis._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce( ( result, skipped ) => {\n\t\t\t\tif ( index < skipped ) {\n\t\t\t\t\tresult.push( skipped - 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\tresult.push( skipped );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Fired when an item is added to the collection.\n\t *\n\t * @event add\n\t * @param {Object} item The added item.\n\t */\n\n\t/**\n\t * Fired when an item is removed from the collection.\n\t *\n\t * @event remove\n\t * @param {Object} item The removed item.\n\t * @param {Number} index Index from which item was removed.\n\t */\n}\n\nmix( Collection, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/document\n */\n\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Document {\n\t/**\n\t * Creates a Document instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Selection done on this document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n\t\t */\n\t\tthis.selection = new DocumentSelection();\n\n\t\t/**\n\t\t * Roots of the view tree. Collection of the {module:engine/view/element~Element view elements}.\n\t\t *\n\t\t * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n\t\t * {@link module:engine/model/document~Document#roots} and this is handled by\n\t\t * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n\t\t * model root using {@link module:engine/model/document~Document#createRoot}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Collection} module:engine/view/document~Document#roots\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * Defines whether document is in read-only mode.\n\t\t *\n\t\t * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * True if document is focused.\n\t\t *\n\t\t * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n\t\t * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/document~Document#isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * True if composition is in progress inside the document.\n\t\t *\n\t\t * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n\t\t * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} module:engine/view/document~Document#isComposing\n\t\t */\n\t\tthis.set( 'isComposing', false );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the view document.\n\t\t *\n\t\t * @private\n\t\t * @member {Set}\n\t\t */\n\t\tthis._postFixers = new Set();\n\t}\n\n\t/**\n\t * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n\t * specific \"main\" root is returned.\n\t *\n\t * @param {String} [name='main'] Name of the root.\n\t * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n\t * or null when there is no root of given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixers mechanism allows to update view tree just before rendering\n\t * to the DOM.\n\t *\n\t * Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * View post-fixers are useful when you wants to update view structure whenever it changes, for instance add some classes\n\t * to elements based on the view structure or selection. However, is you need DOM elements to be already updated, use\n\t * {@link module:engine/view/view~View#event:render render event}.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/view/writer~Writer writer} instance connected with the\n\t * executed changes block.\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @protected\n\t * @param {module:engine/view/writer~Writer} writer\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Event fired whenever document content layout changes. It is fired whenever content is\n\t * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of\n\t * other actions which may change layout, for instance when image loads.\n\t *\n\t * @event layoutChanged\n\t */\n}\n\nmix( Document, ObservableMixin );\n\n/**\n * Enum representing type of the change.\n *\n * Possible values:\n *\n * * `children` - for child list changes,\n * * `attributes` - for element attributes changes,\n * * `text` - for text nodes changes.\n *\n * @typedef {String} module:engine/view/document~ChangeType\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/attributeelement\n */\n\nimport Element from './element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// Default attribute priority.\nconst DEFAULT_PRIORITY = 10;\n\n/**\n * Attributes are elements which define document presentation. They are mostly elements like `<b>` or `<span>`.\n * Attributes can be broken and merged by the {@link module:engine/view/writer~Writer view writer}.\n *\n * Editing engine does not define fixed HTML DTD. This is why the type of the {@link module:engine/view/element~Element} need to\n * be defined by the feature developer. Creating an element you should use {@link module:engine/view/containerelement~ContainerElement}\n * class or `AttributeElement`.\n *\n * @extends module:engine/view/element~Element\n */\nexport default class AttributeElement extends Element {\n\t/**\n\t * Creates a attribute element.\n\t *\n\t * @see module:engine/view/writer~Writer#createAttributeElement\n\t * @protected\n\t * @see module:engine/view/element~Element\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( name, attrs, children );\n\n\t\t/**\n\t\t * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.\n\t\t *\n\t\t * @method #getFillerOffset\n\t\t * @returns {Number|null} Block filler offset or `null` if block filler is not needed.\n\t\t */\n\t\tthis.getFillerOffset = getFillerOffset;\n\n\t\t/**\n\t\t * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/writer~Writer}.\n\t\t *\n\t\t * @protected\n\t\t * @member {Number}\n\t\t */\n\t\tthis._priority = DEFAULT_PRIORITY;\n\n\t\t/**\n\t\t * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},\n\t\t * and then two elements are considered similar if, and only if they have the same `_id`.\n\t\t *\n\t\t * @protected\n\t\t * @member {String|Number}\n\t\t */\n\t\tthis._id = null;\n\n\t\t/**\n\t\t * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~AttributeElement#id ids}\n\t\t * and still exist in the view tree.\n\t\t *\n\t\t * This property is managed by {@link module:engine/view/writer~Writer}.\n\t\t *\n\t\t * @protected\n\t\t * @member {Set|null}\n\t\t */\n\t\tthis._clonesGroup = null;\n\t}\n\n\t/**\n\t * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/writer~Writer}.\n\t *\n\t * @readonly\n\t * @returns {Number}\n\t */\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n\t/**\n\t * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},\n\t * and then two elements are considered similar if, and only if they have the same `id`.\n\t *\n\t * @readonly\n\t * @returns {String|Number}\n\t */\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the\n\t * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).\n\t *\n\t * Note: If this element has been removed from the tree, returned set will not include it.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}\n\t * if this element has no `id`.\n\t *\n\t * @returns {Set.<module:engine/view/attributeelement~AttributeElement>} Set containing all the attribute elements\n\t * with the same `id` that were added and not removed from the view tree.\n\t */\n\tgetElementsWithSameId() {\n\t\tif ( this.id === null ) {\n\t\t\t/**\n\t\t\t * Cannot get elements with the same id for an attribute element without id.\n\t\t\t *\n\t\t\t * @error attribute-element-get-elements-with-same-id-no-id\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'attribute-element-get-elements-with-same-id-no-id: ' +\n\t\t\t\t'Cannot get elements with the same id for an attribute element without id.'\n\t\t\t);\n\t\t}\n\n\t\treturn new Set( this._clonesGroup );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'attributeElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'attributeElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this element is similar to other element.\n\t *\n\t * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements\n\t * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain\n\t * different set of children nodes.\n\t *\n\t * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both\n\t * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be\n\t * considered similar.\n\t *\n\t * Similarity is important for {@link module:engine/view/writer~Writer}. For example:\n\t *\n\t * * two following similar elements can be merged together into one, longer element,\n\t * * {@link module:engine/view/writer~Writer#unwrap} checks similarity of passed element and processed element to\n\t * decide whether processed element should be unwrapped,\n\t * * etc.\n\t *\n\t * @param {module:engine/view/element~Element} otherElement\n\t * @returns {Boolean}\n\t */\n\tisSimilar( otherElement ) {\n\t\t// If any element has an `id` set, just compare the ids.\n\t\tif ( this.id !== null || otherElement.id !== null ) {\n\t\t\treturn this.id === otherElement.id;\n\t\t}\n\n\t\treturn super.isSimilar( otherElement ) && this.priority == otherElement.priority;\n\t}\n\n\t/**\n\t * Clones provided element with priority.\n\t *\n\t * @protected\n\t * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any children.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Clone of this element.\n\t */\n\t_clone( deep ) {\n\t\tconst cloned = super._clone( deep );\n\n\t\t// Clone priority too.\n\t\tcloned._priority = this._priority;\n\n\t\t// And id too.\n\t\tcloned._id = this._id;\n\n\t\treturn cloned;\n\t}\n}\n\n/**\n * Default attribute priority.\n *\n * @member {Number} module:engine/view/attributeelement~AttributeElement.DEFAULT_PRIORITY\n */\nAttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;\n\n// Returns block {@link module:engine/view/filler~Filler filler} offset or `null` if block filler is not needed.\n//\n// @returns {Number|null} Block filler offset or `null` if block filler is not needed.\nfunction getFillerOffset() {\n\t// <b>foo</b> does not need filler.\n\tif ( nonUiChildrenCount( this ) ) {\n\t\treturn null;\n\t}\n\n\tlet element = this.parent;\n\n\t// <p><b></b></p> needs filler -> <p><b><br></b></p>\n\twhile ( element && element.is( 'attributeElement' ) ) {\n\t\tif ( nonUiChildrenCount( element ) > 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\telement = element.parent;\n\t}\n\n\tif ( !element || nonUiChildrenCount( element ) > 1 ) {\n\t\treturn null;\n\t}\n\n\t// Render block filler at the end of element (after all ui elements).\n\treturn this.childCount;\n}\n\n// Returns total count of children that are not {@link module:engine/view/uielement~UIElement UIElements}.\n//\n// @param {module:engine/view/element~Element} element\n// @returns {Number}\nfunction nonUiChildrenCount( element ) {\n\treturn Array.from( element.getChildren() ).filter( element => !element.is( 'uiElement' ) ).length;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/emptyelement\n */\n\nimport Element from './element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Node from './node';\n\n/**\n * EmptyElement class. It is used to represent elements that cannot contain any child nodes.\n */\nexport default class EmptyElement extends Element {\n\t/**\n\t * Creates new instance of EmptyElement.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,\n\t * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).\n\t *\n\t * @see module:engine/view/writer~Writer#createEmptyElement\n\t * @protected\n\t * @param {String} name Node name.\n\t * @param {Object|Iterable} [attributes] Collection of attributes.\n\t */\n\tconstructor( name, attributes, children ) {\n\t\tsuper( name, attributes, children );\n\n\t\t/**\n\t\t * Returns `null` because filler is not needed for EmptyElements.\n\t\t *\n\t\t * @method #getFillerOffset\n\t\t * @returns {null} Always returns null.\n\t\t */\n\t\tthis.getFillerOffset = getFillerOffset;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'emptyElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'emptyElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\t/**\n\t * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent\n\t * adding any child nodes to EmptyElement.\n\t *\n\t * @protected\n\t */\n\t_insertChild( index, nodes ) {\n\t\tif ( nodes && ( nodes instanceof Node || Array.from( nodes ).length > 0 ) ) {\n\t\t\t/**\n\t\t\t * Cannot add children to {@link module:engine/view/emptyelement~EmptyElement}.\n\t\t\t *\n\t\t\t * @error view-emptyelement-cannot-add\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.' );\n\t\t}\n\t}\n}\n\n// Returns `null` because block filler is not needed for EmptyElements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals navigator:false */\n\n/**\n * @module utils/env\n */\n\nconst userAgent = navigator.userAgent.toLowerCase();\n\n/**\n * A namespace containing environment and browser information.\n *\n * @namespace\n */\nconst env = {\n\t/**\n\t * Indicates that the application is running on Macintosh.\n\t *\n\t * @static\n\t * @member {Boolean} module:utils/env~env#isMac\n\t */\n\tisMac: isMac( userAgent ),\n\n\t/**\n\t * Indicates that the application is running in Microsoft Edge.\n\t *\n\t * @static\n\t * @member {Boolean} module:utils/env~env#isEdge\n\t */\n\tisEdge: isEdge( userAgent )\n};\n\nexport default env;\n\n/**\n * Checks if User Agent represented by the string is running on Macintosh.\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is running on Macintosh or not.\n */\nexport function isMac( userAgent ) {\n\treturn userAgent.indexOf( 'macintosh' ) > -1;\n}\n\n/**\n * Checks if User Agent represented by the string is Microsoft Edge.\n *\n * @param {String} userAgent **Lowercase** `navigator.userAgent` string.\n * @returns {Boolean} Whether User Agent is Edge or not.\n */\nexport function isEdge( userAgent ) {\n\treturn !!userAgent.match( /edge\\/(\\d+.?\\d*)/ );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Set of utils related to keyboard support.\n *\n * @module utils/keyboard\n */\n\nimport CKEditorError from './ckeditorerror';\nimport env from './env';\n\nconst macGlyphsToModifiers = {\n\t'⌘': 'ctrl',\n\t'⇧': 'shift',\n\t'⌥': 'alt'\n};\n\nconst modifiersToMacGlyphs = {\n\t'ctrl': '⌘',\n\t'shift': '⇧',\n\t'alt': '⌥'\n};\n\n/**\n * Object with `keyName => keyCode` pairs for a set of known keys.\n *\n * Contains:\n *\n * * `a-z`,\n * * `0-9`,\n * * `f1-f12`,\n * * `arrow(left|up|right|bottom)`,\n * * `backspace`, `delete`, `enter`, `esc`, `tab`,\n * * `ctrl`, `cmd`, `shift`, `alt`.\n */\nexport const keyCodes = generateKnownKeyCodes();\n\n/**\n * Converts a key name or a {@link module:utils/keyboard~KeystrokeInfo keystroke info} into a key code.\n *\n * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.\n *\n * @param {String|module:utils/keyboard~KeystrokeInfo} Key name (see {@link module:utils/keyboard~keyCodes})\n * or a keystroke data object.\n * @returns {Number} Key or keystroke code.\n */\nexport function getCode( key ) {\n\tlet keyCode;\n\n\tif ( typeof key == 'string' ) {\n\t\tkeyCode = keyCodes[ key.toLowerCase() ];\n\n\t\tif ( !keyCode ) {\n\t\t\t/**\n\t\t\t * Unknown key name. Only key names contained by the {@link module:utils/keyboard~keyCodes} can be used.\n\t\t\t *\n\t\t\t * @errror keyboard-unknown-key\n\t\t\t * @param {String} key\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'keyboard-unknown-key: Unknown key name.', { key } );\n\t\t}\n\t} else {\n\t\tkeyCode = key.keyCode +\n\t\t\t( key.altKey ? keyCodes.alt : 0 ) +\n\t\t\t( key.ctrlKey ? keyCodes.ctrl : 0 ) +\n\t\t\t( key.shiftKey ? keyCodes.shift : 0 );\n\t}\n\n\treturn keyCode;\n}\n\n/**\n * Parses keystroke and returns a keystroke code that will match the code returned by\n * link {@link module:utils/keyboard.getCode} for a corresponding {@link module:utils/keyboard~KeystrokeInfo keystroke info}.\n *\n * The keystroke can be passed in two formats:\n *\n * * as a single string – e.g. `ctrl + A`,\n * * as an array of {@link module:utils/keyboard~keyCodes known key names} and key codes – e.g.:\n *   * `[ 'ctrl', 32 ]` (ctrl + space),\n *   * `[ 'ctrl', 'a' ]` (ctrl + A).\n *\n * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.\n *\n * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).\n *\n * @param {String|Array.<Number|String>} keystroke Keystroke definition.\n * @returns {Number} Keystroke code.\n */\nexport function parseKeystroke( keystroke ) {\n\tif ( typeof keystroke == 'string' ) {\n\t\tkeystroke = splitKeystrokeText( keystroke );\n\t}\n\n\treturn keystroke\n\t\t.map( key => ( typeof key == 'string' ) ? getCode( key ) : key )\n\t\t.reduce( ( key, sum ) => sum + key, 0 );\n}\n\n/**\n * It translates any keystroke string text like `\"CTRL+A\"` to an\n * environment–specific keystroke, i.e. `\"⌘A\"` on Mac OSX.\n *\n * @param {String} keystroke Keystroke text.\n * @returns {String} Keystroke text specific for the environment.\n */\nexport function getEnvKeystrokeText( keystroke ) {\n\tif ( !env.isMac ) {\n\t\treturn keystroke;\n\t}\n\n\treturn splitKeystrokeText( keystroke )\n\t\t// Replace modifiers (e.g. \"ctrl\") with Mac glyphs (e.g. \"⌘\") first.\n\t\t.map( key => modifiersToMacGlyphs[ key.toLowerCase() ] || key )\n\n\t\t// Decide whether to put \"+\" between keys in the keystroke or not.\n\t\t.reduce( ( value, key ) => {\n\t\t\tif ( value.slice( -1 ) in macGlyphsToModifiers ) {\n\t\t\t\treturn value + key;\n\t\t\t} else {\n\t\t\t\treturn value + '+' + key;\n\t\t\t}\n\t\t} );\n}\n\nfunction generateKnownKeyCodes() {\n\tconst keyCodes = {\n\t\tarrowleft: 37,\n\t\tarrowup: 38,\n\t\tarrowright: 39,\n\t\tarrowdown: 40,\n\t\tbackspace: 8,\n\t\tdelete: 46,\n\t\tenter: 13,\n\t\tspace: 32,\n\t\tesc: 27,\n\t\ttab: 9,\n\n\t\t// The idea about these numbers is that they do not collide with any real key codes, so we can use them\n\t\t// like bit masks.\n\t\tctrl: 0x110000,\n\t\t// Has the same code as ctrl, because their behaviour should be unified across the editor.\n\t\t// See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd\n\t\tcmd: 0x110000,\n\t\tshift: 0x220000,\n\t\talt: 0x440000\n\t};\n\n\t// a-z\n\tfor ( let code = 65; code <= 90; code++ ) {\n\t\tconst letter = String.fromCharCode( code );\n\n\t\tkeyCodes[ letter.toLowerCase() ] = code;\n\t}\n\n\t// 0-9\n\tfor ( let code = 48; code <= 57; code++ ) {\n\t\tkeyCodes[ code - 48 ] = code;\n\t}\n\n\t// F1-F12\n\tfor ( let code = 112; code <= 123; code++ ) {\n\t\tkeyCodes[ 'f' + ( code - 111 ) ] = code;\n\t}\n\n\treturn keyCodes;\n}\n\nfunction splitKeystrokeText( keystroke ) {\n\treturn keystroke.split( /\\s*\\+\\s*/ );\n}\n\n/**\n * Information about a keystroke.\n *\n * @interface module:utils/keyboard~KeystrokeInfo\n */\n\n/**\n * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).\n *\n * @member {Number} module:utils/keyboard~KeystrokeInfo#keyCode\n */\n\n/**\n * Whether the <kbd>Alt</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#altKey\n */\n\n/**\n * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#ctrlKey\n */\n\n/**\n * Whether the <kbd>Shift</kbd> modifier was pressed.\n *\n * @member {Bolean} module:utils/keyboard~KeystrokeInfo#shiftKey\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/uielement\n */\n\nimport Element from './element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Node from './node';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * UIElement class. It is used to represent UI not a content of the document.\n * This element can't be split and selection can't be placed inside this element.\n */\nexport default class UIElement extends Element {\n\t/**\n\t * Creates new instance of UIElement.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,\n\t * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).\n\t *\n\t * @see module:engine/view/writer~Writer#createUIElement\n\t * @protected\n\t * @param {String} name Node name.\n\t * @param {Object|Iterable} [attributes] Collection of attributes.\n\t */\n\tconstructor( name, attributes, children ) {\n\t\tsuper( name, attributes, children );\n\n\t\t/**\n\t\t * Returns `null` because filler is not needed for UIElements.\n\t\t *\n\t\t * @method #getFillerOffset\n\t\t * @returns {null} Always returns null.\n\t\t */\n\t\tthis.getFillerOffset = getFillerOffset;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'uiElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'uiElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\t/**\n\t * Overrides {@link module:engine/view/element~Element#_insertChild} method.\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes\n\t * to UIElement.\n\t */\n\t_insertChild( index, nodes ) {\n\t\tif ( nodes && ( nodes instanceof Node || Array.from( nodes ).length > 0 ) ) {\n\t\t\t/**\n\t\t\t * Cannot add children to {@link module:engine/view/uielement~UIElement}.\n\t\t\t *\n\t\t\t * @error view-uielement-cannot-add\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-uielement-cannot-add: Cannot add child nodes to UIElement instance.' );\n\t\t}\n\t}\n\n\t/**\n\t * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by\n\t * {@link module:engine/view/domconverter~DomConverter}.\n\t * Do not use inheritance to create custom rendering method, replace `render()` method instead:\n\t *\n\t *\t\tconst myUIElement = new UIElement( 'span' );\n\t *\t\tmyUIElement.render = function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t};\n\t *\n\t * @param {Document} domDocument\n\t * @returns {HTMLElement}\n\t */\n\trender( domDocument ) {\n\t\treturn this.toDomElement( domDocument );\n\t}\n\n\t/**\n\t * Creates DOM element based on this view UIElement.\n\t * Note that each time this method is called new DOM element is created.\n\t *\n\t * @param {Document} domDocument\n\t * @returns {HTMLElement}\n\t */\n\ttoDomElement( domDocument ) {\n\t\tconst domElement = domDocument.createElement( this.name );\n\n\t\tfor ( const key of this.getAttributeKeys() ) {\n\t\t\tdomElement.setAttribute( key, this.getAttribute( key ) );\n\t\t}\n\n\t\treturn domElement;\n\t}\n}\n\n/**\n * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.\n *\n * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.\n * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.\n * Without this handler, it would be impossible to \"jump over\" UI element using right arrow key.\n *\n * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.\n */\nexport function injectUiElementHandling( view ) {\n\tview.document.on( 'keydown', ( evt, data ) => jumpOverUiElement( evt, data, view.domConverter ) );\n}\n\n// Returns `null` because block filler is not needed for UIElements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This\n// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection\n// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.\nfunction jumpOverUiElement( evt, data, domConverter ) {\n\tif ( data.keyCode == keyCodes.arrowright ) {\n\t\tconst domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\t\tconst domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed;\n\n\t\t// Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.\n\t\tif ( domSelectionCollapsed || data.shiftKey ) {\n\t\t\tconst domParent = domSelection.focusNode;\n\t\t\tconst domOffset = domSelection.focusOffset;\n\n\t\t\tconst viewPosition = domConverter.domPositionToView( domParent, domOffset );\n\n\t\t\t// In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.\n\t\t\tif ( viewPosition === null ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip all following ui elements.\n\t\t\tlet jumpedOverAnyUiElement = false;\n\n\t\t\tconst nextViewPosition = viewPosition.getLastMatchingPosition( value => {\n\t\t\t\tif ( value.item.is( 'uiElement' ) ) {\n\t\t\t\t\t// Remember that there was at least one ui element.\n\t\t\t\t\tjumpedOverAnyUiElement = true;\n\t\t\t\t}\n\n\t\t\t\t// Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.\n\t\t\t\tif ( value.item.is( 'uiElement' ) || value.item.is( 'attributeElement' ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Don't jump over text or don't get out of container element.\n\t\t\t\treturn false;\n\t\t\t} );\n\n\t\t\t// If anything has been skipped, fix position.\n\t\t\t// This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.\n\t\t\tif ( jumpedOverAnyUiElement ) {\n\t\t\t\tconst newDomPosition = domConverter.viewPositionToDom( nextViewPosition );\n\n\t\t\t\tif ( domSelectionCollapsed ) {\n\t\t\t\t\t// Selection was collapsed, so collapse it at further position.\n\t\t\t\t\tdomSelection.collapse( newDomPosition.parent, newDomPosition.offset );\n\t\t\t\t} else {\n\t\t\t\t\t// Selection was not collapse, so extend it instead of collapsing.\n\t\t\t\t\tdomSelection.extend( newDomPosition.parent, newDomPosition.offset );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/documentfragment\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\n/**\n * DocumentFragment class.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates new DocumentFragment instance.\n\t *\n\t * @protected\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children] List of nodes to be inserted into\n\t * created document fragment.\n\t */\n\tconstructor( children ) {\n\t\t/**\n\t\t * Array of child nodes.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = [];\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over nodes added to this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Number of child nodes in this document fragment.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether given view tree object is of given type.\n\t *\n\t * Read more in {@link module:engine/view/node~Node#is}.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'documentFragment';\n\t}\n\n\t/**\n\t * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end\n\t * and sets the parent of these nodes to this fragment.\n\t *\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @returns {Number} Number of appended nodes.\n\t */\n\t_appendChild( items ) {\n\t\treturn this._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Gets child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/view/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children[ index ];\n\t}\n\n\t/**\n\t * Gets index of the given child node. Returns `-1` if child node is not found.\n\t *\n\t * @param {module:engine/view/node~Node} node Child node.\n\t * @returns {Number} Index of the child node.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.indexOf( node );\n\t}\n\n\t/**\n\t * Gets child nodes iterator.\n\t *\n\t * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to\n\t * this fragment.\n\t *\n\t * @param {Number} index Position where nodes should be inserted.\n\t * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.\n\t * @returns {Number} Number of inserted nodes.\n\t */\n\t_insertChild( index, items ) {\n\t\tthis._fireChange( 'children', this );\n\t\tlet count = 0;\n\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\n\t\t\tthis._children.splice( index, 0, node );\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.\n\t *\n\t * @param {Number} index Number of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tthis._fireChange( 'children', this );\n\n\t\tfor ( let i = index; i < index + howMany; i++ ) {\n\t\t\tthis._children[ i ].parent = null;\n\t\t}\n\n\t\treturn this._children.splice( index, howMany );\n\t}\n\n\t/**\n\t * Fires `change` event with given type of the change.\n\t *\n\t * @private\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Changed node.\n\t * @fires module:engine/view/node~Node#change\n\t */\n\t_fireChange( type, node ) {\n\t\tthis.fire( 'change:' + type, node );\n\t}\n}\n\nmix( DocumentFragment, EmitterMixin );\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}\n// @returns {Iterable.<module:engine/view/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module module:engine/view/writer\n */\n\nimport Position from './position';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport Range from './range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport isPlainObject from '@ckeditor/ckeditor5-utils/src/lib/lodash/isPlainObject';\nimport Text from './text';\nimport EditableElement from './editableelement';\n\n/**\n * View writer class. Provides set of methods used to properly manipulate nodes attached to\n * {@link module:engine/view/document~Document view document}. It is not recommended to use it directly. To get an instance\n * of view writer associated with the document use {@link module:engine/view/view~View#change view.change()) method.\n */\nexport default class Writer {\n\tconstructor( document ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/documentselection~DocumentSelection document selection},\n\t * {@link module:engine/view/selection~Selection selection}, {@link module:engine/view/position~Position position},\n\t * {@link module:engine/view/item~Item item}, {@link module:engine/view/range~Range range},\n\t * an iterable of {@link module:engine/view/range~Range ranges} or null.\n\t *\n\t * ### Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'paragraph' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `Writer#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selection|module:engine/view/position~Position|\n\t * Iterable.<module:engine/view/range~Range>|module:engine/view/range~Range|module:engine/view/item~Item|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/position~Position.createAt} parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data Text data.\n\t * @returns {module:engine/view/text~Text} Created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( data );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'strong', { 'alignment': 'center' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'myMarker' }, { id: 'marker:my' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( name, attributes );\n\n\t\tif ( options.priority ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'paragraph' );\n\t *\t\twriter.createContainerElement( 'paragraph', { 'alignment': 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes ) {\n\t\treturn new ContainerElement( name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { 'alignment': 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { 'alignment': 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes ) {\n\t\treturn new EmptyElement( name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { 'alignment': 'center' } );\n\t *\n\t * Custom render function can be provided as third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Function} [renderFunction] Custom render function.\n\t * @returns {module:engine/view/uielement~UIElement} Created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction ) {\n\t\tconst uiElement = new UIElement( name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Adds or overwrite element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element );  // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside\n\t * up to a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:\n\t *\n\t *        <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *        <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *        <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *        <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** Difference between {@link module:engine/view/writer~Writer#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/writer~Writer#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/writer~Writer#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute\n\t * elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position\n\t * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning\n\t * or at the end of it's parent element.\n\t *\n\t *        <p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *        <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *        <p>^foobar</p> -> ^<p>foobar</p>\n\t *        <p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** Difference between {@link module:engine/view/writer~Writer#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/writer~Writer#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/writer~Writer#breakAttributes\n\t * @param {module:engine/view/position~Position} position Position where to break element.\n\t * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,\n\t * the returned position is placed either before it or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-break-non-container-element: Trying to break an element which is not a container element.'\n\t\t\t);\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root: Trying to break root element.' );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position.createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position.createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position.createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position.createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *        <p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *        <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *        <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *        <p><b>[]</b></p> -> <p>[]</p>\n\t *        <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/writer~Writer#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/writer~Writer#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/writer~Writer#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *        <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *        <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/writer~Writer#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/writer~Writer#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/writer~Writer#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position: ' +\n\t\t\t\t'Element before and after given position cannot be merged.' );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position.createAt( lastChild, 'end' ) : Position.createAt( prev, 'end' );\n\n\t\tthis.move( Range.createIn( next ), Position.createAt( prev, 'end' ) );\n\t\tthis.remove( Range.createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Insert node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes );\n\n\t\tconst container = getParentContainer( position );\n\n\t\tif ( !container ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-invalid-position-container' );\n\t\t}\n\n\t\tconst insertionPosition = this._breakAttributes( position, true );\n\t\tconst length = container._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( length === 0 ) {\n\t\t\treturn new Range( start, start );\n\t\t} else {\n\t\t\t// If start position was merged - move end position.\n\t\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\t\tendPosition.offset--;\n\t\t\t}\n\n\t\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to remove from container. After removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( range ) {\n\t\tvalidateRangeContainer( range );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment();\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = Position.createFromPosition( mergePosition );\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range.createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( 'textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range.createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n     * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n     *\n     * If a collapsed range was passed and is same as selection, the selection\n     * will be moved to the inside of the wrapped attribute element.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n     * when {@link module:engine/view/range~Range#start}\n     * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n     * is collapsed and different than view selection.\n     *\n     * @param {module:engine/view/range~Range} range Range to wrap.\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n     * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n    */\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError( 'view-writer-wrap-invalid-attribute' );\n\t\t}\n\n\t\tvalidateRangeContainer( range );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * Attribute element need to be instance of attribute element.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-unwrap-invalid-attribute' );\n\t\t}\n\n\t\tvalidateRangeContainer( range );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\n\t\t// Range around one element - check if AttributeElement can be unwrapped partially when it's not similar.\n\t\t// For example:\n\t\t// <b class=\"foo bar\" title=\"baz\"></b> unwrap with:\t<b class=\"foo\"></p> result: <b class\"bar\" title=\"baz\"></b>\n\t\tif ( breakEnd.isEqual( breakStart.getShiftedBy( 1 ) ) ) {\n\t\t\tconst node = breakStart.nodeAfter;\n\n\t\t\t// Unwrap single attribute element.\n\t\t\tif ( !attribute.isSimilar( node ) && node instanceof AttributeElement && this._unwrapAttributeElement( attribute, node ) ) {\n\t\t\t\tconst start = this.mergeAttributes( breakStart );\n\n\t\t\t\tif ( !start.isEqual( breakStart ) ) {\n\t\t\t\t\tbreakEnd.offset--;\n\t\t\t\t}\n\n\t\t\t\tconst end = this.mergeAttributes( breakEnd );\n\n\t\t\t\treturn new Range( start, end );\n\t\t\t}\n\t\t}\n\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t * @param {String} newName New name for element.\n\t */\n\trename( viewElement, newName ) {\n\t\tconst newElement = new ContainerElement( newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position.createAfter( viewElement ), newElement );\n\t\tthis.move( Range.createIn( viewElement ), Position.createAt( newElement ) );\n\t\tthis.remove( Range.createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Wraps children with provided `attribute`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} attribute\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, attribute ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( 'text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isEmpty = child.is( 'emptyElement' );\n\t\t\tconst isUI = child.is( 'uiElement' );\n\n\t\t\t// Wrap text, empty elements, ui elements or attributes with higher or equal priority.\n\t\t\tif ( isText || isEmpty || isUI || ( isAttribute && shouldABeOutsideB( attribute, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = attribute._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push(\tnew Position( parent, i ) );\n\t\t\t}\n\t\t\t// If other nested attribute is found start wrapping there.\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, attribute );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range.createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `attribute`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} attribute\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, attribute ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// If attributes are the similar, then unwrap.\n\t\t\tif ( child.isSimilar( attribute ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming that there won't be another element to unwrap in child\n\t\t\t\t// elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\t\t\t} else {\n\t\t\t\t// If other nested attribute is found start unwrapping there.\n\t\t\t\tif ( child.is( 'attributeElement' ) ) {\n\t\t\t\t\tthis._unwrapChildren( child, 0, child.childCount, attribute );\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range.createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Range is inside single attribute and spans on all children.\n\t\tif ( rangeSpansOnAllChildren( range ) && this._wrapAttributeElement( attribute, range.start.parent ) ) {\n\t\t\tconst parent = range.start.parent;\n\n\t\t\tconst end = this.mergeAttributes( Position.createAfter( parent ) );\n\t\t\tconst start = this.mergeAttributes( Position.createBefore( parent ) );\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\n\t\t// Range around one element.\n\t\tif ( breakEnd.isEqual( breakStart.getShiftedBy( 1 ) ) ) {\n\t\t\tconst node = breakStart.nodeAfter;\n\n\t\t\tif ( node instanceof AttributeElement && this._wrapAttributeElement( attribute, node ) ) {\n\t\t\t\tconst start = this.mergeAttributes( breakStart );\n\n\t\t\t\tif ( !start.isEqual( breakStart ) ) {\n\t\t\t\t\tbreakEnd.offset--;\n\t\t\t\t}\n\n\t\t\t\tconst end = this.mergeAttributes( breakEnd );\n\n\t\t\t\treturn new Range( start, end );\n\t\t\t}\n\t\t}\n\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst unwrappedRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, unwrappedRange.start.offset, unwrappedRange.end.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( Position.createFromPosition( position ) );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( 'text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `Writer` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `Writer` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside EmptyElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element' );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside UIElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element' );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( 'text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn Position.createFromPosition( position );\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn Position.createFromPosition( position );\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else\n\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\tif ( positionOffset === 0 ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t}\n\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\telse {\n\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t// Break element.\n\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t// Insert cloned node to position's parent node.\n\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t// Get nodes to move.\n\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t// Move nodes to cloned node.\n\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t// Create new position to work on.\n\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t\t// If all other elements are removed from the set, everything will be garbage collected.\n\n\t\tif ( group.size === 0 ) {\n\t\t\tthis._cloneGroups.delete( id );\n\t\t}\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * Attribute element need to be instance of attribute element.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped otuside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( 'text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( 'text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Returns `true` if range is located in same {@link module:engine/view/attributeelement~AttributeElement AttributeElement}\n// (`start` and `end` positions are located inside same {@link module:engine/view/attributeelement~AttributeElement AttributeElement}),\n// starts on 0 offset and ends after last child node.\n//\n// @param {module:engine/view/range~Range} Range\n// @returns {Boolean}\nfunction rangeSpansOnAllChildren( range ) {\n\treturn range.start.parent == range.end.parent && range.start.parent.is( 'attributeElement' ) &&\n\t\trange.start.offset === 0 && range.end.offset === range.start.parent.childCount;\n}\n\n// Checks if provided nodes are valid to insert. Checks if each node is an instance of\n// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n// {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or\n// {@link module:engine/view/uielement~UIElement UIElement}.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not {@link module:engine/view/text~Text Texts},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n// {@link module:engine/view/uielement~UIElement UIElements},\n// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or\n// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement\n// |module:engine/view/containerelement~ContainerElement> nodes\nfunction validateNodesToInsert( nodes ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node' );\n\t\t}\n\n\t\tif ( !node.is( 'text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren() );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\nfunction validateRangeContainer( range ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or\n\t\t * parent container for these positions cannot be found.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container' );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window, Text */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * Set of utils related to block and inline fillers handling.\n *\n * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all\n * empty elements which should be selectable with elements or characters called \"fillers\". Unfortunately there is no one\n * universal filler, this is why two types are uses:\n *\n * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,\n * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that\n * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be\n * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used\n * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other\n * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.\n *\n * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty\n * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width\n * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined\n * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to\n * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not\n * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional\n * code is needed to handle the caret.\n *\n * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the\n * view.\n *\n * @module engine/view/filler\n */\n\n/**\n * `<br> filler creator. This is a function which creates `<br data-cke-filler=\"true\">` element.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~NBSP_FILLER\n * @function\n */\nexport const BR_FILLER = domDocument => {\n\tconst fillerBr = domDocument.createElement( 'br' );\n\tfillerBr.dataset.ckeFiller = true;\n\n\treturn fillerBr;\n};\n\n/**\n * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~BR_FILLER\n * @function\n */\nexport const NBSP_FILLER = domDocument => domDocument.createTextNode( '\\u00A0' );\n\n/**\n * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.\n */\nexport const INLINE_FILLER_LENGTH = 7;\n\n/**\n * Inline filler which is sequence of the zero width spaces.\n */\nexport let INLINE_FILLER = '';\n\nfor ( let i = 0; i < INLINE_FILLER_LENGTH; i++ ) {\n\tINLINE_FILLER += '\\u200b';\n}\n\n/**\n * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( 'foo' ) ); // false\n *\t\tstartsWithFiller( document.createElement( 'p' ) ); // false\n *\n * @param {Node} domNode DOM node.\n * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\nexport function startsWithFiller( domNode ) {\n\treturn ( domNode instanceof Text ) && ( domNode.data.substr( 0, INLINE_FILLER_LENGTH ) === INLINE_FILLER );\n}\n\n/**\n * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false\n *\n * @param {Text} domText DOM text node.\n * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\nexport function isInlineFiller( domText ) {\n\treturn domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller( domText );\n}\n\n/**\n * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,\n * if text node contains it.\n *\n *\t\tgetDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true\n *\t\tgetDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true\n *\n * @param {Text} domText DOM text node, possible with inline filler.\n * @returns {String} Data without filler.\n */\nexport function getDataWithoutFiller( domText ) {\n\tif ( startsWithFiller( domText ) ) {\n\t\treturn domText.data.slice( INLINE_FILLER_LENGTH );\n\t} else {\n\t\treturn domText.data;\n\t}\n}\n\n// Cache block fillers templates to improve performance.\nconst templateBlockFillers = new WeakMap();\n\n/**\n * Checks if the node is an instance of the block filler of the given type.\n *\n *\t\tconst brFillerInstance = BR_FILLER( document );\n *\t\tisBlockFiller( brFillerInstance, BR_FILLER ); // true\n *\n * @param {Node} domNode DOM node to check.\n * @param {Function} blockFiller Block filler creator.\n * @returns {Boolean} True if text node contains only {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\nexport function isBlockFiller( domNode, blockFiller ) {\n\tlet templateBlockFiller = templateBlockFillers.get( blockFiller );\n\n\tif ( !templateBlockFiller ) {\n\t\ttemplateBlockFiller = blockFiller( window.document );\n\t\ttemplateBlockFillers.set( blockFiller, templateBlockFiller );\n\t}\n\n\treturn domNode.isEqualNode( templateBlockFiller );\n}\n\n/**\n * Assign key observer which move cursor from the end of the inline filler to the beginning of it when\n * the left arrow is pressed, so the filler does not break navigation.\n *\n * @param {module:engine/view/view~View} view View controller instance we should inject quirks handling on.\n */\nexport function injectQuirksHandling( view ) {\n\tview.document.on( 'keydown', jumpOverInlineFiller );\n}\n\n// Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.\nfunction jumpOverInlineFiller( evt, data ) {\n\tif ( data.keyCode == keyCodes.arrowleft ) {\n\t\tconst domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\n\t\tif ( domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed ) {\n\t\t\tconst domParent = domSelection.getRangeAt( 0 ).startContainer;\n\t\t\tconst domOffset = domSelection.getRangeAt( 0 ).startOffset;\n\n\t\t\tif ( startsWithFiller( domParent ) && domOffset <= INLINE_FILLER_LENGTH ) {\n\t\t\t\tdomSelection.collapse( domParent, 0 );\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/diff\n */\n\n// The following code is based on the \"O(NP) Sequence Comparison Algorithm\"\n// by Sun Wu, Udi Manber, Gene Myers, Webb Miller.\n\n/**\n * Calculates the difference between two arrays or strings producing an array containing a list of changes\n * necessary to transform input into output.\n *\n *\t\tdiff( 'aba', 'acca' ); // [ 'equal', 'insert', 'insert', 'delete', 'equal' ]\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Output array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default === is used.\n * @returns {Array} Array of changes.\n */\nexport default function diff( a, b, cmp ) {\n\t// Set the comparator function.\n\tcmp = cmp || function( a, b ) {\n\t\treturn a === b;\n\t};\n\n\t// Temporary action type statics.\n\tlet _insert, _delete;\n\n\t// Swapped the arrays to use the shorter one as the first one.\n\tif ( b.length < a.length ) {\n\t\tconst tmp = a;\n\n\t\ta = b;\n\t\tb = tmp;\n\n\t\t// We swap the action types as well.\n\t\t_insert = 'delete';\n\t\t_delete = 'insert';\n\t} else {\n\t\t_insert = 'insert';\n\t\t_delete = 'delete';\n\t}\n\n\tconst m = a.length;\n\tconst n = b.length;\n\tconst delta = n - m;\n\n\t// Edit scripts, for each diagonal.\n\tconst es = {};\n\t// Furthest points, the furthest y we can get on each diagonal.\n\tconst fp = {};\n\n\tfunction snake( k ) {\n\t\t// We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).\n\t\t// Furthest points (y) on the diagonal below k.\n\t\tconst y1 = ( fp[ k - 1 ] !== undefined ? fp[ k - 1 ] : -1 ) + 1;\n\t\t// Furthest points (y) on the diagonal above k.\n\t\tconst y2 = fp[ k + 1 ] !== undefined ? fp[ k + 1 ] : -1;\n\t\t// The way we should go to get further.\n\t\tconst dir = y1 > y2 ? -1 : 1;\n\n\t\t// Clone previous changes array (if any).\n\t\tif ( es[ k + dir ] ) {\n\t\t\tes[ k ] = es[ k + dir ].slice( 0 );\n\t\t}\n\n\t\t// Create changes array.\n\t\tif ( !es[ k ] ) {\n\t\t\tes[ k ] = [];\n\t\t}\n\n\t\t// Push the action.\n\t\tes[ k ].push( y1 > y2 ? _insert : _delete );\n\n\t\t// Set the beginning coordinates.\n\t\tlet y = Math.max( y1, y2 );\n\t\tlet x = y - k;\n\n\t\t// Traverse the diagonal as long as the values match.\n\t\twhile ( x < m && y < n && cmp( a[ x ], b[ y ] ) ) {\n\t\t\tx++;\n\t\t\ty++;\n\t\t\t// Push no change action.\n\t\t\tes[ k ].push( 'equal' );\n\t\t}\n\n\t\treturn y;\n\t}\n\n\tlet p = 0;\n\tlet k;\n\n\t// Traverse the graph until we reach the end of the longer string.\n\tdo {\n\t\t// Updates furthest points and edit scripts for diagonals below delta.\n\t\tfor ( k = -p; k < delta; k++ ) {\n\t\t\tfp[ k ] = snake( k );\n\t\t}\n\n\t\t// Updates furthest points and edit scripts for diagonals above delta.\n\t\tfor ( k = delta + p; k > delta; k-- ) {\n\t\t\tfp[ k ] = snake( k );\n\t\t}\n\n\t\t// Updates furthest point and edit script for the delta diagonal.\n\t\t// note that the delta diagonal is the one which goes through the sink (m, n).\n\t\tfp[ delta ] = snake( delta );\n\n\t\tp++;\n\t} while ( fp[ delta ] !== n );\n\n\t// Return the final list of edit changes.\n\t// We remove the first item that represents the action for the injected nulls.\n\treturn es[ delta ].slice( 1 );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/insertat\n */\n\n/**\n * Inserts node to the parent at given index.\n *\n * @param {Element} parentElement Parent element.\n * @param {Number} index Insertions index.\n * @param {Node} nodeToInsert Node to insert.\n */\nexport default function insertAt( parentElement, index, nodeToInsert ) {\n\tparentElement.insertBefore( nodeToInsert, parentElement.childNodes[ index ] || null );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/remove\n */\n\n/**\n * Removes given node from parent.\n *\n * @param {Node} node Node to remove.\n */\nexport default function remove( node ) {\n\tconst parent = node.parentNode;\n\n\tif ( parent ) {\n\t\tparent.removeChild( node );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/istext\n */\n\n/**\n * Checks if the object is a native DOM Text node.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isText( obj ) {\n\treturn Object.prototype.toString.call( obj ) == '[object Text]';\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/isnode\n */\n\n/**\n * Checks if the object is a native DOM Node.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isNode( obj ) {\n\tif ( obj ) {\n\t\tif ( obj.defaultView ) {\n\t\t\treturn obj instanceof obj.defaultView.Document;\n\t\t} else if ( obj.ownerDocument && obj.ownerDocument.defaultView ) {\n\t\t\treturn obj instanceof obj.ownerDocument.defaultView.Node;\n\t\t}\n\t}\n\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/fastdiff\n */\n\n/**\n * Finds position of the first and last change in the given strings and generates set of changes. Set of changes\n * can be applied to the input text in order to transform it into the output text, for example:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]\n *\n *\t\tfastDiff( '12a', '12aa' );\n *\t\t// [ { index: 3, type: 'insert', values: [ 'a' ] } ]\n *\n *\t\tfastDiff( '12xyza', '12a' );\n *\t\t// [ { index: 2, type: 'delete', howMany: 3 } ]\n *\n *\t\tfastDiff( '12aa', '12a' );\n *\t\t// [ { index: 3, type: 'delete', howMany: 1 } ]\n *\n *\t\tfastDiff( '12abc3', '2ab' );\n *\t\t// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]\n *\n * Using returned results you can modify `oldText` to transform it into `newText`:\n *\n * \t\tlet input = '12abc3';\n * \t\tconst output = '2ab';\n * \t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\tinput === output; // -> true\n *\n * The output format of this function is compatible with {@link module:utils/difftochanges~diffToChanges} output format.\n *\n * @param {String} oldText Input string.\n * @param {String} newText Input string.\n * @returns {Array} Array of changes.\n */\nexport default function fastDiff( oldText, newText ) {\n\t// Check if both texts are equal.\n\tif ( oldText === newText ) {\n\t\treturn [];\n\t}\n\n\tconst changeIndexes = findChangeBoundaryIndexes( oldText, newText );\n\n\treturn changeIndexesToChanges( newText, changeIndexes );\n}\n\n// Finds position of the first and last change in the given strings. For example:\n//\n//\t\tconst indexes = findChangeBoundaryIndexes( '1234', '13424' );\n//\t\tconsole.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }\n//\n// The above indexes means that in `oldText` modified part is `1[23]4` and in the `newText` it is `1[342]4`.\n// Based on such indexes, array with `insert`/`delete` operations which allows transforming\n// old text to the new one can be generated.\n//\n// It is expected that `oldText` and `newText` are different.\n//\n// @param {String} oldText\n// @param {String} newText\n// @returns {Object}\n// @returns {Number} return.firstIndex Index of the first change in both strings (always the same for both).\n// @returns {Number} result.lastIndexOld Index of the last common character in `oldText` string.\n// @returns {Number} result.lastIndexNew Index of the last common character in `newText` string.\nfunction findChangeBoundaryIndexes( oldText, newText ) {\n\t// Find the first difference between texts.\n\tconst firstIndex = findFirstDifferenceIndex( oldText, newText );\n\n\t// Remove the common part of texts and reverse them to make it simpler to find the last difference between texts.\n\tconst oldTextReversed = cutAndReverse( oldText, firstIndex );\n\tconst newTextReversed = cutAndReverse( newText, firstIndex );\n\n\t// Find the first difference between reversed texts.\n\t// It should be treated as \"how many characters from the end the last difference occurred\".\n\t//\n\t// For example:\n\t//\n\t// \t\t\tinitial\t->\tafter cut\t-> reversed:\n\t// oldText:\t'321ba'\t->\t'21ba'\t\t-> 'ab12'\n\t// newText:\t'31xba'\t->\t'1xba'\t\t-> 'abx1'\n\t// lastIndex:\t\t\t\t\t\t->    2\n\t//\n\t// So the last change occurred two characters from the end of the texts.\n\tconst lastIndex = findFirstDifferenceIndex( oldTextReversed, newTextReversed );\n\n\t// Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).\n\tconst lastIndexOld = oldText.length - lastIndex;\n\tconst lastIndexNew = newText.length - lastIndex;\n\n\treturn { firstIndex, lastIndexOld, lastIndexNew };\n}\n\n// Returns a first index on which `oldText` and `newText` differ.\n//\n// @param {String} oldText\n// @param {String} newText\n// @returns {Number}\nfunction findFirstDifferenceIndex( oldText, newText ) {\n\tfor ( let i = 0; i < Math.max( oldText.length, newText.length ); i++ ) {\n\t\tif ( oldText[ i ] !== newText[ i ] ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\t// No \"backup\" return cause we assume that `oldText` and `newText` differ. This means that they either have a\n\t// difference or they have a different lengths. This means that the `if` condition will always be met eventually.\n}\n\n// Removes `howMany` characters from the given `text` string starting from the beginning, then reverses and returns it.\n//\n// @param {String} text Text to be processed.\n// @param {Number} howMany How many characters from text beginning to cut.\n// @returns {String} Shortened and reversed text.\nfunction cutAndReverse( text, howMany ) {\n\treturn text.substring( howMany ).split( '' ).reverse().join( '' );\n}\n\n// Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will\n// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).\n//\n// @param {String} newText New text for which change indexes were calculated.\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @returns {Array.<Object>} Array of changes compatible with {@link module:utils/difftochanges~diffToChanges} format.\nfunction changeIndexesToChanges( newText, changeIndexes ) {\n\tconst result = [];\n\tconst { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;\n\n\t// Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}\n\t// in most cases. However, 'diffToChanges' does not stick to any order so in some cases\n\t// (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.\n\tif ( lastIndexNew - firstIndex > 0 ) {\n\t\tresult.push( {\n\t\t\tindex: firstIndex,\n\t\t\ttype: 'insert',\n\t\t\tvalues: newText.substring( firstIndex, lastIndexNew ).split( '' )\n\t\t} );\n\t}\n\n\tif ( lastIndexOld - firstIndex > 0 ) {\n\t\tresult.push( {\n\t\t\tindex: firstIndex + ( lastIndexNew - firstIndex ), // Increase index of what was inserted.\n\t\t\ttype: 'delete',\n\t\t\thowMany: lastIndexOld - firstIndex\n\t\t} );\n\t}\n\n\treturn result;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/renderer\n */\n\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller, isBlockFiller } from './filler';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\n\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer {\n\t/**\n\t * Creates a renderer instance.\n\t *\n\t * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n\t * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n\t */\n\tconstructor( domConverter, selection ) {\n\t\t/**\n\t\t * Set of DOM Documents instances.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<Document>}\n\t\t */\n\t\tthis.domDocuments = new Set();\n\n\t\t/**\n\t\t * Converter instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = domConverter;\n\n\t\t/**\n\t\t * Set of nodes which attributes changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedAttributes = new Set();\n\n\t\t/**\n\t\t * Set of elements which child lists changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedChildren = new Set();\n\n\t\t/**\n\t\t * Set of text nodes which text data changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedTexts = new Set();\n\n\t\t/**\n\t\t * View selection. Renderer updates DOM selection based on the view selection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = selection;\n\n\t\t/**\n\t\t * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n\t\t * this is set to `false`.\n\t\t *\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.isFocused = false;\n\n\t\t/**\n\t\t * The text node in which the inline filler was rendered.\n\t\t *\n\t\t * @private\n\t\t * @member {Text}\n\t\t */\n\t\tthis._inlineFiller = null;\n\n\t\t/**\n\t\t * DOM element containing fake selection.\n\t\t *\n\t\t * @private\n\t\t * @type {null|HTMLElement}\n\t\t */\n\t\tthis._fakeSelectionContainer = null;\n\t}\n\n\t/**\n\t * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n\t *\n\t * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n\t *\n\t * @see #markedAttributes\n\t * @see #markedChildren\n\t * @see #markedTexts\n\t *\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Node to be marked.\n\t */\n\tmarkToSync( type, node ) {\n\t\tif ( type === 'text' ) {\n\t\t\tif ( this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis.markedTexts.add( node );\n\t\t\t}\n\t\t} else {\n\t\t\t// If the node has no DOM element it is not rendered yet,\n\t\t\t// its children/attributes do not need to be marked to be sync.\n\t\t\tif ( !this.domConverter.mapViewToDom( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type === 'attributes' ) {\n\t\t\t\tthis.markedAttributes.add( node );\n\t\t\t} else if ( type === 'children' ) {\n\t\t\t\tthis.markedChildren.add( node );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Unknown type passed to Renderer.markToSync.\n\t\t\t\t *\n\t\t\t\t * @error renderer-unknown-type\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.' );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n\t * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n\t *\n\t * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n\t * so it does as little as it is needed to update the DOM.\n\t *\n\t * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n\t * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n\t * removed as long as the selection is in the text node which needed it at first.\n\t */\n\trender() {\n\t\tlet inlineFillerPosition;\n\n\t\t// Refresh mappings.\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildrenMappings( element );\n\t\t}\n\n\t\t// There was inline filler rendered in the DOM but it's not\n\t\t// at the selection position any more, so we can remove it\n\t\t// (cause even if it's needed, it must be placed in another location).\n\t\tif ( this._inlineFiller && !this._isSelectionInInlineFiller() ) {\n\t\t\tthis._removeInlineFiller();\n\t\t}\n\n\t\t// If we've got the filler, let's try to guess its position in the view.\n\t\tif ( this._inlineFiller ) {\n\t\t\tinlineFillerPosition = this._getInlineFillerPosition();\n\t\t}\n\t\t// Otherwise, if it's needed, create it at the selection position.\n\t\telse if ( this._needsInlineFillerAtSelection() ) {\n\t\t\tinlineFillerPosition = this.selection.getFirstPosition();\n\n\t\t\t// Do not use `markToSync` so it will be added even if the parent is already added.\n\t\t\tthis.markedChildren.add( inlineFillerPosition.parent );\n\t\t}\n\n\t\tfor ( const element of this.markedAttributes ) {\n\t\t\tthis._updateAttrs( element );\n\t\t}\n\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildren( element, { inlineFillerPosition } );\n\t\t}\n\n\t\tfor ( const node of this.markedTexts ) {\n\t\t\tif ( !this.markedChildren.has( node.parent ) && this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis._updateText( node, { inlineFillerPosition } );\n\t\t\t}\n\t\t}\n\n\t\t// Check whether the inline filler is required and where it really is in the DOM.\n\t\t// At this point in most cases it will be in the DOM, but there are exceptions.\n\t\t// For example, if the inline filler was deep in the created DOM structure, it will not be created.\n\t\t// Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n\t\t// it will not be present.\n\t\t// Fix those and similar scenarios.\n\t\tif ( inlineFillerPosition ) {\n\t\t\tconst fillerDomPosition = this.domConverter.viewPositionToDom( inlineFillerPosition );\n\t\t\tconst domDocument = fillerDomPosition.parent.ownerDocument;\n\n\t\t\tif ( !startsWithFiller( fillerDomPosition.parent ) ) {\n\t\t\t\t// Filler has not been created at filler position. Create it now.\n\t\t\t\tthis._inlineFiller = addInlineFiller( domDocument, fillerDomPosition.parent, fillerDomPosition.offset );\n\t\t\t} else {\n\t\t\t\t// Filler has been found, save it.\n\t\t\t\tthis._inlineFiller = fillerDomPosition.parent;\n\t\t\t}\n\t\t} else {\n\t\t\t// There is no filler needed.\n\t\t\tthis._inlineFiller = null;\n\t\t}\n\n\t\tthis._updateSelection();\n\t\tthis._updateFocus();\n\n\t\tthis.markedTexts.clear();\n\t\tthis.markedAttributes.clear();\n\t\tthis.markedChildren.clear();\n\t}\n\n\t/**\n\t * Updates mappings of view element's children.\n\t *\n\t * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n\t * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n\t * Thanks to that these elements do not need to be re-rendered completely.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n\t */\n\t_updateChildrenMappings( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n\t\t\treturn;\n\t\t}\n\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { withChildren: false } )\n\t\t);\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\t\tconst actions = this._findReplaceActions( diff, actualDomChildren, expectedDomChildren );\n\n\t\tif ( actions.indexOf( 'replace' ) !== -1 ) {\n\t\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'replace' ) {\n\t\t\t\t\tconst insertIndex = counter.equal + counter.insert;\n\t\t\t\t\tconst deleteIndex = counter.equal + counter.delete;\n\t\t\t\t\tconst viewChild = viewElement.getChild( insertIndex );\n\n\t\t\t\t\t// The 'uiElement' is a special one and its children are not stored in a view (#799),\n\t\t\t\t\t// so we cannot use it with replacing flow (since it uses view children during rendering\n\t\t\t\t\t// which will always result in rendering empty element).\n\t\t\t\t\tif ( viewChild && !viewChild.is( 'uiElement' ) ) {\n\t\t\t\t\t\tthis._updateElementMappings( viewChild, actualDomChildren[ deleteIndex ] );\n\t\t\t\t\t}\n\n\t\t\t\t\tremove( expectedDomChildren[ insertIndex ] );\n\t\t\t\t\tcounter.equal++;\n\t\t\t\t} else {\n\t\t\t\t\tcounter[ action ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates mappings of a given view element.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n\t * @param {Node} domElement The DOM element representing the given view element.\n\t */\n\t_updateElementMappings( viewElement, domElement ) {\n\t\t// Because we replace new view element mapping with the existing one, the corresponding DOM element\n\t\t// will not be rerendered. The new view element may have different attributes than the previous one.\n\t\t// Since its corresponding DOM element will not be rerendered, new attributes will not be added\n\t\t// to the DOM, so we need to mark it here to make sure its attributes gets updated.\n\t\t// Such situations may happen if only new view element was added to `this.markedAttributes`\n\t\t// or none of the elements were added (relying on 'this._updateChildren()' which by rerendering the element\n\t\t// also rerenders its attributes). See #1427 for more detailed case study.\n\t\tconst newViewChild = this.domConverter.mapDomToView( domElement );\n\n\t\t// It may also happen that 'newViewChild' mapping is not present since its parent mapping\n\t\t// was already removed (the 'domConverter.unbindDomElement()' method also unbinds children\n\t\t// mappings) so we also check for '!newViewChild'.\n\t\tif ( !newViewChild || newViewChild && !newViewChild.isSimilar( viewElement ) ) {\n\t\t\tthis.markedAttributes.add( viewElement );\n\t\t}\n\n\t\t// Remap 'DomConverter' bindings.\n\t\tthis.domConverter.unbindDomElement( domElement );\n\t\tthis.domConverter.bindElements( domElement, viewElement );\n\n\t\t// View element may have children which needs to be updated, but are not marked, mark them to update.\n\t\tthis.markedChildren.add( viewElement );\n\t}\n\n\t/**\n\t * Gets the position of the inline filler based on the current selection.\n\t * Here, we assume that we know that the filler is needed and\n\t * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n\t * it is somewhere at the selection position.\n\t *\n\t * Note: The filler position cannot be restored based on the filler's DOM text node, because\n\t * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n\t * bindings are only dependable after rendering.\n\t *\n\t * @private\n\t * @returns {module:engine/view/position~Position}\n\t */\n\t_getInlineFillerPosition() {\n\t\tconst firstPos = this.selection.getFirstPosition();\n\n\t\tif ( firstPos.parent.is( 'text' ) ) {\n\t\t\treturn ViewPosition.createBefore( this.selection.getFirstPosition().parent );\n\t\t} else {\n\t\t\treturn firstPos;\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` if the selection has not left the inline filler's text node.\n\t * If it is `true`, it means that the filler had been added for a reason and the selection did not\n\t * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n\t */\n\t_isSelectionInInlineFiller() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note, we can't check if selection's position equals position of the\n\t\t// this._inlineFiller node, because of #663. We may not be able to calculate\n\t\t// the filler's position in the view at this stage.\n\t\t// Instead, we check it the other way – whether selection is anchored in\n\t\t// that text node or next to it.\n\n\t\t// Possible options are:\n\t\t// \"FILLER{}\"\n\t\t// \"FILLERadded-text{}\"\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst position = this.domConverter.viewPositionToDom( selectionPosition );\n\n\t\tif ( position && isText( position.parent ) && startsWithFiller( position.parent ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Removes the inline filler.\n\t *\n\t * @private\n\t */\n\t_removeInlineFiller() {\n\t\tconst domFillerNode = this._inlineFiller;\n\n\t\t// Something weird happened and the stored node doesn't contain the filler's text.\n\t\tif ( !startsWithFiller( domFillerNode ) ) {\n\t\t\t/**\n\t\t\t * The inline filler node was lost. Most likely, something overwrote the filler text node\n\t\t\t * in the DOM.\n\t\t\t *\n\t\t\t * @error view-renderer-filler-was-lost\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-renderer-filler-was-lost: The inline filler node was lost.' );\n\t\t}\n\n\t\tif ( isInlineFiller( domFillerNode ) ) {\n\t\t\tdomFillerNode.parentNode.removeChild( domFillerNode );\n\t\t} else {\n\t\t\tdomFillerNode.data = domFillerNode.data.substr( INLINE_FILLER_LENGTH );\n\t\t}\n\n\t\tthis._inlineFiller = null;\n\t}\n\n\t/**\n\t * Checks if the inline {@link module:engine/view/filler filler} should be added.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler should be added.\n\t */\n\t_needsInlineFillerAtSelection() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst selectionParent = selectionPosition.parent;\n\t\tconst selectionOffset = selectionPosition.offset;\n\n\t\t// If there is no DOM root we do not care about fillers.\n\t\tif ( !this.domConverter.mapViewToDom( selectionParent.root ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !( selectionParent.is( 'element' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Prevent adding inline filler inside elements with contenteditable=false.\n\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\t\tif ( !isEditable( selectionParent ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have block filler, we do not need inline one.\n\t\tif ( selectionOffset === selectionParent.getFillerOffset() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst nodeBefore = selectionPosition.nodeBefore;\n\t\tconst nodeAfter = selectionPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText || nodeAfter instanceof ViewText ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if text needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} viewText View text to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateText( viewText, options ) {\n\t\tconst domText = this.domConverter.findCorrespondingDomText( viewText );\n\t\tconst newDomText = this.domConverter.viewToDom( viewText, domText.ownerDocument );\n\n\t\tconst actualText = domText.data;\n\t\tlet expectedText = newDomText.data;\n\n\t\tconst filler = options.inlineFillerPosition;\n\n\t\tif ( filler && filler.parent == viewText.parent && filler.offset == viewText.index ) {\n\t\t\texpectedText = INLINE_FILLER + expectedText;\n\t\t}\n\n\t\tif ( actualText != expectedText ) {\n\t\t\tconst actions = fastDiff( actualText, expectedText );\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action.type === 'insert' ) {\n\t\t\t\t\tdomText.insertData( action.index, action.values.join( '' ) );\n\t\t\t\t} else { // 'delete'\n\t\t\t\t\tdomText.deleteData( action.index, action.howMany );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if attribute list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement The view element to update.\n\t */\n\t_updateAttrs( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n\t\t\t// in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n\t\t\t// replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n\t\t\t// in 'this._updateChildrenMappings()' so it will be processed separately.\n\t\t\treturn;\n\t\t}\n\n\t\tconst domAttrKeys = Array.from( domElement.attributes ).map( attr => attr.name );\n\t\tconst viewAttrKeys = viewElement.getAttributeKeys();\n\n\t\t// Add or overwrite attributes.\n\t\tfor ( const key of viewAttrKeys ) {\n\t\t\tdomElement.setAttribute( key, viewElement.getAttribute( key ) );\n\t\t}\n\n\t\t// Remove from DOM attributes which do not exists in the view.\n\t\tfor ( const key of domAttrKeys ) {\n\t\t\tif ( !viewElement.hasAttribute( key ) ) {\n\t\t\t\tdomElement.removeAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if elements child list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement View element to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateChildren( viewElement, options ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM.\n\t\t\t// There is no need to process it. It will be processed when re-inserted.\n\t\t\treturn;\n\t\t}\n\n\t\tconst inlineFillerPosition = options.inlineFillerPosition;\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { bind: true, inlineFillerPosition } )\n\t\t);\n\n\t\t// Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n\t\t// during diffing so text nodes could be compared correctly and also during rendering to maintain\n\t\t// proper order and indexes while updating the DOM.\n\t\tif ( inlineFillerPosition && inlineFillerPosition.parent === viewElement ) {\n\t\t\taddInlineFiller( domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset );\n\t\t}\n\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\n\t\tlet i = 0;\n\t\tconst nodesToUnbind = new Set();\n\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\tinsertAt( domElement, i, expectedDomChildren[ i ] );\n\t\t\t\ti++;\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tnodesToUnbind.add( actualDomChildren[ i ] );\n\t\t\t\tremove( actualDomChildren[ i ] );\n\t\t\t} else { // 'equal'\n\t\t\t\t// Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n\t\t\t\tthis._markDescendantTextToSync( this.domConverter.domToView( expectedDomChildren[ i ] ) );\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n\t\t// comparision with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n\t\t// it was moved to DOM tree out of the removed node.\n\t\tfor ( const node of nodesToUnbind ) {\n\t\t\tif ( !node.parentNode ) {\n\t\t\t\tthis.domConverter.unbindDomElement( node );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Shorthand for diffing two arrays or node lists of DOM nodes.\n\t *\n\t * @private\n\t * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n\t * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n\t * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n\t */\n\t_diffNodeLists( actualDomChildren, expectedDomChildren ) {\n\t\treturn diff( actualDomChildren, expectedDomChildren, sameNodes.bind( null, this.domConverter.blockFiller ) );\n\t}\n\n\t/**\n\t * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n\t * within one `insert`/`delete` action group, for example:\n\t *\n\t * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n\t * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n\t * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n\t * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n\t *\n\t * @private\n\t * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n\t * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n\t * @param {Array.<Node>} expectedDom Expected DOM children.\n\t * @returns {Array.<String>} Actions array modified with the `replace` actions.\n\t */\n\t_findReplaceActions( actions, actualDom, expectedDom ) {\n\t\t// If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n\t\tif ( actions.indexOf( 'insert' ) === -1 || actions.indexOf( 'delete' ) === -1 ) {\n\t\t\treturn actions;\n\t\t}\n\n\t\tlet newActions = [];\n\t\tlet actualSlice = [];\n\t\tlet expectedSlice = [];\n\n\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\tfor ( const action of actions ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\texpectedSlice.push( expectedDom[ counter.equal + counter.insert ] );\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tactualSlice.push( actualDom[ counter.equal + counter.delete ] );\n\t\t\t} else { // equal\n\t\t\t\tnewActions = newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t\t\t\tnewActions.push( 'equal' );\n\t\t\t\t// Reset stored elements on 'equal'.\n\t\t\t\tactualSlice = [];\n\t\t\t\texpectedSlice = [];\n\t\t\t}\n\t\t\tcounter[ action ]++;\n\t\t}\n\n\t\treturn newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t}\n\n\t/**\n\t * Marks text nodes to be synchronized.\n\t *\n\t * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewNode View node to sync.\n\t */\n\t_markDescendantTextToSync( viewNode ) {\n\t\tif ( !viewNode ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tthis.markedTexts.add( viewNode );\n\t\t} else if ( viewNode.is( 'element' ) ) {\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tthis._markDescendantTextToSync( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the selection needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateSelection() {\n\t\t// If there is no selection - remove DOM and fake selections.\n\t\tif ( this.selection.rangeCount === 0 ) {\n\t\t\tthis._removeDomSelection();\n\t\t\tthis._removeFakeSelection();\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst domRoot = this.domConverter.mapViewToDom( this.selection.editableElement );\n\n\t\t// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\t\tif ( !this.isFocused || !domRoot ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Render selection.\n\t\tif ( this.selection.isFake ) {\n\t\t\tthis._updateFakeSelection( domRoot );\n\t\t} else {\n\t\t\tthis._removeFakeSelection();\n\t\t\tthis._updateDomSelection( domRoot );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the fake selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n\t */\n\t_updateFakeSelection( domRoot ) {\n\t\tconst domDocument = domRoot.ownerDocument;\n\t\tlet container = this._fakeSelectionContainer;\n\n\t\t// Create fake selection container if one does not exist.\n\t\tif ( !container ) {\n\t\t\tthis._fakeSelectionContainer = container = domDocument.createElement( 'div' );\n\n\t\t\tObject.assign( container.style, {\n\t\t\t\tposition: 'fixed',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: '-9999px',\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/752.\n\t\t\t\twidth: '42px'\n\t\t\t} );\n\n\t\t\t// Fill it with a text node so we can update it later.\n\t\t\tcontainer.appendChild( domDocument.createTextNode( '\\u00A0' ) );\n\t\t}\n\n\t\t// Add fake container if not already added.\n\t\tif ( !container.parentElement ) {\n\t\t\tdomRoot.appendChild( container );\n\t\t}\n\n\t\t// Update contents.\n\t\tcontainer.firstChild.data = this.selection.fakeSelectionLabel || '\\u00A0';\n\n\t\t// Update selection.\n\t\tconst domSelection = domDocument.getSelection();\n\t\tconst domRange = domDocument.createRange();\n\n\t\tdomSelection.removeAllRanges();\n\t\tdomRange.selectNodeContents( container );\n\t\tdomSelection.addRange( domRange );\n\n\t\t// Bind fake selection container with current selection.\n\t\tthis.domConverter.bindFakeSelection( container, this.selection );\n\t}\n\n\t/**\n\t * Updates the DOM selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n\t */\n\t_updateDomSelection( domRoot ) {\n\t\tconst domSelection = domRoot.ownerDocument.defaultView.getSelection();\n\n\t\t// Let's check whether DOM selection needs updating at all.\n\t\tif ( !this._domSelectionNeedsUpdate( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n\t\t// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n\t\t// and focus of view selection.\n\t\t// Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n\t\t// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\t\tconst anchor = this.domConverter.viewPositionToDom( this.selection.anchor );\n\t\tconst focus = this.domConverter.viewPositionToDom( this.selection.focus );\n\n\t\t// Focus the new editing host.\n\t\t// Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\t\tdomRoot.focus();\n\n\t\tdomSelection.collapse( anchor.parent, anchor.offset );\n\t\tdomSelection.extend( focus.parent, focus.offset );\n\t}\n\n\t/**\n\t * Checks whether a given DOM selection needs to be updated.\n\t *\n\t * @private\n\t * @param {Selection} domSelection The DOM selection to check.\n\t * @returns {Boolean}\n\t */\n\t_domSelectionNeedsUpdate( domSelection ) {\n\t\tif ( !this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\t// Current DOM selection is in incorrect position. We need to update it.\n\t\t\treturn true;\n\t\t}\n\n\t\tconst oldViewSelection = domSelection && this.domConverter.domSelectionToView( domSelection );\n\n\t\tif ( oldViewSelection && this.selection.isEqual( oldViewSelection ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If selection is not collapsed, it does not need to be updated if it is similar.\n\t\tif ( !this.selection.isCollapsed && this.selection.isSimilar( oldViewSelection ) ) {\n\t\t\t// Selection did not changed and is correct, do not update.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Selections are not similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Removes the DOM selection.\n\t *\n\t * @private\n\t */\n\t_removeDomSelection() {\n\t\tfor ( const doc of this.domDocuments ) {\n\t\t\tconst domSelection = doc.getSelection();\n\n\t\t\tif ( domSelection.rangeCount ) {\n\t\t\t\tconst activeDomElement = doc.activeElement;\n\t\t\t\tconst viewElement = this.domConverter.mapDomToView( activeDomElement );\n\n\t\t\t\tif ( activeDomElement && viewElement ) {\n\t\t\t\t\tdoc.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the fake selection.\n\t *\n\t * @private\n\t */\n\t_removeFakeSelection() {\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\tif ( container ) {\n\t\t\tcontainer.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if focus needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateFocus() {\n\t\tif ( this.isFocused ) {\n\t\t\tconst editable = this.selection.editableElement;\n\n\t\t\tif ( editable ) {\n\t\t\t\tthis.domConverter.focus( editable );\n\t\t\t}\n\t\t}\n\t}\n}\n\nmix( Renderer, ObservableMixin );\n\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable( element ) {\n\tif ( element.getAttribute( 'contenteditable' ) == 'false' ) {\n\t\treturn false;\n\t}\n\n\tconst parent = element.findAncestor( element => element.hasAttribute( 'contenteditable' ) );\n\n\treturn !parent || parent.getAttribute( 'contenteditable' ) == 'true';\n}\n\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller( domDocument, domParentOrArray, offset ) {\n\tconst childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n\tconst nodeAfterFiller = childNodes[ offset ];\n\n\tif ( isText( nodeAfterFiller ) ) {\n\t\tnodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n\n\t\treturn nodeAfterFiller;\n\t} else {\n\t\tconst fillerNode = domDocument.createTextNode( INLINE_FILLER );\n\n\t\tif ( Array.isArray( domParentOrArray ) ) {\n\t\t\tchildNodes.splice( offset, 0, fillerNode );\n\t\t} else {\n\t\t\tinsertAt( domParentOrArray, offset, fillerNode );\n\t\t}\n\n\t\treturn fillerNode;\n\t}\n}\n\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction areSimilar( node1, node2 ) {\n\treturn isNode( node1 ) && isNode( node2 ) &&\n\t\t!isText( node1 ) && !isText( node2 ) &&\n\t\tnode1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {Function} blockFiller Block filler creator function, see {@link module:engine/view/domconverter~DomConverter#blockFiller}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction sameNodes( blockFiller, actualDomChild, expectedDomChild ) {\n\t// Elements.\n\tif ( actualDomChild === expectedDomChild ) {\n\t\treturn true;\n\t}\n\t// Texts.\n\telse if ( isText( actualDomChild ) && isText( expectedDomChild ) ) {\n\t\treturn actualDomChild.data === expectedDomChild.data;\n\t}\n\t// Block fillers.\n\telse if ( isBlockFiller( actualDomChild, blockFiller ) &&\n\t\tisBlockFiller( expectedDomChild, blockFiller ) ) {\n\t\treturn true;\n\t}\n\n\t// Not matching types.\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window, document */\n\n/**\n * @module utils/dom/global\n */\n\n/**\n * A helper (module) giving an access to the global DOM objects such as `window` and\n * `document`. Accessing these objects using this helper allows easy and bulletproof\n * testing, i.e. stubbing native properties:\n *\n *\t\timport global from 'ckeditor5/utils/dom/global.js';\n *\n *\t\t// This stub will work for any code using global module.\n *\t\ttestUtils.sinon.stub( global, 'window', {\n *\t\t\tinnerWidth: 10000\n *\t\t} );\n *\n *\t\tconsole.log( global.window.innerWidth );\n */\nexport default { window, document };\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/indexof\n */\n\n/**\n * Returns index of the node in the parent element.\n *\n * @param {Node} node Node which index is tested.\n * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.\n */\nexport default function indexOf( node ) {\n\tlet index = 0;\n\n\twhile ( node.previousSibling ) {\n\t\tnode = node.previousSibling;\n\t\tindex++;\n\t}\n\n\treturn index;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals Node */\n\n/**\n * @module utils/dom/getancestors\n */\n\n/**\n * Returns all ancestors of given DOM node, starting from the top-most (root). Includes the given node itself. If the\n * node is a part of `DocumentFragment` that `DocumentFragment` will be returned. In contrary, if the node is\n * appended to a `Document`, that `Document` will not be returned (algorithms operating on DOM tree care for `Document#documentElement`\n * at most, which will be returned).\n *\n * @param {Node} node DOM node.\n * @returns {Array.<Node|DocumentFragment>} Array of given `node` parents.\n */\nexport default function getAncestors( node ) {\n\tconst nodes = [];\n\n\t// We are interested in `Node`s `DocumentFragment`s only.\n\twhile ( node && node.nodeType != Node.DOCUMENT_NODE ) {\n\t\tnodes.unshift( node );\n\t\tnode = node.parentNode;\n\t}\n\n\treturn nodes;\n}\n","import isObjectLike from './isObjectLike';\nimport isPlainObject from './isPlainObject';\n\n/**\n * Checks if `value` is likely a DOM element.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a DOM element,\n *  else `false`.\n * @example\n *\n * _.isElement(document.body);\n * // => true\n *\n * _.isElement('<body>');\n * // => false\n */\nfunction isElement(value) {\n  return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n}\n\nexport default isElement;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, isBlockFiller, isInlineFiller, startsWithFiller, getDataWithoutFiller } from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isElement from '@ckeditor/ckeditor5-utils/src/lib/lodash/isElement';\n\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates DOM converter.\n\t *\n\t * @param {Object} options Object with configuration options.\n\t * @param {Function} [options.blockFiller=module:engine/view/filler~BR_FILLER] Block filler creator.\n\t */\n\tconstructor( options = {} ) {\n\t\t// Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM\n\t\t// will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced\n\t\t// will be also removed, isn't it brilliant?\n\t\t//\n\t\t// Yes, PJ. It is.\n\t\t//\n\t\t// You guys so smart.\n\t\t//\n\t\t// I've been here. Seen stuff. Afraid of code now.\n\n\t\t/**\n\t\t * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n\t\t * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Function} module:engine/view/domconverter~DomConverter#blockFiller\n\t\t */\n\t\tthis.blockFiller = options.blockFiller || BR_FILLER;\n\n\t\t/**\n\t\t * Tag names of DOM `Element`s which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Tag names of DOM `Element`s which are considered block elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ];\n\n\t\t/**\n\t\t * DOM to View mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View to DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\t}\n\n\t/**\n\t * Binds given DOM element that represents fake selection to {@link module:engine/view/documentselection~DocumentSelection\n\t * document selection}. Document selection copy is stored and can be retrieved by\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n\t * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and View elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement View element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * `domElement` will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\t// Use Array.from because of MS Edge (#923).\n\t\t\tfor ( const child of Array.from( domElement.childNodes ) ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this.blockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this.blockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( 'text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( isBlockFiller( domNode, this.blockFiller ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside UIElement return that UIElement as it's view representation.\n\t\tconst uiElement = this.getParentUIElement( domNode, this._domToViewMapping );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( isBlockFiller( domParent, this.blockFiller ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && viewElement.is( 'uiElement' ) ) {\n\t\t\treturn ViewPosition.createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\treturn this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by UIElement - return that element.\n\t\tconst uiElement = this.getParentUIElement( domText );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n\t * parent UIElement.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|null}\n\t */\n\tgetParentUIElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && viewNode.is( 'uiElement' ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t * * before or in the middle of the inline filler sequence,\n\t * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n\t *\n\t * @param {Selection} domSelection DOM Selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n\t\t// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\t\tif ( viewParent && viewParent.is( 'uiElement' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if this is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with a nbsp if this is the last text node (container element boundary).\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( !nextNode ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed, if it is the last text node in its container.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\n\t\t// Now we have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view as\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them\n\t\t// to `  ` which is what we expect to have in model/view.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// As above, that &nbsp; was created for rendering reasons but it's real meaning is just a space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// Since input text data could be: `x_ _`, we would not replace the first &nbsp; after `x` character.\n\t\t// We have to fix it. Since we already change all ` &nbsp;`, we will have something like this at the end of text data:\n\t\t// `x_ _ _` -> `x_    `. Find &nbsp; at the end of string (can be followed only by spaces).\n\t\t// We do that replacement only if this is the last node or the next node starts with &nbsp; or is a <br>.\n\t\tif ( isText( nextNode ) ? nextNode.data.charAt( 0 ) == '\\u00A0' : true ) {\n\t\t\tdata = data.replace( /\\u00A0( *)$/, ' $1' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @param {Node} node\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition.createAfter( node ) : ViewPosition.createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( 'textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/getcommonancestor\n */\n\nimport getAncestors from './getancestors';\n\n/**\n * Searches and returns the lowest common ancestor of two given nodes.\n *\n * @param {Node} nodeA First node.\n * @param {Node} nodeB Second node.\n * @returns {Node|DocumentFragment|Document|null} Lowest common ancestor of both nodes or `null` if nodes do not have a common ancestor.\n */\nexport default function getCommonAncestor( nodeA, nodeB ) {\n\tconst ancestorsA = getAncestors( nodeA );\n\tconst ancestorsB = getAncestors( nodeB );\n\n\tlet i = 0;\n\n\t// It does not matter which array is shorter.\n\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\ti++;\n\t}\n\n\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/iswindow\n */\n\n/**\n * Checks if the object is a native DOM Window.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isWindow( obj ) {\n\tconst stringifiedObject = Object.prototype.toString.apply( obj );\n\n\t// Returns `true` for the `window` object in browser environments.\n\tif ( stringifiedObject == '[object Window]' ) {\n\t\treturn true;\n\t}\n\n\t// Returns `true` for the `window` object in the Electron environment.\n\tif ( stringifiedObject == '[object global]' ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/emittermixin\n */\n\nimport { default as EmitterMixin, _getEmitterListenedTo, _setEmitterId } from '../emittermixin';\nimport uid from '../uid';\nimport extend from '../lib/lodash/extend';\nimport isNode from './isnode';\nimport isWindow from './iswindow';\n\n/**\n * Mixin that injects the DOM events API into its host. It provides the API\n * compatible with {@link module:utils/emittermixin~EmitterMixin}.\n *\n * DOM emitter mixin is by default available in the {@link module:ui/view~View} class,\n * but it can also be mixed into any other class:\n *\n *\t\timport mix from '../utils/mix.js';\n *\t\timport DomEmitterMixin from '../utils/dom/emittermixin.js';\n *\n *\t\tclass SomeView {}\n *\t\tmix( SomeView, DomEmitterMixin );\n *\n *\t\tconst view = new SomeView();\n *\t\tview.listenTo( domElement, ( evt, domEvt ) => {\n *\t\t\tconsole.log( evt, domEvt );\n *\t\t} );\n *\n * @mixin EmitterMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n */\nconst DomEmitterMixin = extend( {}, EmitterMixin, {\n\t/**\n\t * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.\n\t * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n\t *\n\t * @param {module:utils/emittermixin~Emitter|Node} emitter The object that fires the event.\n\t * @param {String} event The name of the event.\n\t * @param {Function} callback The function to be called on event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n\t * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n\t * order they were added.\n\t * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n\t * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n\t */\n\tlistenTo( emitter, ...rest ) {\n\t\t// Check if emitter is an instance of DOM Node. If so, replace the argument with\n\t\t// corresponding ProxyEmitter (or create one if not existing).\n\t\tif ( isNode( emitter ) || isWindow( emitter ) ) {\n\t\t\tconst proxy = this._getProxyEmitter( emitter ) || new ProxyEmitter( emitter );\n\n\t\t\tproxy.attach( ...rest );\n\n\t\t\temitter = proxy;\n\t\t}\n\n\t\t// Execute parent class method with Emitter (or ProxyEmitter) instance.\n\t\tEmitterMixin.listenTo.call( this, emitter, ...rest );\n\t},\n\n\t/**\n\t * Stops listening for events. It can be used at different levels:\n\t * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n\t *\n\t * * To stop listening to a specific callback.\n\t * * To stop listening to a specific event.\n\t * * To stop listening to all events fired by a specific object.\n\t * * To stop listening to all events fired by all object.\n\t *\n\t * @param {module:utils/emittermixin~Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n\t * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n\t * for all events from `emitter`.\n\t * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n\t * `event`.\n\t */\n\tstopListening( emitter, event, callback ) {\n\t\t// Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.\n\t\tif ( isNode( emitter ) || isWindow( emitter ) ) {\n\t\t\tconst proxy = this._getProxyEmitter( emitter );\n\n\t\t\t// Element has no listeners.\n\t\t\tif ( !proxy ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\temitter = proxy;\n\t\t}\n\n\t\t// Execute parent class method with Emitter (or ProxyEmitter) instance.\n\t\tEmitterMixin.stopListening.call( this, emitter, event, callback );\n\n\t\tif ( emitter instanceof ProxyEmitter ) {\n\t\t\temitter.detach( event );\n\t\t}\n\t},\n\n\t/**\n\t * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.\n\t *\n\t * @pivate\n\t * @param {Node} node DOM Node of the ProxyEmitter.\n\t * @returns {module:utils/dom/emittermixin~ProxyEmitter} ProxyEmitter instance or null.\n\t */\n\t_getProxyEmitter( node ) {\n\t\treturn _getEmitterListenedTo( this, getNodeUID( node ) );\n\t}\n} );\n\nexport default DomEmitterMixin;\n\n/**\n * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events\n * and any Host listening to them. It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#on}.\n *\n *                                  listenTo( click, ... )\n *                    +-----------------------------------------+\n *                    |              stopListening( ... )       |\n *     +----------------------------+                           |             addEventListener( click, ... )\n *     | Host                       |                           |   +---------------------------------------------+\n *     +----------------------------+                           |   |       removeEventListener( click, ... )     |\n *     | _listeningTo: {            |                +----------v-------------+                                   |\n *     |   UID: {                   |                | ProxyEmitter           |                                   |\n *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+\n *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |\n *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+\n *     |     }                      |                | },                     |                      | data-ck-expando: UID  |\n *     |   }                        |                | _domNode: Node,        |                      +-----------------------+\n *     | }                          |                | _domListeners: {},     |                                   |\n *     | +------------------------+ |                | _emitterId: UID        |                                   |\n *     | | DomEmitterMixin        | |                +--------------^---------+                                   |\n *     | +------------------------+ |                           |   |                                             |\n *     +--------------^-------------+                           |   +---------------------------------------------+\n *                    |                                         |                  click (DOM Event)\n *                    +-----------------------------------------+\n *                                fire( click, DOM Event )\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n * @private\n */\nclass ProxyEmitter {\n\t/**\n\t * @param {Node} node DOM Node that fires events.\n\t * @returns {Object} ProxyEmitter instance bound to the DOM Node.\n\t */\n\tconstructor( node ) {\n\t\t// Set emitter ID to match DOM Node \"expando\" property.\n\t\t_setEmitterId( this, getNodeUID( node ) );\n\n\t\t// Remember the DOM Node this ProxyEmitter is bound to.\n\t\tthis._domNode = node;\n\t}\n}\n\nextend( ProxyEmitter.prototype, EmitterMixin, {\n\t/**\n\t * Collection of native DOM listeners.\n\t *\n\t * @private\n\t * @member {Object} module:utils/dom/emittermixin~ProxyEmitter#_domListeners\n\t */\n\n\t/**\n\t * Registers a callback function to be executed when an event is fired.\n\t *\n\t * It attaches a native DOM listener to the DOM Node. When fired,\n\t * a corresponding Emitter event will also fire with DOM Event object as an argument.\n\t *\n\t * @method module:utils/dom/emittermixin~ProxyEmitter#attach\n\t * @param {String} event The name of the event.\n\t * @param {Function} callback The function to be called on event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n\t * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n\t */\n\tattach( event, callback, options = {} ) {\n\t\t// If the DOM Listener for given event already exist it is pointless\n\t\t// to attach another one.\n\t\tif ( this._domListeners && this._domListeners[ event ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domListener = this._createDomListener( event, !!options.useCapture );\n\n\t\t// Attach the native DOM listener to DOM Node.\n\t\tthis._domNode.addEventListener( event, domListener, !!options.useCapture );\n\n\t\tif ( !this._domListeners ) {\n\t\t\tthis._domListeners = {};\n\t\t}\n\n\t\t// Store the native DOM listener in this ProxyEmitter. It will be helpful\n\t\t// when stopping listening to the event.\n\t\tthis._domListeners[ event ] = domListener;\n\t},\n\n\t/**\n\t * Stops executing the callback on the given event.\n\t *\n\t * @method module:utils/dom/emittermixin~ProxyEmitter#detach\n\t * @param {String} event The name of the event.\n\t */\n\tdetach( event ) {\n\t\tlet events;\n\n\t\t// Remove native DOM listeners which are orphans. If no callbacks\n\t\t// are awaiting given event, detach native DOM listener from DOM Node.\n\t\t// See: {@link attach}.\n\n\t\tif ( this._domListeners[ event ] && ( !( events = this._events[ event ] ) || !events.callbacks.length ) ) {\n\t\t\tthis._domListeners[ event ].removeListener();\n\t\t}\n\t},\n\n\t/**\n\t * Creates a native DOM listener callback. When the native DOM event\n\t * is fired it will fire corresponding event on this ProxyEmitter.\n\t * Note: A native DOM Event is passed as an argument.\n\t *\n\t * @private\n\t * @method module:utils/dom/emittermixin~ProxyEmitter#_createDomListener\n\t * @param {String} event The name of the event.\n\t * @param {Boolean} useCapture Indicates whether the listener was created for capturing event.\n\t * @returns {Function} The DOM listener callback.\n\t */\n\t_createDomListener( event, useCapture ) {\n\t\tconst domListener = domEvt => {\n\t\t\tthis.fire( event, domEvt );\n\t\t};\n\n\t\t// Supply the DOM listener callback with a function that will help\n\t\t// detach it from the DOM Node, when it is no longer necessary.\n\t\t// See: {@link detach}.\n\t\tdomListener.removeListener = () => {\n\t\t\tthis._domNode.removeEventListener( event, domListener, useCapture );\n\t\t\tdelete this._domListeners[ event ];\n\t\t};\n\n\t\treturn domListener;\n\t}\n} );\n\n// Gets an unique DOM Node identifier. The identifier will be set if not defined.\n//\n// @private\n// @param {Node} node\n// @returns {String} UID for given DOM Node.\nfunction getNodeUID( node ) {\n\treturn node[ 'data-ck-expando' ] || ( node[ 'data-ck-expando' ] = uid() );\n}\n\n/**\n * Interface representing classes which mix in {@link module:utils/dom/emittermixin~EmitterMixin}.\n *\n * @interface Emitter\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/observer\n */\n\nimport DomEmitterMixin from '@ckeditor/ckeditor5-utils/src/dom/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Abstract base observer class. Observers are classes which listen to DOM events, do the preliminary\n * processing and fire events on the {@link module:engine/view/document~Document} objects.\n * Observers can also add features to the view, for instance by updating its status or marking elements\n * which need refresh on DOM events.\n *\n * @abstract\n */\nexport default class Observer {\n\t/**\n\t * Creates an instance of the observer.\n\t *\n\t * @param {module:engine/view/view~View} view\n\t */\n\tconstructor( view ) {\n\t\t/**\n\t\t * Instance of the view controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/view~View}\n\t\t */\n\t\tthis.view = view;\n\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/document~Document} object.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = view.document;\n\n\t\t/**\n\t\t * State of the observer. If it is disabled events will not be fired.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.isEnabled = false;\n\t}\n\n\t/**\n\t * Enables the observer. This method is called when the observer is registered to the\n\t * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#render rendering}\n\t * (all observers are {@link #disable disabled} before rendering).\n\t *\n\t * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.\n\t * However, a child class may not need to be disabled, so it can implement an empty method.\n\t *\n\t * @see module:engine/view/observer/observer~Observer#disable\n\t */\n\tenable() {\n\t\tthis.isEnabled = true;\n\t}\n\n\t/**\n\t * Disables the observer. This method is called before\n\t * {@link module:engine/view/view~View#render rendering} to prevent firing events during rendering.\n\t *\n\t * @see module:engine/view/observer/observer~Observer#enable\n\t */\n\tdisable() {\n\t\tthis.isEnabled = false;\n\t}\n\n\t/**\n\t * Disables and destroys the observer, among others removes event listeners created by the observer.\n\t */\n\tdestroy() {\n\t\tthis.disable();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Starts observing the given root element.\n\t *\n\t * @method #observe\n\t * @param {HTMLElement} domElement\n\t * @param {String} name The name of the root element.\n\t */\n}\n\nmix( Observer, DomEmitterMixin );\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nexport default setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nexport default setCacheHas;\n","import MapCache from './_MapCache';\nimport setCacheAdd from './_setCacheAdd';\nimport setCacheHas from './_setCacheHas';\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nexport default SetCache;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default arraySome;\n","import SetCache from './_SetCache';\nimport arraySome from './_arraySome';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  return result;\n}\n\nexport default equalArrays;\n","import Symbol from './_Symbol';\nimport Uint8Array from './_Uint8Array';\nimport equalArrays from './_equalArrays';\nimport mapToArray from './_mapToArray';\nimport setToArray from './_setToArray';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and\n      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as\n      // not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object) ? other != +other : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n      stack.set(object, other);\n\n      // Recursively compare objects (susceptible to call stack limits).\n      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nexport default equalByTag;\n","import baseHas from './_baseHas';\nimport keys from './keys';\n\n/** Used to compose bitmasks for comparison styles. */\nvar PARTIAL_COMPARE_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : baseHas(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  return result;\n}\n\nexport default equalObjects;\n","import isLength from './isLength';\nimport isObjectLike from './isObjectLike';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n *  else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\nexport default isTypedArray;\n","import Stack from './_Stack';\nimport equalArrays from './_equalArrays';\nimport equalByTag from './_equalByTag';\nimport equalObjects from './_equalObjects';\nimport getTag from './_getTag';\nimport isArray from './isArray';\nimport isHostObject from './_isHostObject';\nimport isTypedArray from './isTypedArray';\n\n/** Used to compose bitmasks for comparison styles. */\nvar PARTIAL_COMPARE_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\nexport default baseIsEqualDeep;\n","import baseIsEqualDeep from './_baseIsEqualDeep';\nimport isObject from './isObject';\nimport isObjectLike from './isObjectLike';\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\nexport default baseIsEqual;\n","import baseIsEqual from './_baseIsEqual';\n\n/**\n * This method is like `_.isEqual` except that it accepts `customizer` which\n * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n * are handled by the method instead. The `customizer` is invoked with up to\n * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent,\n *  else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * _.isEqualWith(array, other, customizer);\n * // => true\n */\nfunction isEqualWith(value, other, customizer) {\n  customizer = typeof customizer == 'function' ? customizer : undefined;\n  var result = customizer ? customizer(value, other) : undefined;\n  return result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n}\n\nexport default isEqualWith;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/mutationobserver\n */\n\n/* globals window */\n\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport isEqualWith from '@ckeditor/ckeditor5-utils/src/lib/lodash/isEqualWith';\n\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class MutationObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Native mutation observer config.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._config = {\n\t\t\tchildList: true,\n\t\t\tcharacterData: true,\n\t\t\tcharacterDataOldValue: true,\n\t\t\tsubtree: true\n\t\t};\n\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#domConverter}.\n\t\t *\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = view.domConverter;\n\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#renderer}.\n\t\t *\n\t\t * @member {module:engine/view/renderer~Renderer}\n\t\t */\n\t\tthis.renderer = view._renderer;\n\n\t\t/**\n\t\t * Observed DOM elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Array.<HTMLElement>}\n\t\t */\n\t\tthis._domElements = [];\n\n\t\t/**\n\t\t * Native mutation observer.\n\t\t *\n\t\t * @private\n\t\t * @member {MutationObserver}\n\t\t */\n\t\tthis._mutationObserver = new window.MutationObserver( this._onMutations.bind( this ) );\n\t}\n\n\t/**\n\t * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n\t * At the same time empties the queue so mutations will not be fired twice.\n\t */\n\tflush() {\n\t\tthis._onMutations( this._mutationObserver.takeRecords() );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domElement ) {\n\t\tthis._domElements.push( domElement );\n\n\t\tif ( this.isEnabled ) {\n\t\t\tthis._mutationObserver.observe( domElement, this._config );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tenable() {\n\t\tsuper.enable();\n\n\t\tfor ( const domElement of this._domElements ) {\n\t\t\tthis._mutationObserver.observe( domElement, this._config );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisable() {\n\t\tsuper.disable();\n\n\t\tthis._mutationObserver.disconnect();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._mutationObserver.disconnect();\n\t}\n\n\t/**\n\t * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n\t *\n\t * @private\n\t * @param {Array.<Object>} domMutations Array of native mutations.\n\t */\n\t_onMutations( domMutations ) {\n\t\t// As a result of this.flush() we can have an empty collection.\n\t\tif ( domMutations.length === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domConverter = this.domConverter;\n\n\t\t// Use map and set for deduplication.\n\t\tconst mutatedTexts = new Map();\n\t\tconst mutatedElements = new Set();\n\n\t\t// Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n\t\t// element with changed structure anyway.\n\t\tfor ( const mutation of domMutations ) {\n\t\t\tif ( mutation.type === 'childList' ) {\n\t\t\t\tconst element = domConverter.mapDomToView( mutation.target );\n\n\t\t\t\t// Do not collect mutations from UIElements.\n\t\t\t\tif ( element && element.is( 'uiElement' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( element && !this._isBogusBrMutation( mutation ) ) {\n\t\t\t\t\tmutatedElements.add( element );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n\t\tfor ( const mutation of domMutations ) {\n\t\t\tconst element = domConverter.mapDomToView( mutation.target );\n\n\t\t\t// Do not collect mutations from UIElements.\n\t\t\tif ( element && element.is( 'uiElement' ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( mutation.type === 'characterData' ) {\n\t\t\t\tconst text = domConverter.findCorrespondingViewText( mutation.target );\n\n\t\t\t\tif ( text && !mutatedElements.has( text.parent ) ) {\n\t\t\t\t\t// Use text as a key, for deduplication. If there will be another mutation on the same text element\n\t\t\t\t\t// we will have only one in the map.\n\t\t\t\t\tmutatedTexts.set( text, {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\toldText: text.data,\n\t\t\t\t\t\tnewText: getDataWithoutFiller( mutation.target ),\n\t\t\t\t\t\tnode: text\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n\t\t\t\t// on text, but for the view, where filler text node did not existed, new text node was created, so we\n\t\t\t\t// need to fire 'children' mutation instead of 'text'.\n\t\t\t\telse if ( !text && startsWithFiller( mutation.target ) ) {\n\t\t\t\t\tmutatedElements.add( domConverter.mapDomToView( mutation.target.parentNode ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n\t\t// same node multiple times in case of duplication.\n\n\t\t// List of mutations we will fire.\n\t\tconst viewMutations = [];\n\n\t\tfor ( const mutatedText of mutatedTexts.values() ) {\n\t\t\tthis.renderer.markToSync( 'text', mutatedText.node );\n\t\t\tviewMutations.push( mutatedText );\n\t\t}\n\n\t\tfor ( const viewElement of mutatedElements ) {\n\t\t\tconst domElement = domConverter.mapViewToDom( viewElement );\n\t\t\tconst viewChildren = Array.from( viewElement.getChildren() );\n\t\t\tconst newViewChildren = Array.from( domConverter.domChildrenToView( domElement, { withChildren: false } ) );\n\n\t\t\t// It may happen that as a result of many changes (sth was inserted and then removed),\n\t\t\t// both elements haven't really changed. #1031\n\t\t\tif ( !isEqualWith( viewChildren, newViewChildren, sameNodes ) ) {\n\t\t\t\tthis.renderer.markToSync( 'children', viewElement );\n\n\t\t\t\tviewMutations.push( {\n\t\t\t\t\ttype: 'children',\n\t\t\t\t\toldChildren: viewChildren,\n\t\t\t\t\tnewChildren: newViewChildren,\n\t\t\t\t\tnode: viewElement\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\t// Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n\t\t// There should not be simultaneous mutation in multiple documents, so it's fine.\n\t\tconst domSelection = domMutations[ 0 ].target.ownerDocument.getSelection();\n\n\t\tlet viewSelection = null;\n\n\t\tif ( domSelection && domSelection.anchorNode ) {\n\t\t\t// If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n\t\t\t// corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n\t\t\t// be used by features handling mutations.\n\t\t\t// Only one range is supported.\n\n\t\t\tconst viewSelectionAnchor = domConverter.domPositionToView( domSelection.anchorNode, domSelection.anchorOffset );\n\t\t\tconst viewSelectionFocus = domConverter.domPositionToView( domSelection.focusNode, domSelection.focusOffset );\n\n\t\t\t// Anchor and focus has to be properly mapped to view.\n\t\t\tif ( viewSelectionAnchor && viewSelectionFocus ) {\n\t\t\t\tviewSelection = new ViewSelection( viewSelectionAnchor );\n\t\t\t\tviewSelection.setFocus( viewSelectionFocus );\n\t\t\t}\n\t\t}\n\n\t\tthis.document.fire( 'mutations', viewMutations, viewSelection );\n\n\t\t// If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n\t\t// view (which has not been changed). In order to \"reset DOM\" we render the view again.\n\t\tthis.view.render();\n\n\t\tfunction sameNodes( child1, child2 ) {\n\t\t\t// First level of comparison (array of children vs array of children) – use the Lodash's default behavior.\n\t\t\tif ( Array.isArray( child1 ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Elements.\n\t\t\tif ( child1 === child2 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Texts.\n\t\t\telse if ( child1.is( 'text' ) && child2.is( 'text' ) ) {\n\t\t\t\treturn child1.data === child2.data;\n\t\t\t}\n\n\t\t\t// Not matching types.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n\t * Such mutations are generated while pressing space or performing native spellchecker correction\n\t * on the end of the block element in Firefox browser.\n\t *\n\t * @private\n\t * @param {Object} mutation Native mutation object.\n\t * @returns {Boolean}\n\t */\n\t_isBogusBrMutation( mutation ) {\n\t\tlet addedNode = null;\n\n\t\t// Check if mutation added only one node on the end of its parent.\n\t\tif ( mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1 ) {\n\t\t\taddedNode = this.domConverter.domToView( mutation.addedNodes[ 0 ], {\n\t\t\t\twithChildren: false\n\t\t\t} );\n\t\t}\n\n\t\treturn addedNode && addedNode.is( 'element', 'br' );\n\t}\n}\n\n/**\n * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverted to the state before\n * mutation, so all changes which should be applied, should be handled on this event.\n *\n * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.\n *\n * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @event module:engine/view/document~Document#event:mutations\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}\n * viewMutations Array of mutations.\n * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be\n * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.\n * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.\n * Keep in\n * mind that the DOM selection is already \"updated\", meaning that it already acknowledges changes done in mutation.\n */\n\n/**\n * Mutation item for text.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText\n *\n * @property {String} type For text mutations it is always 'text'.\n * @property {module:engine/view/text~Text} node Mutated text node.\n * @property {String} oldText Old text.\n * @property {String} newText New text.\n */\n\n/**\n * Mutation item for child nodes.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedText\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @property {String} type For child nodes mutations it is always 'children'.\n * @property {module:engine/view/element~Element} node Parent of the mutated children.\n * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.\n * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/domeventdata\n */\n\nimport extend from '@ckeditor/ckeditor5-utils/src/lib/lodash/extend';\n\n/**\n * Information about a DOM event in context of the {@link module:engine/view/document~Document}.\n * It wraps the native event, which usually should not be used as the wrapper contains\n * additional data (like key code for keyboard events).\n */\nexport default class DomEventData {\n\t/**\n\t * @param {module:engine/view/view~View} view The instance of the view controller.\n\t * @param {Event} domEvent The DOM event.\n\t * @param {Object} [additionalData] Additional properties that the instance should contain.\n\t */\n\tconstructor( view, domEvent, additionalData ) {\n\t\t/**\n\t\t * Instance of the view controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/view~View} module:engine/view/observer/observer~Observer.DomEvent#view\n\t\t */\n\t\tthis.view = view;\n\n\t\t/**\n\t\t * The instance of the document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document} module:engine/view/observer/observer~Observer.DomEvent#document\n\t\t */\n\t\tthis.document = view.document;\n\n\t\t/**\n\t\t * The DOM event.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Event} module:engine/view/observer/observer~Observer.DomEvent#domEvent\n\t\t */\n\t\tthis.domEvent = domEvent;\n\n\t\t/**\n\t\t * The DOM target.\n\t\t *\n\t\t * @readonly\n\t\t * @member {HTMLElement} module:engine/view/observer/observer~Observer.DomEvent#target\n\t\t */\n\t\tthis.domTarget = domEvent.target;\n\n\t\textend( this, additionalData );\n\t}\n\n\t/**\n\t * The tree view element representing the target.\n\t *\n\t * @readonly\n\t * @type module:engine/view/element~Element\n\t */\n\tget target() {\n\t\treturn this.view.domConverter.mapDomToView( this.domTarget );\n\t}\n\n\t/**\n\t * Prevents the native's event default action.\n\t */\n\tpreventDefault() {\n\t\tthis.domEvent.preventDefault();\n\t}\n\n\t/**\n\t * Stops native event propagation.\n\t */\n\tstopPropagation() {\n\t\tthis.domEvent.stopPropagation();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/domeventobserver\n */\n\nimport Observer from './observer';\nimport DomEventData from './domeventdata';\n\n/**\n * Base class for DOM event observers. This class handles\n * {@link module:engine/view/observer/observer~Observer#observe adding} listeners to DOM elements,\n * {@link module:engine/view/observer/observer~Observer#disable disabling} and\n * {@link module:engine/view/observer/observer~Observer#enable re-enabling} events.\n * Child class needs to define\n * {@link module:engine/view/observer/domeventobserver~DomEventObserver#domEventType DOM event type} and\n * {@link module:engine/view/observer/domeventobserver~DomEventObserver#onDomEvent callback}.\n *\n * For instance:\n *\n *\t\tclass ClickObserver extends DomEventObserver {\n *\t\t\t// It can also be defined as a normal property in the constructor.\n *\t\t\tget domEventType() {\n *\t\t\t\treturn 'click';\n *\t\t\t}\n *\n *\t\t\tonDomEvent( domEvent ) {\n *\t\t\t\tthis.fire( 'click', domEvent );\n *\t\t\t}\n *\t\t}\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class DomEventObserver extends Observer {\n\t/**\n\t * Type of the DOM event the observer should listen on. Array of types can be defined\n\t * if the obsever should listen to multiple DOM events.\n\t *\n\t * @readonly\n\t * @member {String|Array.<String>} #domEventType\n\t */\n\n\t/**\n\t * Callback which should be called when the DOM event occurred. Note that the callback will not be called if\n\t * observer {@link #isEnabled is not enabled}.\n\t *\n\t * @see #domEventType\n\t * @abstract\n\t * @method #onDomEvent\n\t */\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * If set to `true` DOM events will be listened on the capturing phase.\n\t\t * Default value is `false`.\n\t\t *\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.useCapture = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domElement ) {\n\t\tconst types = typeof this.domEventType == 'string' ? [ this.domEventType ] : this.domEventType;\n\n\t\ttypes.forEach( type => {\n\t\t\tthis.listenTo( domElement, type, ( eventInfo, domEvent ) => {\n\t\t\t\tif ( this.isEnabled ) {\n\t\t\t\t\tthis.onDomEvent( domEvent );\n\t\t\t\t}\n\t\t\t}, { useCapture: this.useCapture } );\n\t\t} );\n\t}\n\n\t/**\n\t * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.\n\t *\n\t * @see module:utils/emittermixin~EmitterMixin#fire\n\t * @param {String} eventType The event type (name).\n\t * @param {Event} domEvent The DOM event.\n\t * @param {Object} [additionalData] The additional data which should extend the\n\t * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.\n\t */\n\tfire( eventType, domEvent, additionalData ) {\n\t\tif ( this.isEnabled ) {\n\t\t\tthis.document.fire( eventType, new DomEventData( this.view, domEvent, additionalData ) );\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/keyobserver\n */\n\nimport DomEventObserver from './domeventobserver';\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * {@link module:engine/view/document~Document#event:keydown Key down} event observer.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\nexport default class KeyObserver extends DomEventObserver {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tthis.domEventType = [ 'keydown', 'keyup' ];\n\t}\n\n\tonDomEvent( domEvt ) {\n\t\tthis.fire( domEvt.type, domEvt, {\n\t\t\tkeyCode: domEvt.keyCode,\n\n\t\t\taltKey: domEvt.altKey,\n\t\t\tctrlKey: domEvt.ctrlKey || domEvt.metaKey,\n\t\t\tshiftKey: domEvt.shiftKey,\n\n\t\t\tget keystroke() {\n\t\t\t\treturn getCode( this );\n\t\t\t}\n\t\t} );\n\t}\n}\n\n/**\n * Fired when a key has been pressed.\n *\n * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.\n *\n * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/keyobserver~KeyObserver\n * @event module:engine/view/document~Document#event:keydown\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData\n */\n\n/**\n * Fired when a key has been released.\n *\n * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.\n *\n * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/keyobserver~KeyObserver\n * @event module:engine/view/document~Document#event:keyup\n * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData\n */\n\n/**\n * The value of both events - {@link module:engine/view/document~Document#event:keydown} and\n * {@link module:engine/view/document~Document#event:keyup}.\n *\n * @class module:engine/view/observer/keyobserver~KeyEventData\n * @extends module:engine/view/observer/domeventdata~DomEventData\n * @implements module:utils/keyboard~KeystrokeInfo\n */\n\n/**\n * Code of the whole keystroke. See {@link module:utils/keyboard~getCode}.\n *\n * @readonly\n * @member {Number} module:engine/view/observer/keyobserver~KeyEventData#keystroke\n */\n","/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @type {Function}\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred function to be invoked.\n */\nvar now = Date.now;\n\nexport default now;\n","import isObject from './isObject';\nimport now from './now';\nimport toNumber from './toNumber';\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide an options object to indicate whether `func` should be invoked on\n * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent calls\n * to the debounced function return the result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime = 0,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (!lastCallTime || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    clearTimeout(timerId);\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastCallTime = lastInvokeTime = 0;\n    lastArgs = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\n\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport debounce from '@ckeditor/ckeditor5-utils/src/lib/lodash/debounce';\n\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer.Observer\n */\nexport default class FakeSelectionObserver extends Observer {\n\t/**\n\t * Creates new FakeSelectionObserver instance.\n\t *\n\t * @param {module:engine/view/view~View} view\n\t */\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n\t\t *\n\t\t * @private\n\t\t * @param {Object} data Selection change data.\n\t\t * @method #_fireSelectionChangeDoneDebounced\n\t\t */\n\t\tthis._fireSelectionChangeDoneDebounced = debounce( data => this.document.fire( 'selectionChangeDone', data ), 200 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve() {\n\t\tconst document = this.document;\n\n\t\tdocument.on( 'keydown', ( eventInfo, data ) => {\n\t\t\tconst selection = document.selection;\n\n\t\t\tif ( selection.isFake && _isArrowKeyCode( data.keyCode ) && this.isEnabled ) {\n\t\t\t\t// Prevents default key down handling - no selection change will occur.\n\t\t\t\tdata.preventDefault();\n\n\t\t\t\tthis._handleSelectionMove( data.keyCode );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._fireSelectionChangeDoneDebounced.cancel();\n\t}\n\n\t/**\n\t * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n\t * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n\t *\n\t * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n\t * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n\t * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n\t *\n\t * @private\n\t * @param {Number} keyCode\n\t * @fires module:engine/view/document~Document#event:selectionChange\n\t * @fires module:engine/view/document~Document#event:selectionChangeDone\n\t */\n\t_handleSelectionMove( keyCode ) {\n\t\tconst selection = this.document.selection;\n\t\tconst newSelection = new ViewSelection( selection.getRanges(), { backward: selection.isBackward, fake: false } );\n\n\t\t// Left or up arrow pressed - move selection to start.\n\t\tif ( keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup ) {\n\t\t\tnewSelection.setTo( newSelection.getFirstPosition() );\n\t\t}\n\n\t\t// Right or down arrow pressed - move selection to end.\n\t\tif ( keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown ) {\n\t\t\tnewSelection.setTo( newSelection.getLastPosition() );\n\t\t}\n\n\t\tconst data = {\n\t\t\toldSelection: selection,\n\t\t\tnewSelection,\n\t\t\tdomSelection: null\n\t\t};\n\n\t\t// Fire dummy selection change event.\n\t\tthis.document.fire( 'selectionChange', data );\n\n\t\t// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n\t\t// This function is debounced what means that `selectionChangeDone` event will be fired only when\n\t\t// defined int the function time will elapse since the last time the function was called.\n\t\t// So `selectionChangeDone` will be fired when selection will stop changing.\n\t\tthis._fireSelectionChangeDoneDebounced( data );\n\t}\n}\n\n// Checks if one of the arrow keys is pressed.\n//\n// @private\n// @param {Number} keyCode\n// @returns {Boolean}\nfunction _isArrowKeyCode( keyCode ) {\n\treturn keyCode == keyCodes.arrowright ||\n\t\tkeyCode == keyCodes.arrowleft ||\n\t\tkeyCode == keyCodes.arrowup ||\n\t\tkeyCode == keyCodes.arrowdown;\n}\n\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/selectionobserver\n */\n\n/* global setInterval, clearInterval */\n\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport debounce from '@ckeditor/ckeditor5-utils/src/lib/lodash/debounce';\n\n/**\n * Selection observer class observes selection changes in the document. If selection changes on the document this\n * observer checks if there are any mutations and if DOM selection is different than the\n * {@link module:engine/view/document~Document#selection view selection}. Selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if selection change was the only change in the document\n * and DOM selection is different then the view selection.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class SelectionObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Instance of the mutation observer. Selection observer calls\n\t\t * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n\t\t * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n\t\t * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n\t\t */\n\t\tthis.mutationObserver = view.getObserver( MutationObserver );\n\n\t\t/**\n\t\t * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n\t\t * new selection with it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n\t\t */\n\t\tthis.selection = this.document.selection;\n\n\t\t/* eslint-disable max-len */\n\t\t/**\n\t\t * Reference to the {@link module:engine/view/view~View#domConverter}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n\t\t */\n\t\t/* eslint-enable max-len */\n\t\tthis.domConverter = view.domConverter;\n\n\t\t/**\n\t\t * Set of documents which have added \"selectionchange\" listener to avoid adding listener twice to the same\n\t\t * document.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n\t\t */\n\t\tthis._documents = new WeakSet();\n\n\t\t/**\n\t\t * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n\t\t *\n\t\t * @private\n\t\t * @param {Object} data Selection change data.\n\t\t * @method #_fireSelectionChangeDoneDebounced\n\t\t */\n\t\tthis._fireSelectionChangeDoneDebounced = debounce( data => this.document.fire( 'selectionChangeDone', data ), 200 );\n\n\t\tthis._clearInfiniteLoopInterval = setInterval( () => this._clearInfiniteLoop(), 1000 );\n\n\t\t/**\n\t\t * Private property to check if the code does not enter infinite loop.\n\t\t *\n\t\t * @private\n\t\t * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n\t\t */\n\t\tthis._loopbackCounter = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domElement ) {\n\t\tconst domDocument = domElement.ownerDocument;\n\n\t\t// Add listener once per each document.\n\t\tif ( this._documents.has( domDocument ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listenTo( domDocument, 'selectionchange', () => {\n\t\t\tthis._handleSelectionChange( domDocument );\n\t\t} );\n\n\t\tthis._documents.add( domDocument );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tclearInterval( this._clearInfiniteLoopInterval );\n\t\tthis._fireSelectionChangeDoneDebounced.cancel();\n\t}\n\n\t/**\n\t * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n\t * selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n\t * and {@link module:engine/view/document~Document#event:selectionChangeDone} when selection stop changing.\n\t *\n\t * @private\n\t * @param {Document} domDocument DOM document.\n\t */\n\t_handleSelectionChange( domDocument ) {\n\t\t// Selection is handled when document is not focused but is read-only. This is because in read-only\n\t\t// mode contenteditable is set as false and editor won't receive focus but we still need to know\n\t\t// selection position.\n\t\tif ( !this.isEnabled || ( !this.document.isFocused && !this.document.isReadOnly ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure the mutation event will be before selection event on all browsers.\n\t\tthis.mutationObserver.flush();\n\n\t\t// If there were mutations then the view will be re-rendered by the mutation observer and selection\n\t\t// will be updated, so selections will equal and event will not be fired, as expected.\n\t\tconst domSelection = domDocument.defaultView.getSelection();\n\t\tconst newViewSelection = this.domConverter.domSelectionToView( domSelection );\n\n\t\tif ( this.selection.isEqual( newViewSelection ) && this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure we are not in the infinite loop (#400).\n\t\t// This counter is reset each second. 60 selection changes in 1 second is enough high number\n\t\t// to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n\t\tif ( ++this._loopbackCounter > 60 ) {\n\t\t\t/**\n\t\t\t * Selection change observer detected an infinite rendering loop.\n\t\t\t * Most probably you try to put the selection in the position which is not allowed\n\t\t\t * by the browser and browser fixes it automatically what causes `selectionchange` event on\n\t\t\t * which a loopback through a model tries to re-render the wrong selection and again.\n\t\t\t *\n\t\t\t * @error selectionchange-infinite-loop\n\t\t\t */\n\t\t\tlog.warn( 'selectionchange-infinite-loop: Selection change observer detected an infinite rendering loop.' );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.selection.isSimilar( newViewSelection ) ) {\n\t\t\t// If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n\t\t\t// Just re-render it, no need to fire any events, etc.\n\t\t\tthis.view.render();\n\t\t} else {\n\t\t\tconst data = {\n\t\t\t\toldSelection: this.selection,\n\t\t\t\tnewSelection: newViewSelection,\n\t\t\t\tdomSelection\n\t\t\t};\n\n\t\t\t// Prepare data for new selection and fire appropriate events.\n\t\t\tthis.document.fire( 'selectionChange', data );\n\n\t\t\t// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n\t\t\t// This function is debounced what means that `selectionChangeDone` event will be fired only when\n\t\t\t// defined int the function time will elapse since the last time the function was called.\n\t\t\t// So `selectionChangeDone` will be fired when selection will stop changing.\n\t\t\tthis._fireSelectionChangeDoneDebounced( data );\n\t\t}\n\t}\n\n\t/**\n\t * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n\t *\n\t * @protected\n\t */\n\t_clearInfiniteLoop() {\n\t\tthis._loopbackCounter = 0;\n\t}\n}\n\n/**\n * Fired when selection has changed. This event is fired only when the selection change was the only change that happened\n * in the document, and old selection is different then the new selection.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChange\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/focusobserver\n */\n\n/* globals setTimeout, clearTimeout */\n\nimport DomEventObserver from './domeventobserver';\n\n/**\n * {@link module:engine/view/document~Document#event:focus Focus}\n * and {@link module:engine/view/document~Document#event:blur blur} events observer.\n * Focus observer handle also {@link module:engine/view/rooteditableelement~RootEditableElement#isFocused isFocused} property of the\n * {@link module:engine/view/rooteditableelement~RootEditableElement root elements}.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\nexport default class FocusObserver extends DomEventObserver {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tthis.domEventType = [ 'focus', 'blur' ];\n\t\tthis.useCapture = true;\n\t\tconst document = this.document;\n\n\t\tdocument.on( 'focus', () => {\n\t\t\tdocument.isFocused = true;\n\n\t\t\t// Unfortunately native `selectionchange` event is fired asynchronously.\n\t\t\t// We need to wait until `SelectionObserver` handle the event and then render. Otherwise rendering will\n\t\t\t// overwrite new DOM selection with selection from the view.\n\t\t\t// See https://github.com/ckeditor/ckeditor5-engine/issues/795 for more details.\n\t\t\t// Long timeout is needed to solve #676 and https://github.com/ckeditor/ckeditor5-engine/issues/1157 issues.\n\t\t\tthis._renderTimeoutId = setTimeout( () => view.render(), 50 );\n\t\t} );\n\n\t\tdocument.on( 'blur', ( evt, data ) => {\n\t\t\tconst selectedEditable = document.selection.editableElement;\n\n\t\t\tif ( selectedEditable === null || selectedEditable === data.target ) {\n\t\t\t\tdocument.isFocused = false;\n\n\t\t\t\t// Re-render the document to update view elements.\n\t\t\t\tview.render();\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * Identifier of the timeout currently used by focus listener to delay rendering execution.\n\t\t *\n\t\t * @private\n\t\t * @member {Number} #_renderTimeoutId\n\t\t */\n\t}\n\n\tonDomEvent( domEvent ) {\n\t\tthis.fire( domEvent.type, domEvent );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tif ( this._renderTimeoutId ) {\n\t\t\tclearTimeout( this._renderTimeoutId );\n\t\t}\n\n\t\tsuper.destroy();\n\t}\n}\n\n/**\n * Fired when one of the editables gets focus.\n *\n * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.\n *\n * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/focusobserver~FocusObserver\n * @event module:engine/view/document~Document#event:focus\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n\n/**\n * Fired when one of the editables loses focus.\n *\n * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.\n *\n * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/focusobserver~FocusObserver\n * @event module:engine/view/document~Document#event:blur\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/compositionobserver\n */\n\nimport DomEventObserver from './domeventobserver';\n\n/**\n * {@link module:engine/view/document~Document#event:compositionstart Compositionstart},\n * {@link module:engine/view/document~Document#event:compositionupdate compositionupdate} and\n * {@link module:engine/view/document~Document#event:compositionend compositionend} events observer.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\nexport default class CompositionObserver extends DomEventObserver {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tthis.domEventType = [ 'compositionstart', 'compositionupdate', 'compositionend' ];\n\t\tconst document = this.document;\n\n\t\tdocument.on( 'compositionstart', () => {\n\t\t\tdocument.isComposing = true;\n\t\t} );\n\n\t\tdocument.on( 'compositionend', () => {\n\t\t\tdocument.isComposing = false;\n\t\t} );\n\t}\n\n\tonDomEvent( domEvent ) {\n\t\tthis.fire( domEvent.type, domEvent );\n\t}\n}\n\n/**\n * Fired when composition starts inside one of the editables.\n *\n * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n *\n * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/compositionobserver~CompositionObserver\n * @event module:engine/view/document~Document#event:compositionstart\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n\n/**\n * Fired when composition is updated inside one of the editables.\n *\n * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n *\n * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/compositionobserver~CompositionObserver\n * @event module:engine/view/document~Document#event:compositionupdate\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n\n/**\n * Fired when composition ends inside one of the editables.\n *\n * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n *\n * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/compositionobserver~CompositionObserver\n * @event module:engine/view/document~Document#event:compositionend\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/isrange\n */\n\n/**\n * Checks if the object is a native DOM Range.\n *\n * @param {*} obj\n * @returns {Boolean}\n */\nexport default function isRange( obj ) {\n\treturn Object.prototype.toString.apply( obj ) == '[object Range]';\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/getborderwidths\n */\n\n/**\n * Returns an object containing CSS border widths of a specified HTML element.\n *\n * @param {HTMLElement} element An element which has CSS borders.\n * @param {Object} An object containing `top`, `left`, `right` and `bottom` properties\n * with numerical values of the `border-[top,left,right,bottom]-width` CSS styles.\n */\nexport default function getBorderWidths( element ) {\n\t// Call getComputedStyle on the window the element document belongs to.\n\tconst style = element.ownerDocument.defaultView.getComputedStyle( element );\n\n\treturn {\n\t\ttop: parseInt( style.borderTopWidth, 10 ),\n\t\tright: parseInt( style.borderRightWidth, 10 ),\n\t\tbottom: parseInt( style.borderBottomWidth, 10 ),\n\t\tleft: parseInt( style.borderLeftWidth, 10 )\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/rect\n */\n\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport isElement from '../lib/lodash/isElement';\nimport getBorderWidths from './getborderwidths';\nimport log from '../log';\nimport isText from './istext';\n\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\nexport default class Rect {\n\t/**\n\t * Creates an instance of rect.\n\t *\n\t *\t\t// Rect of an HTMLElement.\n\t *\t\tconst rectA = new Rect( document.body );\n\t *\n\t *\t\t// Rect of a DOM Range.\n\t *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n\t *\n\t *\t\t// Rect of a window (web browser viewport).\n\t *\t\tconst rectC = new Rect( window );\n\t *\n\t *\t\t// Rect out of an object.\n\t *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n\t *\n\t *\t\t// Rect out of another Rect instance.\n\t *\t\tconst rectE = new Rect( rectD );\n\t *\n\t *\t\t// Rect out of a ClientRect.\n\t *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n\t *\n\t * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n\t * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n\t * to get the inner part of the rect.\n\t *\n\t * @param {HTMLElement|Range|Window|ClientRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.\n\t */\n\tconstructor( source ) {\n\t\tconst isSourceRange = isRange( source );\n\n\t\t/**\n\t\t * The object this rect is for.\n\t\t *\n\t\t * @protected\n\t\t * @readonly\n\t\t * @member {HTMLElement|Range|ClientRect|module:utils/dom/rect~Rect|Object} #_source\n\t\t */\n\t\tObject.defineProperty( this, '_source', {\n\t\t\t// If the source is a Rect instance, copy it's #_source.\n\t\t\tvalue: source._source || source,\n\t\t\twritable: true,\n\t\t\tenumerable: false\n\t\t} );\n\n\t\tif ( isElement( source ) || isSourceRange ) {\n\t\t\tconst sourceNode = isSourceRange ? source.startContainer : source;\n\n\t\t\tif ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n\t\t\t\t/**\n\t\t\t\t * The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods.\n\t\t\t\t * If the {@link #constructor source} of a rect in an HTML element or a DOM range but it does\n\t\t\t\t * not belong to any rendered DOM tree, these methods will fail to obtain the geometry and\n\t\t\t\t * the rect instance makes little sense to the features using it.\n\t\t\t\t *\n\t\t\t\t * To get rid of this warning make sure the source passed to the constructor\n\t\t\t\t * is a descendant of `window.document.body`.\n\t\t\t\t *\n\t\t\t\t * @error rect-source-not-in-dom\n\t\t\t\t * @param {String} source The source of the Rect instance.\n\t\t\t\t */\n\t\t\t\tlog.warn(\n\t\t\t\t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n\t\t\t\t\t{ source }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( isSourceRange ) {\n\t\t\t\tcopyRectProperties( this, Rect.getDomRangeRects( source )[ 0 ] );\n\t\t\t} else {\n\t\t\t\tcopyRectProperties( this, source.getBoundingClientRect() );\n\t\t\t}\n\t\t} else if ( isWindow( source ) ) {\n\t\t\tconst { innerWidth, innerHeight } = source;\n\n\t\t\tcopyRectProperties( this, {\n\t\t\t\ttop: 0,\n\t\t\t\tright: innerWidth,\n\t\t\t\tbottom: innerHeight,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: innerWidth,\n\t\t\t\theight: innerHeight\n\t\t\t} );\n\t\t} else {\n\t\t\tcopyRectProperties( this, source );\n\t\t}\n\n\t\t/**\n\t\t * The \"top\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #top\n\t\t */\n\n\t\t/**\n\t\t * The \"right\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #right\n\t\t */\n\n\t\t/**\n\t\t * The \"bottom\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #bottom\n\t\t */\n\n\t\t/**\n\t\t * The \"left\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #left\n\t\t */\n\n\t\t/**\n\t\t * The \"width\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #width\n\t\t */\n\n\t\t/**\n\t\t * The \"height\" value of the rect.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #height\n\t\t */\n\t}\n\n\t/**\n\t * Returns a clone of the rect.\n\t *\n\t * @returns {module:utils/dom/rect~Rect} A cloned rect.\n\t */\n\tclone() {\n\t\treturn new Rect( this );\n\t}\n\n\t/**\n\t * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n\t *\n\t * @param {Number} x Desired horizontal location.\n\t * @param {Number} y Desired vertical location.\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n\t */\n\tmoveTo( x, y ) {\n\t\tthis.top = y;\n\t\tthis.right = x + this.width;\n\t\tthis.bottom = y + this.height;\n\t\tthis.left = x;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the rect in–place by a dedicated offset.\n\t *\n\t * @param {Number} x A horizontal offset.\n\t * @param {Number} y A vertical offset\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n\t */\n\tmoveBy( x, y ) {\n\t\tthis.top += y;\n\t\tthis.right += x;\n\t\tthis.left += x;\n\t\tthis.bottom += y;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a new rect a a result of intersection with another rect.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect\n\t * @returns {module:utils/dom/rect~Rect}\n\t */\n\tgetIntersection( anotherRect ) {\n\t\tconst rect = {\n\t\t\ttop: Math.max( this.top, anotherRect.top ),\n\t\t\tright: Math.min( this.right, anotherRect.right ),\n\t\t\tbottom: Math.min( this.bottom, anotherRect.bottom ),\n\t\t\tleft: Math.max( this.left, anotherRect.left )\n\t\t};\n\n\t\trect.width = rect.right - rect.left;\n\t\trect.height = rect.bottom - rect.top;\n\n\t\tif ( rect.width < 0 || rect.height < 0 ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn new Rect( rect );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the area of intersection with another rect.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect [description]\n\t * @returns {Number} Area of intersection.\n\t */\n\tgetIntersectionArea( anotherRect ) {\n\t\tconst rect = this.getIntersection( anotherRect );\n\n\t\tif ( rect ) {\n\t\t\treturn rect.getArea();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the area of the rect.\n\t *\n\t * @returns {Number}\n\t */\n\tgetArea() {\n\t\treturn this.width * this.height;\n\t}\n\n\t/**\n\t * Returns a new rect, a part of the original rect, which is actually visible to the user,\n\t * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n\t * other than `\"visible\"`.\n\t *\n\t * If there's no such visible rect, which is when the rect is limited by one or many of\n\t * the ancestors, `null` is returned.\n\t *\n\t * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n\t */\n\tgetVisible() {\n\t\tconst source = this._source;\n\t\tlet visibleRect = this.clone();\n\n\t\t// There's no ancestor to crop <body> with the overflow.\n\t\tif ( !isBody( source ) ) {\n\t\t\tlet parent = source.parentNode || source.commonAncestorContainer;\n\n\t\t\t// Check the ancestors all the way up to the <body>.\n\t\t\twhile ( parent && !isBody( parent ) ) {\n\t\t\t\tconst parentRect = new Rect( parent );\n\t\t\t\tconst intersectionRect = visibleRect.getIntersection( parentRect );\n\n\t\t\t\tif ( intersectionRect ) {\n\t\t\t\t\tif ( intersectionRect.getArea() < visibleRect.getArea() ) {\n\t\t\t\t\t\t// Reduce the visible rect to the intersection.\n\t\t\t\t\t\tvisibleRect = intersectionRect;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// There's no intersection, the rect is completely invisible.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t}\n\n\t\treturn visibleRect;\n\t}\n\n\t/**\n\t * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n\t * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n\t * instances.\n\t *\n\t * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.\n\t * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n\t */\n\tisEqual( anotherRect ) {\n\t\tfor ( const prop of rectProperties ) {\n\t\t\tif ( this[ prop ] !== anotherRect[ prop ] ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether a rect fully contains another rect instance.\n\t *\n\t * @param {module:utils/dom/rect~Rect} anotherRect\n\t * @returns {Boolean} `true` if contains, `false` otherwise.\n\t */\n\tcontains( anotherRect ) {\n\t\tconst intersectRect = this.getIntersection( anotherRect );\n\n\t\treturn !!( intersectRect && intersectRect.isEqual( anotherRect ) );\n\t}\n\n\t/**\n\t * Excludes scrollbars and CSS borders from the rect.\n\t *\n\t * * Borders are removed when {@link #_source} is an HTML element.\n\t * * Scrollbars are excluded from HTML elements and the `window`.\n\t *\n\t * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n\t */\n\texcludeScrollbarsAndBorders() {\n\t\tconst source = this._source;\n\t\tlet scrollBarWidth, scrollBarHeight;\n\n\t\tif ( isWindow( source ) ) {\n\t\t\tscrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n\t\t\tscrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n\t\t} else {\n\t\t\tconst borderWidths = getBorderWidths( this._source );\n\n\t\t\tscrollBarWidth = source.offsetWidth - source.clientWidth;\n\t\t\tscrollBarHeight = source.offsetHeight - source.clientHeight;\n\n\t\t\tthis.moveBy( borderWidths.left, borderWidths.top );\n\t\t}\n\n\t\t// Assuming LTR scrollbars. TODO: RTL.\n\t\tthis.width -= scrollBarWidth;\n\t\tthis.right -= scrollBarWidth;\n\n\t\tthis.height -= scrollBarHeight;\n\t\tthis.bottom -= scrollBarHeight;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of rects of the given native DOM Range.\n\t *\n\t * @param {Range} range A native DOM range.\n\t * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n\t */\n\tstatic getDomRangeRects( range ) {\n\t\tconst rects = [];\n\t\t// Safari does not iterate over ClientRectList using for...of loop.\n\t\tconst clientRects = Array.from( range.getClientRects() );\n\n\t\tif ( clientRects.length ) {\n\t\t\tfor ( const rect of clientRects ) {\n\t\t\t\trects.push( new Rect( rect ) );\n\t\t\t}\n\t\t}\n\t\t// If there's no client rects for the Range, use parent container's bounding rect\n\t\t// instead and adjust rect's width to simulate the actual geometry of such range.\n\t\t// https://github.com/ckeditor/ckeditor5-utils/issues/153\n\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/317\n\t\telse {\n\t\t\tlet startContainer = range.startContainer;\n\n\t\t\tif ( isText( startContainer ) ) {\n\t\t\t\tstartContainer = startContainer.parentNode;\n\t\t\t}\n\n\t\t\tconst rect = new Rect( startContainer.getBoundingClientRect() );\n\t\t\trect.right = rect.left;\n\t\t\trect.width = 0;\n\n\t\t\trects.push( rect );\n\t\t}\n\n\t\treturn rects;\n\t}\n}\n\nconst rectProperties = [ 'top', 'right', 'bottom', 'left', 'width', 'height' ];\n\n// Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {ClientRect|module:utils/dom/rect~Rect|Object} source\nfunction copyRectProperties( rect, source ) {\n\tfor ( const p of rectProperties ) {\n\t\trect[ p ] = source[ p ];\n\t}\n}\n\n// Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Boolean}\nfunction isBody( elementOrRange ) {\n\tif ( !isElement( elementOrRange ) ) {\n\t\treturn false;\n\t}\n\n\treturn elementOrRange === elementOrRange.ownerDocument.body;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/scroll\n */\n\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\n\nconst utils = {};\n\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\nexport function scrollViewportToShowTarget( { target, viewportOffset = 0 } ) {\n\tconst targetWindow = getWindow( target );\n\tlet currentWindow = targetWindow;\n\tlet currentFrame = null;\n\n\t// Iterate over all windows, starting from target's parent window up to window#top.\n\twhile ( currentWindow ) {\n\t\tlet firstAncestorToScroll;\n\n\t\t// Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n\t\t// settled down, the algorithm can eventually scroll the viewport of the current window.\n\t\t//\n\t\t// Note: If the current window is target's **original** window (e.g. the first one),\n\t\t// start scrolling the closest parent of the target. If not, scroll the closest parent\n\t\t// of an iframe that resides in the current window.\n\t\tif ( currentWindow == targetWindow ) {\n\t\t\tfirstAncestorToScroll = getParentElement( target );\n\t\t} else {\n\t\t\tfirstAncestorToScroll = getParentElement( currentFrame );\n\t\t}\n\n\t\t// Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n\t\tscrollAncestorsToShowRect( firstAncestorToScroll, () => {\n\t\t\t// Note: If the target does not belong to the current window **directly**,\n\t\t\t// i.e. it resides in an iframe belonging to the window, obtain the target's rect\n\t\t\t// in the coordinates of the current window. By default, a Rect returns geometry\n\t\t\t// relative to the current window's viewport. To make it work in a parent window,\n\t\t\t// it must be shifted.\n\t\t\treturn getRectRelativeToWindow( target, currentWindow );\n\t\t} );\n\n\t\t// Obtain the rect of the target after it has been scrolled within its ancestors.\n\t\t// It's time to scroll the viewport.\n\t\tconst targetRect = getRectRelativeToWindow( target, currentWindow );\n\n\t\tscrollWindowToShowRect( currentWindow, targetRect, viewportOffset );\n\n\t\tif ( currentWindow.parent != currentWindow ) {\n\t\t\t// Keep the reference to the <iframe> element the \"previous current window\" was\n\t\t\t// rendered within. It will be useful to re–calculate the rect of the target\n\t\t\t// in the parent window's relative geometry. The target's rect must be shifted\n\t\t\t// by it's iframe's position.\n\t\t\tcurrentFrame = currentWindow.frameElement;\n\t\t\tcurrentWindow = currentWindow.parent;\n\n\t\t\t// If the current window has some parent but frameElement is inaccessible, then they have\n\t\t\t// different domains/ports and, due to security reasons, accessing and scrolling\n\t\t\t// the parent window won't be possible.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/930.\n\t\t\tif ( !currentFrame ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentWindow = null;\n\t\t}\n\t}\n}\n\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\nexport function scrollAncestorsToShowTarget( target ) {\n\tconst targetParent = getParentElement( target );\n\n\tscrollAncestorsToShowRect( targetParent, () => {\n\t\treturn new Rect( target );\n\t} );\n}\n\n// TODO: Using a property value shorthand in the top of the file\n// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.\nObject.assign( utils, {\n\tscrollViewportToShowTarget,\n\tscrollAncestorsToShowTarget\n} );\n\n// Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\nfunction scrollWindowToShowRect( window, rect, viewportOffset ) {\n\tconst targetShiftedDownRect = rect.clone().moveBy( 0, viewportOffset );\n\tconst targetShiftedUpRect = rect.clone().moveBy( 0, -viewportOffset );\n\tconst viewportRect = new Rect( window ).excludeScrollbarsAndBorders();\n\n\tconst rects = [ targetShiftedUpRect, targetShiftedDownRect ];\n\n\tif ( !rects.every( rect => viewportRect.contains( rect ) ) ) {\n\t\tlet { scrollX, scrollY } = window;\n\n\t\tif ( isAbove( targetShiftedUpRect, viewportRect ) ) {\n\t\t\tscrollY -= viewportRect.top - rect.top + viewportOffset;\n\t\t} else if ( isBelow( targetShiftedDownRect, viewportRect ) ) {\n\t\t\tscrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n\t\t}\n\n\t\t// TODO: Web browsers scroll natively to place the target in the middle\n\t\t// of the viewport. It's not a very popular case, though.\n\t\tif ( isLeftOf( rect, viewportRect ) ) {\n\t\t\tscrollX -= viewportRect.left - rect.left + viewportOffset;\n\t\t} else if ( isRightOf( rect, viewportRect ) ) {\n\t\t\tscrollX += rect.right - viewportRect.right + viewportOffset;\n\t\t}\n\n\t\twindow.scrollTo( scrollX, scrollY );\n\t}\n}\n\n// Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\nfunction scrollAncestorsToShowRect( parent, getRect ) {\n\tconst parentWindow = getWindow( parent );\n\tlet parentRect, targetRect;\n\n\twhile ( parent != parentWindow.document.body ) {\n\t\ttargetRect = getRect();\n\t\tparentRect = new Rect( parent ).excludeScrollbarsAndBorders();\n\n\t\tif ( !parentRect.contains( targetRect ) ) {\n\t\t\tif ( isAbove( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop -= parentRect.top - targetRect.top;\n\t\t\t} else if ( isBelow( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop += targetRect.bottom - parentRect.bottom;\n\t\t\t}\n\n\t\t\tif ( isLeftOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft -= parentRect.left - targetRect.left;\n\t\t\t} else if ( isRightOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft += targetRect.right - parentRect.right;\n\t\t\t}\n\t\t}\n\n\t\tparent = parent.parentNode;\n\t}\n}\n\n// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isBelow( firstRect, secondRect ) {\n\treturn firstRect.bottom > secondRect.bottom;\n}\n\n// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isAbove( firstRect, secondRect ) {\n\treturn firstRect.top < secondRect.top;\n}\n\n// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isLeftOf( firstRect, secondRect ) {\n\treturn firstRect.left < secondRect.left;\n}\n\n// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isRightOf( firstRect, secondRect ) {\n\treturn firstRect.right > secondRect.right;\n}\n\n// Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {Window}\nfunction getWindow( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\treturn elementOrRange.startContainer.ownerDocument.defaultView;\n\t} else {\n\t\treturn elementOrRange.ownerDocument.defaultView;\n\t}\n}\n\n// Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {HTMLelement}\nfunction getParentElement( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\tlet parent = elementOrRange.commonAncestorContainer;\n\n\t\t// If a Range is attached to the Text, use the closest element ancestor.\n\t\tif ( isText( parent ) ) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn parent;\n\t} else {\n\t\treturn elementOrRange.parentNode;\n\t}\n}\n\n// Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\nfunction getRectRelativeToWindow( target, relativeWindow ) {\n\tconst targetWindow = getWindow( target );\n\tconst rect = new Rect( target );\n\n\tif ( targetWindow === relativeWindow ) {\n\t\treturn rect;\n\t} else {\n\t\tlet currentWindow = targetWindow;\n\n\t\twhile ( currentWindow != relativeWindow ) {\n\t\t\tconst frame = currentWindow.frameElement;\n\t\t\tconst frameRect = new Rect( frame ).excludeScrollbarsAndBorders();\n\n\t\t\trect.moveBy( frameRect.left, frameRect.top );\n\n\t\t\tcurrentWindow = currentWindow.parent;\n\t\t}\n\t}\n\n\treturn rect;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/view\n */\n\nimport Document from './document';\nimport Writer from './writer';\nimport Renderer from './renderer';\nimport DomConverter from './domconverter';\n\nimport MutationObserver from './observer/mutationobserver';\nimport KeyObserver from './observer/keyobserver';\nimport FakeSelectionObserver from './observer/fakeselectionobserver';\nimport SelectionObserver from './observer/selectionobserver';\nimport FocusObserver from './observer/focusobserver';\nimport CompositionObserver from './observer/compositionobserver';\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { scrollViewportToShowTarget } from '@ckeditor/ckeditor5-utils/src/dom/scroll';\nimport { injectUiElementHandling } from './uielement';\nimport { injectQuirksHandling } from './filler';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Editor's view controller class. Its main responsibility is DOM - View management for editing purposes, to provide\n * abstraction over the DOM structure and events and hide all browsers quirks.\n *\n * View controller renders view document to DOM whenever view structure changes. To determine when view can be rendered,\n * all changes need to be done using the {@link module:engine/view/view~View#change} method, using\n * {@link module:engine/view/writer~Writer}:\n *\n *\t\tview.change( writer => {\n *\t\t\twriter.insert( position, writer.createText( 'foo' ) );\n *\t\t} );\n *\n * View controller also register {@link module:engine/view/observer/observer~Observer observers} which observes changes\n * on DOM and fire events on the {@link module:engine/view/document~Document Document}.\n * Note that the following observers are added by the class constructor and are always available:\n *\n * * {@link module:engine/view/observer/mutationobserver~MutationObserver},\n * * {@link module:engine/view/observer/selectionobserver~SelectionObserver},\n * * {@link module:engine/view/observer/focusobserver~FocusObserver},\n * * {@link module:engine/view/observer/keyobserver~KeyObserver},\n * * {@link module:engine/view/observer/fakeselectionobserver~FakeSelectionObserver}.\n * * {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n *\n * This class also {@link module:engine/view/view~View#attachDomRoot bind DOM and View elements}.\n *\n * If you do not need full DOM - View management, and want to only transform the tree of view elements to the DOM\n * elements you do not need this controller, you can use the {@link module:engine/view/domconverter~DomConverter DomConverter}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class View {\n\tconstructor() {\n\t\t/**\n\t\t * Instance of the {@link module:engine/view/document~Document} associated with this view controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document} module:engine/view/view~View#document\n\t\t */\n\t\tthis.document = new Document();\n\n\t\t/**\n\t\t * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} use by\n\t\t * {@link module:engine/view/view~View#renderer renderer}\n\t\t * and {@link module:engine/view/observer/observer~Observer observers}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter} module:engine/view/view~View#domConverter\n\t\t */\n\t\tthis.domConverter = new DomConverter();\n\n\t\t/**\n\t\t * Instance of the {@link module:engine/view/renderer~Renderer renderer}.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/view/renderer~Renderer} module:engine/view/view~View#renderer\n\t\t */\n\t\tthis._renderer = new Renderer( this.domConverter, this.document.selection );\n\t\tthis._renderer.bind( 'isFocused' ).to( this.document );\n\n\t\t/**\n\t\t * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map} module:engine/view/view~View#domRoots\n\t\t */\n\t\tthis.domRoots = new Map();\n\n\t\t/**\n\t\t * Map of registered {@link module:engine/view/observer/observer~Observer observers}.\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<Function, module:engine/view/observer/observer~Observer>} module:engine/view/view~View#_observers\n\t\t */\n\t\tthis._observers = new Map();\n\n\t\t/**\n\t\t * Is set to `true` when {@link #change view changes} are currently in progress.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean} module:engine/view/view~View#_ongoingChange\n\t\t */\n\t\tthis._ongoingChange = false;\n\n\t\t/**\n\t\t * Used to prevent calling {@link #render} and {@link #change} during rendering view to the DOM.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean} module:engine/view/view~View#_renderingInProgress\n\t\t */\n\t\tthis._renderingInProgress = false;\n\n\t\t/**\n\t\t * Used to prevent calling {@link #render} and {@link #change} during rendering view to the DOM.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean} module:engine/view/view~View#_renderingInProgress\n\t\t */\n\t\tthis._postFixersInProgress = false;\n\n\t\t/**\n\t\t * Writer instance used in {@link #change change method) callbacks.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/writer~Writer} module:engine/view/view~View#_writer\n\t\t */\n\t\tthis._writer = new Writer( this.document );\n\n\t\t// Add default observers.\n\t\tthis.addObserver( MutationObserver );\n\t\tthis.addObserver( SelectionObserver );\n\t\tthis.addObserver( FocusObserver );\n\t\tthis.addObserver( KeyObserver );\n\t\tthis.addObserver( FakeSelectionObserver );\n\t\tthis.addObserver( CompositionObserver );\n\n\t\t// Inject quirks handlers.\n\t\tinjectQuirksHandling( this );\n\t\tinjectUiElementHandling( this );\n\n\t\t// Use 'normal' priority so that rendering is performed as first when using that priority.\n\t\tthis.on( 'render', () => {\n\t\t\tthis._render();\n\n\t\t\t// Informs that layout has changed after render.\n\t\t\tthis.document.fire( 'layoutChanged' );\n\t\t} );\n\t}\n\n\t/**\n\t * Attaches DOM root element to the view element and enable all observers on that element.\n\t * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized with the view\n\t * what means that all child nodes will be removed and replaced with content of the view root.\n\t *\n\t * This method also will change view element name as the same as tag name of given dom root.\n\t * Name is always transformed to lower case.\n\t *\n\t * @param {Element} domRoot DOM root element.\n\t * @param {String} [name='main'] Name of the root.\n\t */\n\tattachDomRoot( domRoot, name = 'main' ) {\n\t\tconst viewRoot = this.document.getRoot( name );\n\n\t\t// Set view root name the same as DOM root tag name.\n\t\tviewRoot._name = domRoot.tagName.toLowerCase();\n\n\t\tthis.domRoots.set( name, domRoot );\n\t\tthis.domConverter.bindElements( domRoot, viewRoot );\n\t\tthis._renderer.markToSync( 'children', viewRoot );\n\t\tthis._renderer.domDocuments.add( domRoot.ownerDocument );\n\n\t\tviewRoot.on( 'change:children', ( evt, node ) => this._renderer.markToSync( 'children', node ) );\n\t\tviewRoot.on( 'change:attributes', ( evt, node ) => this._renderer.markToSync( 'attributes', node ) );\n\t\tviewRoot.on( 'change:text', ( evt, node ) => this._renderer.markToSync( 'text', node ) );\n\n\t\tfor ( const observer of this._observers.values() ) {\n\t\t\tobserver.observe( domRoot, name );\n\t\t}\n\t}\n\n\t/**\n\t * Gets DOM root element.\n\t *\n\t * @param {String} [name='main']  Name of the root.\n\t * @returns {Element} DOM root element instance.\n\t */\n\tgetDomRoot( name = 'main' ) {\n\t\treturn this.domRoots.get( name );\n\t}\n\n\t/**\n\t * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it\n\t * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future\n\t * {@link #domRoots DOM roots}.\n\t *\n\t * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only\n\t * when registered for the first time. This means that features and other components can register a single observer\n\t * multiple times without caring whether it has been already added or not.\n\t *\n\t * @param {Function} Observer The constructor of an observer to add.\n\t * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.\n\t * @returns {module:engine/view/observer/observer~Observer} Added observer instance.\n\t */\n\taddObserver( Observer ) {\n\t\tlet observer = this._observers.get( Observer );\n\n\t\tif ( observer ) {\n\t\t\treturn observer;\n\t\t}\n\n\t\tobserver = new Observer( this );\n\n\t\tthis._observers.set( Observer, observer );\n\n\t\tfor ( const [ name, domElement ] of this.domRoots ) {\n\t\t\tobserver.observe( domElement, name );\n\t\t}\n\n\t\tobserver.enable();\n\n\t\treturn observer;\n\t}\n\n\t/**\n\t * Returns observer of the given type or `undefined` if such observer has not been added yet.\n\t *\n\t * @param {Function} Observer The constructor of an observer to get.\n\t * @returns {module:engine/view/observer/observer~Observer|undefined} Observer instance or undefined.\n\t */\n\tgetObserver( Observer ) {\n\t\treturn this._observers.get( Observer );\n\t}\n\n\t/**\n\t * Disables all added observers.\n\t */\n\tdisableObservers() {\n\t\tfor ( const observer of this._observers.values() ) {\n\t\t\tobserver.disable();\n\t\t}\n\t}\n\n\t/**\n\t * Enables all added observers.\n\t */\n\tenableObservers() {\n\t\tfor ( const observer of this._observers.values() ) {\n\t\t\tobserver.enable();\n\t\t}\n\t}\n\n\t/**\n\t * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the\n\t * caret, if not already visible to the user.\n\t */\n\tscrollToTheSelection() {\n\t\tconst range = this.document.selection.getFirstRange();\n\n\t\tif ( range ) {\n\t\t\tscrollViewportToShowTarget( {\n\t\t\t\ttarget: this.domConverter.viewRangeToDom( range ),\n\t\t\t\tviewportOffset: 20\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}\n\t * that is currently having selection inside.\n\t */\n\tfocus() {\n\t\tif ( !this.document.isFocused ) {\n\t\t\tconst editable = this.document.selection.editableElement;\n\n\t\t\tif ( editable ) {\n\t\t\t\tthis.domConverter.focus( editable );\n\t\t\t\tthis.render();\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Before focusing view document, selection should be placed inside one of the view's editables.\n\t\t\t\t * Normally its selection will be converted from model document (which have default selection), but\n\t\t\t\t * when using view document on its own, we need to manually place selection before focusing it.\n\t\t\t\t *\n\t\t\t\t * @error view-focus-no-selection\n\t\t\t\t */\n\t\t\t\tlog.warn( 'view-focus-no-selection: There is no selection in any editable to focus.' );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Change method is the primary way of changing the view. You should use it to modify any node in the view tree.\n\t * It makes sure that after all changes are made view is rendered to DOM. It prevents situations when DOM is updated\n\t * when view state is not yet correct. It allows to nest calls one inside another and still perform single rendering\n\t * after all changes are applied.\n\t *\n\t *\t\tview.change( writer => {\n\t *\t\t\twriter.insert( position1, writer.createText( 'foo' ) );\n\t *\n\t *\t\t\tview.change( writer => {\n\t *\t\t\t\twriter.insert( position2, writer.createText( 'bar' ) );\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.remove( range );\n\t *\t\t} );\n\t *\n\t * Change block is executed immediately.\n\t *\n\t * When the outermost change block is done and rendering to DOM is over it fires\n\t * {@link module:engine/view/view~View#event:render} event.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when\n\t * change block is used after rendering to DOM has started.\n\t *\n\t * @param {Function} callback Callback function which may modify the view.\n\t */\n\tchange( callback ) {\n\t\tif ( this._renderingInProgress || this._postFixersInProgress ) {\n\t\t\t/**\n\t\t\t * Thrown when there is an attempt to make changes to the view tree when it is in incorrect state. This may\n\t\t\t * cause some unexpected behaviour and inconsistency between the DOM and the view.\n\t\t\t * This may be caused by:\n\t\t\t *\n\t\t\t * * calling {@link #change} or {@link #render} during rendering process,\n\t\t\t * * calling {@link #change} or {@link #render} inside of\n\t\t\t *   {@link module:engine/view/document~Document#registerPostFixer post-fixer function}.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'cannot-change-view-tree: ' +\n\t\t\t\t'Attempting to make changes to the view when it is in incorrect state: rendering or post-fixers are in progress. ' +\n\t\t\t\t'This may cause some unexpected behaviour and inconsistency between the DOM and the view.'\n\t\t\t);\n\t\t}\n\n\t\t// Recursive call to view.change() method - execute listener immediately.\n\t\tif ( this._ongoingChange ) {\n\t\t\tcallback( this._writer );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// This lock will assure that all recursive calls to view.change() will end up in same block - one \"render\"\n\t\t// event for all nested calls.\n\t\tthis._ongoingChange = true;\n\t\tcallback( this._writer );\n\t\tthis._ongoingChange = false;\n\n\t\t// Execute all document post-fixers after the change.\n\t\tthis._postFixersInProgress = true;\n\t\tthis.document._callPostFixers( this._writer );\n\t\tthis._postFixersInProgress = false;\n\n\t\tthis.fire( 'render' );\n\t}\n\n\t/**\n\t * Renders {@link module:engine/view/document~Document view document} to DOM. If any view changes are\n\t * currently in progress, rendering will start after all {@link #change change blocks} are processed.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when\n\t * trying to re-render when rendering to DOM has already started.\n\t */\n\trender() {\n\t\tthis.change( () => {} );\n\t}\n\n\t/**\n\t * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n\t */\n\tdestroy() {\n\t\tfor ( const observer of this._observers.values() ) {\n\t\t\tobserver.destroy();\n\t\t}\n\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled\n\t * before rendering and re-enabled after that.\n\t *\n\t * @private\n\t */\n\t_render() {\n\t\tthis._renderingInProgress = true;\n\t\tthis.disableObservers();\n\t\tthis._renderer.render();\n\t\tthis.enableObservers();\n\t\tthis._renderingInProgress = false;\n\t}\n\n\t/**\n\t * Fired after a topmost {@link module:engine/view/view~View#change change block} and all\n\t * {@link module:engine/view/document~Document#registerPostFixer post-fixers} are executed.\n\t *\n\t * Actual rendering is performed as a first listener on 'normal' priority.\n\t *\n\t *\t\tview.on( 'render', () => {\n\t *\t\t\t// Rendering to the DOM is complete.\n\t *\t\t} );\n\t *\n\t * This event is useful when you want to update interface elements after the rendering, e.g. position of the\n\t * balloon panel. If you wants to change view structure use\n\t * {@link module:engine/view/document~Document#registerPostFixer post-fixers}.\n\t *\n\t * @event module:engine/view/view~View#event:render\n\t */\n}\n\nmix( View, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/tomap\n */\n\nimport isPlainObject from './lib/lodash/isPlainObject';\nimport objectToMap from './objecttomap';\n\n/**\n * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.\n *\n *\t\tmap = toMap( { 'foo': 1, 'bar': 2 } );\n *\t\tmap = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );\n *\t\tmap = toMap( anotherMap );\n *\n * @param {Object|Iterable} data Object or iterable to transform.\n * @returns {Map} Map created from data.\n */\nexport default function toMap( data ) {\n\tif ( isPlainObject( data ) ) {\n\t\treturn objectToMap( data );\n\t} else {\n\t\treturn new Map( data );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/node\n */\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\nexport default class Node {\n\t/**\n\t * Creates a model node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t *\n\t * @abstract\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( attrs ) {\n\t\t/**\n\t\t * Parent of this node. It could be {@link module:engine/model/element~Element}\n\t\t * or {@link module:engine/model/documentfragment~DocumentFragment}.\n\t\t * Equals to `null` if the node has no parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Attributes set on this node.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/node~Node#_attrs\n\t\t */\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Index of this node in it's parent or `null` if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.' );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n\t * of all it's previous siblings. Equals to `null` if node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|Null}\n\t */\n\tget startOffset() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.' );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n\t * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n\t * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n\t * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n\t * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n\t * Equals to `null` if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget endOffset() {\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.startOffset + this.offsetSize;\n\t}\n\n\t/**\n\t * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n\t * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * {@link module:engine/model/document~Document Document} that owns this node or `null` if the node has no parent or is inside\n\t * a {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/document~Document|null}\n\t */\n\tget document() {\n\t\t// This is a top element of a sub-tree.\n\t\tif ( this.root == this ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Root may be `DocumentFragment` which does not have document property.\n\t\treturn this.root.document || null;\n\t}\n\n\t/**\n\t * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n\t * create {@link module:engine/model/position~Position Position} instance.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.startOffset );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/model/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Checks if the node has an attribute with given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Converts `Node` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = {};\n\n\t\tif ( this._attrs.size ) {\n\t\t\tjson.attributes = [ ...this._attrs ];\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n\t */\n\t_clone() {\n\t\treturn new Node( this._attrs );\n\t}\n\n\t/**\n\t * Removes this node from it's parent.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._attrs.set( key, value );\n\t}\n\n\t/**\n\t * Removes all attributes from the node and sets given attributes.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttributes\n\t * @protected\n\t * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\t_setAttributesTo( attrs ) {\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to remove.\n\t * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n\t */\n\t_removeAttribute( key ) {\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Removes all attributes from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#clearAttributes\n\t * @protected\n\t */\n\t_clearAttributes() {\n\t\tthis._attrs.clear();\n\t}\n\n\t/**\n\t * Checks whether given model tree object is of given type.\n\t *\n\t * This method is useful when processing model tree objects that are of unknown type. For example, a function\n\t * may return {@link module:engine/model/documentfragment~DocumentFragment} or {@link module:engine/model/node~Node}\n\t * that can be either text node or element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tobj.is( 'node' ); // true for any node, false for document fragment and text fragment\n\t *\t\tobj.is( 'documentFragment' ); // true for document fragment, false for any node\n\t *\t\tobj.is( 'element' ); // true for any element, false for text node or document fragment\n\t *\t\tobj.is( 'element', 'paragraph' ); // true only for element which name is 'paragraph'\n\t *\t\tobj.is( 'paragraph' ); // shortcut for obj.is( 'element', 'paragraph' )\n\t *\t\tobj.is( 'text' ); // true for text node, false for element and document fragment\n\t *\t\tobj.is( 'textProxy' ); // true for text proxy object\n\t *\n\t * @method #is\n\t * @param {'element'|'rootElement'|'text'|'textProxy'|'documentFragment'} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'node';\n\t}\n}\n\n/**\n * The node's parent does not contain this node.\n *\n * This error may be thrown from corrupted trees.\n *\n * @error model-node-not-found-in-parent\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/text\n */\n\nimport Node from './node';\n\n/**\n * Model text node. Type of {@link module:engine/model/node~Node node} that contains {@link module:engine/model/text~Text#data text data}.\n *\n * **Important:** see {@link module:engine/model/node~Node} to read about restrictions using `Text` and `Node` API.\n *\n * **Note:** keep in mind that `Text` instances might indirectly got removed from model tree when model is changed.\n * This happens when {@link module:engine/model/writer~Writer model writer} is used to change model and the text node is merged with\n * another text node. Then, both text nodes are removed and a new text node is inserted into the model. Because of\n * this behavior, keeping references to `Text` is not recommended. Instead, consider creating\n * {@link module:engine/model/liveposition~LivePosition live position} placed before the text node.\n *\n * @extends {module:engine/model/node~Node}\n */\nexport default class Text extends Node {\n\t/**\n\t * Creates a text node.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createText} method instead.\n\t *\n\t * @protected\n\t * @param {String} data Node's text.\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( data, attrs ) {\n\t\tsuper( attrs );\n\n\t\t/**\n\t\t * Text data contained in this text node.\n\t\t *\n\t\t * @protected\n\t\t * @type {String}\n\t\t */\n\t\tthis._data = data || '';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget offsetSize() {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * Returns a text data contained in the node.\n\t *\n\t * @returns {String}\n\t */\n\tget data() {\n\t\treturn this._data;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type ) {\n\t\treturn type == 'text' || super.is( type );\n\t}\n\n\t/**\n\t * Converts `Text` instance to plain object and returns it.\n\t *\n\t * @returns {Object} `Text` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.data = this.data;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/text~Text} `Text` instance created using given plain object.\n\t */\n\t_clone() {\n\t\treturn new Text( this.data, this.getAttributes() );\n\t}\n\n\t/**\n\t * Creates a `Text` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Text`.\n\t * @returns {module:engine/model/text~Text} `Text` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\treturn new Text( json.data, json.attributes );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/textproxy\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.\n *\n * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,\n * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems\n * getting items}\n * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.\n * `TextProxy` solves this issue.\n *\n * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed\n * on model nodes.\n *\n * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.\n * See {@link module:engine/model/textproxy~TextProxy#isPartial}.\n *\n * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a\n * parameter of methods.\n *\n * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`\n * use {@link module:engine/model/writer~Writer model writer API}.\n *\n * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is\n * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when\n * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live\n * position}.\n *\n * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create\n * an instance of this class by your own.\n */\nexport default class TextProxy {\n\t/**\n\t * Creates a text proxy.\n\t *\n\t * @protected\n\t * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.\n\t * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy\n\t * starts.\n\t * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.\n\t * @constructor\n\t */\n\tconstructor( textNode, offsetInText, length ) {\n\t\t/**\n\t\t * Text node which part is represented by this text proxy.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/text~Text}\n\t\t */\n\t\tthis.textNode = textNode;\n\n\t\tif ( offsetInText < 0 || offsetInText > textNode.offsetSize ) {\n\t\t\t/**\n\t\t\t * Given `offsetInText` value is incorrect.\n\t\t\t *\n\t\t\t * @error model-textproxy-wrong-offsetintext\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.' );\n\t\t}\n\n\t\tif ( length < 0 || offsetInText + length > textNode.offsetSize ) {\n\t\t\t/**\n\t\t\t * Given `length` value is incorrect.\n\t\t\t *\n\t\t\t * @error model-textproxy-wrong-length\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-textproxy-wrong-length: Given length value is incorrect.' );\n\t\t}\n\n\t\t/**\n\t\t * Text data represented by this text proxy.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.data = textNode.data.substring( offsetInText, offsetInText + length );\n\n\t\t/**\n\t\t * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.offsetInText = offsetInText;\n\t}\n\n\t/**\n\t * Offset at which this text proxy starts in it's parent.\n\t *\n\t * @see module:engine/model/node~Node#startOffset\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget startOffset() {\n\t\treturn this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;\n\t}\n\n\t/**\n\t * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.\n\t *\n\t * @see module:engine/model/node~Node#offsetSize\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * Offset at which this text proxy ends in it's parent.\n\t *\n\t * @see module:engine/model/node~Node#endOffset\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget endOffset() {\n\t\treturn this.startOffset !== null ? this.startOffset + this.offsetSize : null;\n\t}\n\n\t/**\n\t * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}\n\t * (`true`) or the whole text node (`false`).\n\t *\n\t * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}\n\t * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to\n\t * text node size.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isPartial() {\n\t\treturn this.offsetSize !== this.textNode.offsetSize;\n\t}\n\n\t/**\n\t * Parent of this text proxy, which is same as parent of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tget parent() {\n\t\treturn this.textNode.parent;\n\t}\n\n\t/**\n\t * Root of this text proxy, which is same as root of text node represented by this text proxy.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.textNode.root;\n\t}\n\n\t/**\n\t * {@link module:engine/model/document~Document Document} that owns text node represented by this text proxy or `null` if the text node\n\t * has no parent or is inside a {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/document~Document|null}\n\t */\n\tget document() {\n\t\treturn this.textNode.document;\n\t}\n\n\t/**\n\t * Checks whether given model tree object is of given type.\n\t *\n\t * Read more in {@link module:engine/model/node~Node#is}.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'textProxy';\n\t}\n\n\t/**\n\t * Gets path to this text proxy.\n\t *\n\t * @see module:engine/model/node~Node#getPath\n\t * @returns {Array.<Number>}\n\t */\n\tgetPath() {\n\t\tconst path = this.textNode.getPath();\n\n\t\tif ( path.length > 0 ) {\n\t\t\tpath[ path.length - 1 ] += this.offsetInText;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this text proxy.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Checks if this text proxy has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this.textNode.hasAttribute( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this.textNode.getAttribute( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two\n\t * items. First one is attribute key and second is attribute value.\n\t *\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this.textNode.getAttributes();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this.textNode.getAttributeKeys();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/nodelist\n */\n\nimport Node from './node';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Provides an interface to operate on a list of {@link module:engine/model/node~Node nodes}. `NodeList` is used internally\n * in classes like {@link module:engine/model/element~Element Element}\n * or {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n */\nexport default class NodeList {\n\t/**\n\t * Creates an empty node list.\n\t *\n\t * @protected\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes contained in this node list.\n\t */\n\tconstructor( nodes ) {\n\t\t/**\n\t\t * Nodes contained in this node list.\n\t\t *\n\t\t * @private\n\t\t * @member {Array.<module:engine/model/node~Node>}\n\t\t */\n\t\tthis._nodes = [];\n\n\t\tif ( nodes ) {\n\t\t\tthis._insertNodes( 0, nodes );\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all nodes contained inside this node list.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._nodes[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Number of nodes contained inside this node list.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._nodes.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\t}\n\n\t/**\n\t * Gets the node at the given index. Returns `null` if incorrect index was passed.\n\t *\n\t * @param {Number} index Index of node.\n\t * @returns {module:engine/model/node~Node|null} Node at given index.\n\t */\n\tgetNode( index ) {\n\t\treturn this._nodes[ index ] || null;\n\t}\n\n\t/**\n\t * Returns an index of the given node. Returns `null` if given node is not inside this node list.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's index.\n\t */\n\tgetNodeIndex( node ) {\n\t\tconst index = this._nodes.indexOf( node );\n\n\t\treturn index == -1 ? null : index;\n\t}\n\n\t/**\n\t * Returns the starting offset of given node. Starting offset is equal to the sum of\n\t * {module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.\n\t *\n\t * @param {module:engine/model/node~Node} node Node to look for.\n\t * @returns {Number|null} Node's starting offset.\n\t */\n\tgetNodeStartOffset( node ) {\n\t\tconst index = this.getNodeIndex( node );\n\n\t\treturn index === null ? null : this._nodes.slice( 0, index ).reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\t}\n\n\t/**\n\t * Converts index to offset in node list.\n\t *\n\t * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.\n\t *\n\t * @param {Number} index Node's index.\n\t * @returns {Number} Node's starting offset.\n\t */\n\tindexToOffset( index ) {\n\t\tif ( index == this._nodes.length ) {\n\t\t\treturn this.maxOffset;\n\t\t}\n\n\t\tconst node = this._nodes[ index ];\n\n\t\tif ( !node ) {\n\t\t\t/**\n\t\t\t * Given index cannot be found in the node list.\n\t\t\t *\n\t\t\t * @error nodelist-index-out-of-bounds\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.' );\n\t\t}\n\n\t\treturn this.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Converts offset in node list to index.\n\t *\n\t * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number} Index of a node that occupies given offset.\n\t */\n\toffsetToIndex( offset ) {\n\t\tlet totalOffset = 0;\n\n\t\tfor ( const node of this._nodes ) {\n\t\t\tif ( offset >= totalOffset && offset < totalOffset + node.offsetSize ) {\n\t\t\t\treturn this.getNodeIndex( node );\n\t\t\t}\n\n\t\t\ttotalOffset += node.offsetSize;\n\t\t}\n\n\t\tif ( totalOffset != offset ) {\n\t\t\t/**\n\t\t\t * Given offset cannot be found in the node list.\n\t\t\t *\n\t\t\t * @error model-nodelist-offset-out-of-bounds\n\t\t\t * @param {Number} offset\n\t\t\t * @param {module:engine/model/nodelist~NodeList} nodeList Stringified node list.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.', {\n\t\t\t\toffset,\n\t\t\t\tnodeList: this\n\t\t\t} );\n\t\t}\n\n\t\treturn this.length;\n\t}\n\n\t/**\n\t * Inserts given nodes at given index.\n\t *\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.\n\t */\n\t_insertNodes( index, nodes ) {\n\t\t// Validation.\n\t\tfor ( const node of nodes ) {\n\t\t\tif ( !( node instanceof Node ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to insert an object which is not a Node instance.\n\t\t\t\t *\n\t\t\t\t * @error nodelist-insertNodes-not-node\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.' );\n\t\t\t}\n\t\t}\n\n\t\tthis._nodes.splice( index, 0, ...nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index.\n\t *\n\t * @protected\n\t * @param {Number} indexStart Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeNodes( indexStart, howMany = 1 ) {\n\t\treturn this._nodes.splice( indexStart, howMany );\n\t}\n\n\t/**\n\t * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes\n\t * are also converted to their plain object representation.\n\t *\n\t * @returns {Array.<module:engine/model/node~Node>} `NodeList` instance converted to `Array`.\n\t */\n\ttoJSON() {\n\t\treturn this._nodes.map( node => node.toJSON() );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/element\n */\n\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends {module:engine/model/node~Node}\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a model element.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n\t *\n\t * @protected\n\t * @param {String} name Element's name.\n\t * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * One or more nodes to be inserted as children of created element.\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( attrs );\n\n\t\t/**\n\t\t * Element name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} module:engine/model/element~Element#name\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * List of children nodes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Number of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Checks whether given model tree object is of given type.\n\t *\n\t *\t\tobj.name; // 'listItem'\n\t *\t\tobj instanceof Element; // true\n\t *\n\t *\t\tobj.is( 'element' ); // true\n\t *\t\tobj.is( 'listItem' ); // true\n\t *\t\tobj.is( 'element', 'listItem' ); // true\n\t *\t\tobj.is( 'text' ); // false\n\t *\t\tobj.is( 'element', 'image' ); // false\n\t *\n\t * Read more in {@link module:engine/model/node~Node#is}.\n\t *\n\t * @param {String} type Type to check when `name` parameter is present.\n\t * Otherwise, it acts like the `name` parameter.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'element' || type == this.name || super.is( type );\n\t\t} else {\n\t\t\treturn type == 'element' && name == this.name;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this element's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's index in this element.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst divElement = new Element( [ textNode, pElement ] );\n\t *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number}\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n\t *\n\t * @returns {Object} `Element` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.name = this.name;\n\n\t\tif ( this._children.length > 0 ) {\n\t\t\tjson.children = [];\n\n\t\t\tfor ( const node of this._children ) {\n\t\t\t\tjson.children.push( node.toJSON() );\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is removed.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\t_clone( deep = false ) {\n\t\tconst children = deep ? Array.from( this._children ).map( node => node._clone( true ) ) : null;\n\n\t\treturn new Element( this.name, this.getAttributes(), children );\n\t}\n\n\t/**\n\t * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n\t *\n\t * @see module:engine/model/writer~Writer#append\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n\t */\n\t_appendChild( nodes ) {\n\t\tthis._insertChild( this.childCount, nodes );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this element.\n\t *\n\t * @see module:engine/model/writer~Writer#insert\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index and sets\n\t * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `Element` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `Element`.\n\t * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tlet children = null;\n\n\t\tif ( json.children ) {\n\t\t\tchildren = [];\n\n\t\t\tfor ( const child of json.children ) {\n\t\t\t\tif ( child.name ) {\n\t\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Element( json.name, json.attributes, children );\n\t}\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/treewalker\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Element from './element';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} [options={}] Object with configuration.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n\t * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n\t * {@link module:engine/model/textproxy~TextProxy} (`false`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n\t\t\t *\n\t\t\t * @error model-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.' );\n\t\t}\n\n\t\tconst direction = options.direction || 'forward';\n\n\t\tif ( direction != 'forward' && direction != 'backward' ) {\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',\n\t\t\t\t{ direction }\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. This is always static position, even if the initial position was a\n\t\t * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n\t\t * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n\t\t * is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = Position.createFromPosition( options.startPosition );\n\t\t} else {\n\t\t\tthis.position = Position.createFromPosition( this.boundaries[ this.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t/**\n\t\t * Flag indicating whether all consecutive characters with the same attributes should be\n\t\t * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n\t\t * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n\t\t * be returned once, while if the option is `false` they might be returned twice:\n\t\t * for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\n\t\t/**\n\t\t * Parent of the most recently visited node. Cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/treewalker~TreeWalker#_visitedParent\n\t\t */\n\t\tthis._visitedParent = this.position.parent;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n\t * \t\twalker.skip( () => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition, prevVisitedParent;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\t\t\tprevVisitedParent = this._visitedParent;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t\tthis._visitedParent = prevVisitedParent;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = Position.createFromPosition( this.position );\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.maxOffset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\tconst node = position.textNode ? position.textNode : position.nodeAfter;\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\t// Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n\t\t\t\tposition.path.push( 0 );\n\t\t\t\tthis._visitedParent = node;\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.endOffset;\n\n\t\t\t\tif ( this._boundaryEndParent == parent && this.boundaries.end.offset < offset ) {\n\t\t\t\t\toffset = this.boundaries.end.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = offset - position.offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode, charactersCount );\n\n\t\t\tposition.offset += charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tposition.offset++;\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = Position.createFromPosition( this.position );\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before current position\n\t\tconst node = position.textNode ? position.textNode : position.nodeBefore;\n\n\t\tif ( node instanceof Element ) {\n\t\t\tposition.offset--;\n\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition.path.push( node.maxOffset );\n\t\t\t\tthis.position = position;\n\t\t\t\tthis._visitedParent = node;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.startOffset;\n\n\t\t\t\tif ( this._boundaryStartParent == parent && this.boundaries.start.offset > offset ) {\n\t\t\t\t\toffset = this.boundaries.start.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = position.offset - offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode - charactersCount, charactersCount );\n\n\t\t\tposition.offset -= charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\treturn formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n}\n\nfunction formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\treturn {\n\t\tdone: false,\n\t\tvalue: {\n\t\t\ttype,\n\t\t\titem,\n\t\t\tpreviousPosition,\n\t\t\tnextPosition,\n\t\t\tlength\n\t\t}\n\t};\n}\n\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in\n * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).\n *\n * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item. Note that it is more efficient to use this position then calculate the position before\n * the node using {@link module:engine/model/position~Position.createBefore}. It is also more efficient to get the\n * position after node by shifting `previousPosition` by `length`, using {@link module:engine/model/position~Position#getShiftedBy},\n * then calculate the position using {@link module:engine/model/position~Position.createAfter}.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is undefined.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport last from '@ckeditor/ckeditor5-utils/src/lib/lodash/last';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Text from './text';\n\n/**\n * Represents a position in the model tree.\n *\n * **Note:** Position is based on offsets, not indexes. This means that position in element containing two text nodes\n * with data `foo` and `bar`, position between them has offset `3`, not `1`.\n * See {@link module:engine/model/position~Position#path} for more.\n *\n * Since position in a model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing elements.\n * This requirement is important for {@link module:engine/model/operation/transform~transform operational transformation}.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after document got changed.\n *\n * When changes are applied to model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t */\n\tconstructor( root, path ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-root-invalid: Position root invalid.' );\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: Position path must be an array with at least one item.', { path } );\n\t\t}\n\n\t\t// Normalize the root and path (if element was passed).\n\t\tpath = root.getPath().concat( path );\n\t\troot = root.root;\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn last( this.path );\n\t}\n\n\t/**\n\t * @param {Number} newOffset\n\t */\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\tconst node = this.parent.getChild( this.index );\n\n\t\treturn ( node instanceof Text && node.startOffset < this.offset ) ? node : null;\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index ) : null;\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {Node}\n\t */\n\tget nodeBefore() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index - 1 ) : null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method returns the parent path even if the parent does not exists.\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = Position.createFromPosition( this );\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * **Note:** this method traverses model document so it can be only used when range is up-to-date with model document.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position.createFromPosition( this );\n\t\t\t\tright = Position.createFromPosition( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position.createFromPosition( otherPosition );\n\t\t\t\tright = Position.createFromPosition( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position.createFromPosition( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} insertBefore Flag indicating whether nodes are inserted before or after `insertPosition`.\n\t * This is important only when `insertPosition` and this position are same. If that is the case and the flag is\n\t * set to `true`, this position will get transformed. If the flag is set to `false`, it won't.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, insertBefore ) {\n\t\tconst transformed = Position.createFromPosition( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && insertBefore ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @param {Boolean} insertBefore Flag indicating whether moved nodes are pasted before or after `insertPosition`.\n\t * This is important only when `targetPosition` and this position are same. If that is the case and the flag is\n\t * set to `true`, this position will get transformed by range insertion. If the flag is set to `false`, it won't.\n\t * @param {Boolean} [sticky] Flag indicating whether this position \"sticks\" to range, that is if it should be moved\n\t * with the moved range if it is equal to one of range's boundaries.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany, insertBefore, sticky ) {\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tlet transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\t// Then we update target position, as it could be affected by nodes removal too.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( transformed === null || ( sticky && transformed.isEqual( sourcePosition ) ) ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\ttransformed = this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\ttransformed = transformed._getTransformedByInsertion( targetPosition, howMany, insertBefore );\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = new Position( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = new Position( root, [ 2, 2 ] );\n\t *\t\tlet target = new Position( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position.createFromPosition( target );\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = combined.path.concat( this.path.slice( i + 1 ) );\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link module:engine/model/position~Position.createBefore},\n\t * * {@link module:engine/model/position~Position.createAfter},\n\t * * {@link module:engine/model/position~Position.createFromParentAndOffset},\n\t * * {@link module:engine/model/position~Position.createFromPosition}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tstatic createAt( itemOrPosition, offset ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn this.createFromPosition( itemOrPosition );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this.createBefore( node );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this.createAfter( node );\n\t\t\t} else if ( !offset ) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\treturn this.createFromParentAndOffset( node, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tstatic createAfter( item ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-after-root: You cannot make a position after root.', { root: item } );\n\t\t}\n\n\t\treturn this.createFromParentAndOffset( item.parent, item.endOffset );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tstatic createBefore( item ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-before-root: You cannot make a position before root.', { root: item } );\n\t\t}\n\n\t\treturn this.createFromParentAndOffset( item.parent, item.startOffset );\n\t}\n\n\t/**\n\t * Creates a new position from the parent element and an offset in that element.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent Position's parent.\n\t * @param {Number} offset Position's offset.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tstatic createFromParentAndOffset( parent, offset ) {\n\t\tif ( !parent.is( 'element' ) && !parent.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t *\n\t\t\t * @error model-position-parent-incorrect\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-parent-incorrect: Position parent have to be a element or document fragment.' );\n\t\t}\n\n\t\tconst path = parent.getPath();\n\n\t\tpath.push( offset );\n\n\t\treturn new this( parent.root, path );\n\t}\n\n\t/**\n\t * Creates a new position, which is equal to passed position.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to be cloned.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tstatic createFromPosition( position ) {\n\t\treturn new this( position.root, position.path.slice() );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\treturn new Position( doc.graveyard, json.path );\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path );\n\t}\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Range class. Range is iterable.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/model/position~Position Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.start = Position.createFromPosition( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.end = end ? Position.createFromPosition( end ) : Position.createFromPosition( start );\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/model/position~Position positions},\n\t * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n\t * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n\t *\n\t * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n\t * and `ignoreElementEnd` option set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is if {@link #start} and\n\t * {@link #end} positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link #start} position and\n\t * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n\t * in this range,`false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link ~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n\t *\n\t * @param {module:engine/model/item~Item} item Model item to check.\n\t */\n\tcontainsItem( item ) {\n\t\tconst pos = Position.createBefore( item );\n\n\t\treturn this.containsPosition( pos ) || this.start.isEqual( pos );\n\t}\n\n\t/**\n\t * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n\t * Returned array contains zero, one or two {@link ~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );\n\t *\t\tlet otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 5 ] ) );\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 3 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\totherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 4 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( Range.createFromRange( this ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );\n\t *\t\tlet otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 2 ] ) );\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 5 ] ) );\n\t *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n\t *\n\t * See an example of a model structure (`[` and `]` are range boundaries):\n\t *\n\t *\t\troot                                                            root\n\t *\t\t |- element DIV                         DIV             P2              P3             DIV\n\t *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n\t *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n\t *\t\t |   |- element P1\n\t *\t\t |   |   |- \"lorem\"                                              ||\n\t *\t\t |- element P2                                                   ||\n\t *\t\t |   |- \"foo\"                                                    VV\n\t *\t\t |- element P3\n\t *\t\t |   |- \"bar\"                                                   root\n\t *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n\t *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n\t *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n\t *\t\t |   |- element P4\n\t *\t\t |   |   |- \"ipsum\"\n\t *\n\t * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n\t * We are looking for minimal set of flat ranges that contains the same nodes.\n\t *\n\t * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n\t *\n\t *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n\t *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n\t *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n\t *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n\t *\n\t * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n\t * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n\t * were omitted. Only their parts that were wholly in the range were returned.\n\t *\n\t * **Note:** this method is not returning flat ranges that contain no nodes.\n\t *\n\t * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n\t */\n\tgetMinimalFlatRanges() {\n\t\tconst ranges = [];\n\t\tconst diffAt = this.start.getCommonPath( this.end ).length;\n\n\t\tconst pos = Position.createFromPosition( this.start );\n\t\tlet posParent = pos.parent;\n\n\t\t// Go up.\n\t\twhile ( pos.path.length > diffAt + 1 ) {\n\t\t\tconst howMany = posParent.maxOffset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.path = pos.path.slice( 0, -1 );\n\t\t\tpos.offset++;\n\t\t\tposParent = posParent.parent;\n\t\t}\n\n\t\t// Go down.\n\t\twhile ( pos.path.length <= this.end.path.length ) {\n\t\t\tconst offset = this.end.path[ pos.path.length - 1 ];\n\t\t\tconst howMany = offset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.offset = offset;\n\t\t\tpos.path.push( 0 );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @param {module:engine/model/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n\t * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @method getItems\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by given `delta`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (e.g. when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} delta Delta to transform range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByDelta( delta ) {\n\t\tconst ranges = [ Range.createFromRange( this ) ];\n\n\t\t// Operation types that a range can be transformed by.\n\t\tconst supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );\n\n\t\tfor ( const operation of delta.operations ) {\n\t\t\tif ( supportedTypes.has( operation.type ) ) {\n\t\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\t\tlet result;\n\n\t\t\t\t\tif ( operation.type == 'insert' ) {\n\t\t\t\t\t\tresult = ranges[ i ]._getTransformedByDocumentChange(\n\t\t\t\t\t\t\toperation.type,\n\t\t\t\t\t\t\tdelta.type,\n\t\t\t\t\t\t\toperation.position,\n\t\t\t\t\t\t\toperation.nodes.maxOffset\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = ranges[ i ]._getTransformedByDocumentChange(\n\t\t\t\t\t\t\toperation.type,\n\t\t\t\t\t\t\tdelta.type,\n\t\t\t\t\t\t\toperation.targetPosition,\n\t\t\t\t\t\t\toperation.howMany,\n\t\t\t\t\t\t\toperation.sourcePosition\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tranges.splice( i, 1, ...result );\n\n\t\t\t\t\ti += result.length - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by multiple `deltas`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (e.g. when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {Iterable.<module:engine/model/delta/delta~Delta>} deltas Deltas to transform the range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByDeltas( deltas ) {\n\t\tconst ranges = [ Range.createFromRange( this ) ];\n\n\t\tfor ( const delta of deltas ) {\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\tconst result = ranges[ i ].getTransformedByDelta( delta );\n\n\t\t\t\tranges.splice( i, 1, ...result );\n\t\t\t\ti += result.length - 1;\n\t\t\t}\n\t\t}\n\n\t\t// It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n\t\t// \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n\t\t// because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n\t\t// are inside other ranges and we simply remove them.\n\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\tconst range = ranges[ i ];\n\n\t\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t\tconst next = ranges[ j ];\n\n\t\t\t\tif ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {\n\t\t\t\t\tranges.splice( j, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of the range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by a change in the model document.\n\t *\n\t * @protected\n\t * @param {'insert'|'move'|'remove'|'reinsert'} type Change type.\n\t * @param {String} deltaType Type of delta that introduced the change.\n\t * @param {module:engine/model/position~Position} targetPosition Position before the first changed node.\n\t * @param {Number} howMany How many nodes has been changed.\n\t * @param {module:engine/model/position~Position} sourcePosition Source position of changes.\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByDocumentChange( type, deltaType, targetPosition, howMany, sourcePosition ) {\n\t\tif ( type == 'insert' ) {\n\t\t\treturn this._getTransformedByInsertion( targetPosition, howMany, false, false );\n\t\t} else {\n\t\t\tconst sourceRange = Range.createFromPositionAndShift( sourcePosition, howMany );\n\n\t\t\t// Edge case for merge delta.\n\t\t\tif (\n\t\t\t\tdeltaType == 'merge' &&\n\t\t\t\tthis.isCollapsed &&\n\t\t\t\t( this.start.isEqual( sourceRange.start ) || this.start.isEqual( sourceRange.end ) )\n\t\t\t) {\n\t\t\t\t// Collapsed range is in merged element, at the beginning or at the end of it.\n\t\t\t\t// Without fix, the range would end up in the graveyard, together with removed element.\n\t\t\t\t// <p>foo</p><p>[]bar</p> -> <p>foobar</p><p>[]</p> -> <p>foobar</p> -> <p>foo[]bar</p>\n\t\t\t\t// <p>foo</p><p>bar[]</p> -> <p>foobar</p><p>[]</p> -> <p>foobar</p> -> <p>foobar[]</p>\n\t\t\t\t//\n\t\t\t\t// In most cases, `sourceRange.start.offset` for merge delta's move operation would be 0,\n\t\t\t\t// so this formula might look overcomplicated.\n\t\t\t\t// However in some scenarios, after operational transformation, move operation might not\n\t\t\t\t// in fact start from 0 and we need to properly count new offset.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-engine/pull/1133#issuecomment-329080668.\n\t\t\t\tconst offset = this.start.offset - sourceRange.start.offset;\n\n\t\t\t\treturn [ new Range( targetPosition.getShiftedBy( offset ) ) ];\n\t\t\t}\n\t\t\t//\n\t\t\t// Edge case for split delta.\n\t\t\t//\n\t\t\tif ( deltaType == 'split' && this.isCollapsed && this.end.isEqual( sourceRange.end ) ) {\n\t\t\t\t// Collapsed range is at the end of split element.\n\t\t\t\t// Without fix, the range would end up at the end of split (old) element instead of at the end of new element.\n\t\t\t\t// That would happen because this range is not technically inside moved range. Last step below shows the fix.\n\t\t\t\t// <p>foobar[]</p> -> <p>foobar[]</p><p></p> -> <p>foo[]</p><p>bar</p> -> <p>foo</p><p>bar[]</p>\n\t\t\t\treturn [ new Range( targetPosition.getShiftedBy( howMany ) ) ];\n\t\t\t}\n\t\t\t//\n\t\t\t// Other edge cases:\n\t\t\t//\n\t\t\t// In all examples `[]` is `this` and `{}` is `sourceRange`, while `^` is move target position.\n\t\t\t//\n\t\t\t// Example:\n\t\t\t// <p>xx</p>^<w>{<p>a[b</p>}</w><p>c]d</p>   -->   <p>xx</p><p>a[b</p><w></w><p>c]d</p>\n\t\t\t// ^<p>xx</p><w>{<p>a[b</p>}</w><p>c]d</p>   -->   <p>a[b</p><p>xx</p><w></w><p>c]d</p>  // Note <p>xx</p> inclusion.\n\t\t\t// <w>{<p>a[b</p>}</w>^<p>c]d</p>            -->   <w></w><p>a[b</p><p>c]d</p>\n\t\t\tif (\n\t\t\t\t( sourceRange.containsPosition( this.start ) || sourceRange.start.isEqual( this.start ) ) &&\n\t\t\t\tthis.containsPosition( sourceRange.end ) &&\n\t\t\t\tthis.end.isAfter( targetPosition )\n\t\t\t) {\n\t\t\t\tconst start = this.start._getCombined(\n\t\t\t\t\tsourcePosition,\n\t\t\t\t\ttargetPosition._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t\t);\n\t\t\t\tconst end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany, false, false );\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\n\t\t\t// Example:\n\t\t\t// <p>c[d</p><w>{<p>a]b</p>}</w>^<p>xx</p>   -->   <p>c[d</p><w></w><p>a]b</p><p>xx</p>\n\t\t\t// <p>c[d</p><w>{<p>a]b</p>}</w><p>xx</p>^   -->   <p>c[d</p><w></w><p>xx</p><p>a]b</p>  // Note <p>xx</p> inclusion.\n\t\t\t// <p>c[d</p>^<w>{<p>a]b</p>}</w>            -->   <p>c[d</p><p>a]b</p><w></w>\n\t\t\tif (\n\t\t\t\t( sourceRange.containsPosition( this.end ) || sourceRange.end.isEqual( this.end ) ) &&\n\t\t\t\tthis.containsPosition( sourceRange.start ) &&\n\t\t\t\tthis.start.isBefore( targetPosition )\n\t\t\t) {\n\t\t\t\tconst start = this.start._getTransformedByMove(\n\t\t\t\t\tsourcePosition,\n\t\t\t\t\ttargetPosition,\n\t\t\t\t\thowMany,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\tconst end = this.end._getCombined(\n\t\t\t\t\tsourcePosition,\n\t\t\t\t\ttargetPosition._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t\t);\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\n\t\t\treturn this._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n\t * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );\n\t *\t\tlet transformed = range._getTransformedByInsertion( new Position( root, [ 1 ] ), 2 );\n\t *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 0 ] ), 4 );\n\t *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4 );\n\t *\t\t// transformed array has one range, which is equal to original range\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4, true );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, false );\n\t *\t\t// transformed array has one range which is equal to original range because insertion is after the range boundary\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, true );\n\t *\t\t// transformed array has one range: from [ 2, 7 ] to [ 4, 0, 5 ] because range was expanded\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n\t * was inside the range. Defaults to `false`.\n\t * @param {Boolean} [isSticky] Flag indicating whether insertion should expand a range if it is in a place of\n\t * range boundary. Defaults to `false`.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, spread = false, isSticky = false ) {\n\t\tif ( spread && this.containsPosition( insertPosition ) ) {\n\t\t\t// Range has to be spread. The first part is from original start to the spread point.\n\t\t\t// The other part is from spread point to the original end, but transformed by\n\t\t\t// insertion to reflect insertion changes.\n\n\t\t\treturn [\n\t\t\t\tnew Range( this.start, insertPosition ),\n\t\t\t\tnew Range(\n\t\t\t\t\tinsertPosition._getTransformedByInsertion( insertPosition, howMany, true ),\n\t\t\t\t\tthis.end._getTransformedByInsertion( insertPosition, howMany, this.isCollapsed )\n\t\t\t\t)\n\t\t\t];\n\t\t} else {\n\t\t\tconst range = Range.createFromRange( this );\n\n\t\t\tconst insertBeforeStart = !isSticky;\n\t\t\tconst insertBeforeEnd = range.isCollapsed ? true : isSticky;\n\n\t\t\trange.start = range.start._getTransformedByInsertion( insertPosition, howMany, insertBeforeStart );\n\t\t\trange.end = range.end._getTransformedByInsertion( insertPosition, howMany, insertBeforeEnd );\n\n\t\t\treturn [ range ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n\t * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n\t * @param {Number} howMany How many nodes are moved.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\tif ( this.isCollapsed ) {\n\t\t\tconst newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany, true, false );\n\n\t\t\treturn [ new Range( newPos ) ];\n\t\t}\n\n\t\tlet result;\n\n\t\tconst moveRange = new Range( sourcePosition, sourcePosition.getShiftedBy( howMany ) );\n\n\t\tconst differenceSet = this.getDifference( moveRange );\n\t\tlet difference = null;\n\n\t\tconst common = this.getIntersection( moveRange );\n\n\t\tif ( differenceSet.length == 1 ) {\n\t\t\t// `moveRange` and this range may intersect.\n\t\t\tdifference = new Range(\n\t\t\t\tdifferenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),\n\t\t\t\tdifferenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} else if ( differenceSet.length == 2 ) {\n\t\t\t// `moveRange` is inside this range.\n\t\t\tdifference = new Range(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} // else, `moveRange` contains this range.\n\n\t\tconst insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( difference ) {\n\t\t\tresult = difference._getTransformedByInsertion( insertPosition, howMany, common !== null );\n\t\t} else {\n\t\t\tresult = [];\n\t\t}\n\n\t\tif ( common ) {\n\t\t\tresult.push( new Range(\n\t\t\t\tcommon.start._getCombined( moveRange.start, insertPosition ),\n\t\t\t\tcommon.end._getCombined( moveRange.start, insertPosition )\n\t\t\t) );\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @param {module:engine/model/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range from given parents and offsets.\n\t *\n\t * @param {module:engine/model/element~Element} startElement Start position parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/model/element~Element} endElement End position parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tPosition.createFromParentAndOffset( startElement, startOffset ),\n\t\t\tPosition.createFromParentAndOffset( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new instance of `Range` which is equal to passed range.\n\t *\n\t * @param {module:engine/model/range~Range} range Range to clone.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic createFromRange( range ) {\n\t\treturn new this( range.start, range.end );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic createIn( element ) {\n\t\treturn this.createFromParentsAndOffsets( element, 0, element, element.maxOffset );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic createOn( item ) {\n\t\treturn this.createFromPositionAndShift( Position.createBefore( item ), item.offsetSize );\n\t}\n\n\t/**\n\t * Creates a collapsed range at given {@link module:engine/model/position~Position position}\n\t * or on the given {@link module:engine/model/item~Item item}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tstatic createCollapsedAt( itemOrPosition, offset ) {\n\t\tconst start = Position.createAt( itemOrPosition, offset );\n\t\tconst end = Position.createFromPosition( start );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n\t * Passed ranges must not have common parts.\n\t *\n\t * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n\t * the reference range, they get combined into one range.\n\t *\n\t *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n\t *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n\t *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n\t *\t                                           [  ]  // The result of the function if the last range was a reference range.\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n\t * @returns {module:engine/model/range~Range} Combined range.\n\t */\n\tstatic createFromRanges( ranges ) {\n\t\tif ( ranges.length === 0 ) {\n\t\t\t/**\n\t\t\t * At least one range has to be passed to\n\t\t\t * {@link module:engine/model/range~Range.createFromRanges `Range.createFromRanges()`}.\n\t\t\t *\n\t\t\t * @error range-create-from-ranges-empty-array\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'range-create-from-ranges-empty-array: At least one range has to be passed.' );\n\t\t} else if ( ranges.length == 1 ) {\n\t\t\treturn this.createFromRange( ranges[ 0 ] );\n\t\t}\n\n\t\t// 1. Set the first range in `ranges` array as a reference range.\n\t\t// If we are going to return just a one range, one of the ranges need to be the reference one.\n\t\t// Other ranges will be stuck to that range, if possible.\n\t\tconst ref = ranges[ 0 ];\n\n\t\t// 2. Sort all the ranges so it's easier to process them.\n\t\tranges.sort( ( a, b ) => {\n\t\t\treturn a.start.isAfter( b.start ) ? 1 : -1;\n\t\t} );\n\n\t\t// 3. Check at which index the reference range is now.\n\t\tconst refIndex = ranges.indexOf( ref );\n\n\t\t// 4. At this moment we don't need the original range.\n\t\t// We are going to modify the result and we need to return a new instance of Range.\n\t\t// We have to create a copy of the reference range.\n\t\tconst result = new this( ref.start, ref.end );\n\n\t\t// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex - 1; i >= 0; i++ ) {\n\t\t\tif ( ranges[ i ].end.isEqual( result.start ) ) {\n\t\t\t\tresult.start = Position.createFromPosition( ranges[ i ].start );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex + 1; i < ranges.length; i++ ) {\n\t\t\tif ( ranges[ i ].start.isEqual( result.end ) ) {\n\t\t\t\tresult.end = Position.createFromPosition( ranges[ i ].end );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Range`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n\t * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\treturn new this( Position.fromJSON( json.start, doc ), Position.fromJSON( json.end, doc ) );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * Mapper use bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tdata.viewPosition = this._findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet viewBlock = data.viewPosition.parent;\n\t\t\tlet modelParent = this._viewToModelMapping.get( viewBlock );\n\n\t\t\twhile ( !modelParent ) {\n\t\t\t\tviewBlock = viewBlock.parent;\n\t\t\t\tmodelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\t}\n\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition.createFromParentAndOffset( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to passed `viewElement`.\n\t *\n\t * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t */\n\tunbindViewElement( viewElement ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n\t * will be removed only if view element is still bound to passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\n\t\telements.add( element );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t}\n\n\t/**\n\t * Unbinds all elements from given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementsFromMarkerName( name ) {\n\t\tthis._markerNameToElements.delete( name );\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n\t * if no elements are bound to given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of view element in model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n\t * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( 'text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\t_findPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\t_findPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\t_findPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\t_findPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: offset in the model equals offset in the text.\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this._findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n\t * if it was next to it.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n\t * @returns {module:engine/view/position~Position} Position in text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after text node, put it at the end of that text node.\n\t\t// If the position is just before text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n\t * value in `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n\t * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n\t * (it would point to a correct place in view when converted). One example of such situation is when a range is\n\t * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n\t * handle such situation, check `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n\t * \t\t// to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\n\nimport TextProxy from '../model/textproxy';\n\n/**\n * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcast-selection-converters default downcast converters} for more information.\n *\n * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding\n * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `image` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [image]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:image', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `image` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Check if the `image` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class ModelConsumable {\n\t/**\n\t * Creates an empty consumables list.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Contains list of consumable values.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n\t\t */\n\t\tthis._consumable = new Map();\n\n\t\t/**\n\t\t * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent\n\t\t * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`\n\t\t * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`\n\t\t * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`\n\t\t * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of\n\t\t * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n\t\t */\n\t\tthis._textProxyRegistry = new Map();\n\t}\n\n\t/**\n\t * Adds a consumable value to the consumables list and links it with given model item.\n\t *\n\t *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n\t *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n\t *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection that has the consumable.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t */\n\tadd( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( !this._consumable.has( item ) ) {\n\t\t\tthis._consumable.set( item, new Map() );\n\t\t}\n\n\t\tthis._consumable.get( item ).set( type, true );\n\t}\n\n\t/**\n\t * Removes given consumable value from given model item.\n\t *\n\t *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n\t *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n\t *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection from which consumable will be consumed.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n\t */\n\tconsume( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( this.test( item, type ) ) {\n\t\t\tthis._consumable.get( item ).set( type, false );\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Tests whether there is a consumable value of given type connected with given model item.\n\t *\n\t *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n\t *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n\t *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be tested.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n\t * already consumed or `true` if it was added and not consumed yet.\n\t */\n\ttest( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst itemConsumables = this._consumable.get( item );\n\n\t\tif ( itemConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst value = itemConsumables.get( type );\n\n\t\tif ( value === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Reverts consuming of consumable value.\n\t *\n\t *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n\t *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n\t *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be reverted.\n\t * @param {String} type Consumable type.\n\t * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n\t * never been added.\n\t */\n\trevert( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst test = this.test( item, type );\n\n\t\tif ( test === false ) {\n\t\t\tthis._consumable.get( item ).set( type, true );\n\n\t\t\treturn true;\n\t\t} else if ( test === true ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n\t * have same parent, same start index and same end index will get the same symbol.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n\t * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n\t */\n\t_getSymbolForTextProxy( textProxy ) {\n\t\tlet symbol = null;\n\n\t\tconst startMap = this._textProxyRegistry.get( textProxy.startOffset );\n\n\t\tif ( startMap ) {\n\t\t\tconst endMap = startMap.get( textProxy.endOffset );\n\n\t\t\tif ( endMap ) {\n\t\t\t\tsymbol = endMap.get( textProxy.parent );\n\t\t\t}\n\t\t}\n\n\t\tif ( !symbol ) {\n\t\t\tsymbol = this._addSymbolForTextProxy( textProxy.startOffset, textProxy.endOffset, textProxy.parent );\n\t\t}\n\n\t\treturn symbol;\n\t}\n\n\t/**\n\t * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {Number} startIndex Text proxy start index in it's parent.\n\t * @param {Number} endIndex Text proxy end index in it's parent.\n\t * @param {module:engine/model/element~Element} parent Text proxy parent.\n\t * @returns {Symbol} Symbol generated for given properties.\n\t */\n\t_addSymbolForTextProxy( start, end, parent ) {\n\t\tconst symbol = Symbol( 'textProxySymbol' );\n\t\tlet startMap, endMap;\n\n\t\tstartMap = this._textProxyRegistry.get( start );\n\n\t\tif ( !startMap ) {\n\t\t\tstartMap = new Map();\n\t\t\tthis._textProxyRegistry.set( start, startMap );\n\t\t}\n\n\t\tendMap = startMap.get( end );\n\n\t\tif ( !endMap ) {\n\t\t\tendMap = new Map();\n\t\t\tstartMap.set( end, endMap );\n\t\t}\n\n\t\tendMap.set( parent, symbol );\n\n\t\treturn symbol;\n\t}\n}\n\n// Returns a normalized consumable type name from given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If string to normalize has more \"parts\" (more colons),\n// the other parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\nfunction _normalizeConsumableType( type ) {\n\tconst parts = type.split( ':' );\n\n\treturn parts.length > 1 ? parts[ 0 ] + ':' + parts[ 1 ] : parts[ 0 ];\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\n\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport extend from '@ckeditor/ckeditor5-utils/src/lib/lodash/extend';\n\n/**\n * `DowncastDispatcher` is a central point of downcasting (conversion from model to view), which is a process of reacting to changes\n * in the model and firing a set of events. Callbacks listening to those events are called converters. Those\n * converters role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During conversion process, `DowncastDispatcher` fires events, basing on state of the model and prepares\n * data for those events. It is important to understand that those events are connected with changes done on model,\n * for example: \"node has been inserted\" or \"attribute has changed\". This is in a contrary to upcasting (view to model conversion),\n * where we convert view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to `DowncastDispatcher` as a diff between old model state and new model state.\n *\n * Note, that because changes are converted there is a need to have a mapping between model structure and view structure.\n * To map positions and elements during downcast (model to view conversion) use {@link module:engine/conversion/mapper~Mapper}.\n *\n * `DowncastDispatcher` fires following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * if a range of nodes has been inserted to the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove remove}\n * if a range of nodes has been removed from the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute}\n * if attribute has been added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute},\n * `DowncastDispatcher` generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have a control over which changes has been already consumed. It is useful when some converters\n * overwrite other or converts multiple changes (for example converts insertion of an element and also converts that\n * element's attributes during insertion).\n *\n * Additionally, `DowncastDispatcher` fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} if a marker has been added,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} if a marker has been removed.\n *\n * Note, that changing a marker is done through removing the marker from the old range, and adding on the new range,\n * so both those events are fired.\n *\n * Finally, `DowncastDispatcher` also handles firing events for {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * which converts selection from model to view,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * which is fired for every selection attribute,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * which is fired for every marker which contains selection.\n *\n * Unlike model tree and markers, events for selection are not fired for changes but for selection state.\n *\n * When providing custom listeners for `DowncastDispatcher` remember to check whether given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for `DowncastDispatcher` keep in mind that any callback that had\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for `DowncastDispatcher` remember to use provided\n * {@link module:engine/view/writer~Writer view writer} to apply changes to the view document.\n *\n * Example of a custom converter for `DowncastDispatcher`:\n *\n *\t\t// We will convert inserting \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate position in model to position in view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create <p> element that will be inserted in view at `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to model element so positions will map accordingly in future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class DowncastDispatcher {\n\t/**\n\t * Creates a `DowncastDispatcher` instance.\n\t *\n\t * @param {Object} [conversionApi] Interface passed by dispatcher to the events calls.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {Object}\n\t\t */\n\t\tthis.conversionApi = extend( { dispatcher: this }, conversionApi );\n\t}\n\n\t/**\n\t * Takes {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n\t *\n\t * @param {module:engine/model/differ~Differ} differ Differ object with buffered changes.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertChanges( differ, writer ) {\n\t\t// Before the view is updated, remove markers which have changed.\n\t\tfor ( const change of differ.getMarkersToRemove() ) {\n\t\t\tthis.convertMarkerRemove( change.name, change.range, writer );\n\t\t}\n\n\t\t// Convert changes that happened on model tree.\n\t\tfor ( const entry of differ.getChanges() ) {\n\t\t\tif ( entry.type == 'insert' ) {\n\t\t\t\tthis.convertInsert( Range.createFromPositionAndShift( entry.position, entry.length ), writer );\n\t\t\t} else if ( entry.type == 'remove' ) {\n\t\t\t\tthis.convertRemove( entry.position, entry.length, entry.name, writer );\n\t\t\t} else {\n\t\t\t\t// entry.type == 'attribute'.\n\t\t\t\tthis.convertAttribute( entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer );\n\t\t\t}\n\t\t}\n\n\t\t// After the view is updated, convert markers which have changed.\n\t\tfor ( const change of differ.getMarkersToAdd() ) {\n\t\t\tthis.convertMarkerAdd( change.name, change.range, writer );\n\t\t}\n\t}\n\n\t/**\n\t * Starts conversion of a range insertion.\n\t *\n\t * For each node in the range, {@link #event:insert insert event is fired}. For each attribute on each node,\n\t * {@link #event:attribute attribute event is fired}.\n\t *\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Inserted range.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertInsert( range, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list of things that can be consumed, consisting of nodes and their attributes.\n\t\tthis.conversionApi.consumable = this._createInsertConsumable( range );\n\n\t\t// Fire a separate insert event for each node and text fragment contained in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\t\t\tconst itemRange = Range.createFromPositionAndShift( value.previousPosition, value.length );\n\t\t\tconst data = {\n\t\t\t\titem,\n\t\t\t\trange: itemRange\n\t\t\t};\n\n\t\t\tthis._testAndFire( 'insert', data );\n\n\t\t\t// Fire a separate addAttribute event for each attribute that was set on inserted items.\n\t\t\t// This is important because most attributes converters will listen only to add/change/removeAttribute events.\n\t\t\t// If we would not add this part, attributes on inserted nodes would not be converted.\n\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\tdata.attributeKey = key;\n\t\t\t\tdata.attributeOldValue = null;\n\t\t\t\tdata.attributeNewValue = item.getAttribute( key );\n\n\t\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t\t}\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n\t *\n\t * @param {module:engine/model/position~Position} position Position from which node was removed.\n\t * @param {Number} length Offset size of removed node.\n\t * @param {String} name Name of removed node.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertRemove( position, length, name, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'remove:' + name, { position, length }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts conversion of attribute change on given `range`.\n\t *\n\t * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n\t *\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Changed range.\n\t * @param {String} key Key of the attribute that has changed.\n\t * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n\t * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertAttribute( range, key, oldValue, newValue, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list with attributes to consume.\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( range, `attribute:${ key }` );\n\n\t\t// Create a separate attribute event for each node in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\t\t\tconst itemRange = Range.createFromPositionAndShift( value.previousPosition, value.length );\n\t\t\tconst data = {\n\t\t\t\titem,\n\t\t\t\trange: itemRange,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\tattributeNewValue: newValue\n\t\t\t};\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts model selection conversion.\n\t *\n\t * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.\n\t *\n\t * @fires selection\n\t * @fires addMarker\n\t * @fires attribute\n\t * @param {module:engine/model/selection~Selection} selection Selection to convert.\n\t * @param {Array.<module:engine/model/markercollection~Marker>} markers Array of markers containing model markers.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertSelection( selection, markers, writer ) {\n\t\tconst markersAtSelection = Array.from( markers.getMarkersAtPosition( selection.getFirstPosition() ) );\n\n\t\tthis.conversionApi.writer = writer;\n\t\tthis.conversionApi.consumable = this._createSelectionConsumable( selection, markersAtSelection );\n\n\t\tthis.fire( 'selection', { selection }, this.conversionApi );\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const marker of markersAtSelection ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tif ( !shouldMarkerChangeBeConverted( selection.getFirstPosition(), marker, this.conversionApi.mapper ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\tmarkerName: marker.name,\n\t\t\t\tmarkerRange\n\t\t\t};\n\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'addMarker:' + marker.name ) ) {\n\t\t\t\tthis.fire( 'addMarker:' + marker.name, data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\trange: selection.getFirstRange(),\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: selection.getAttribute( key )\n\t\t\t};\n\n\t\t\t// Do not fire event if the attribute has been consumed.\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'attribute:' + data.attributeKey ) ) {\n\t\t\t\tthis.fire( 'attribute:' + data.attributeKey, data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Converts added marker. Fires {@link #event:addMarker addMarker} event for each item\n\t * in marker's range. If range is collapsed single event is dispatched. See event description for more details.\n\t *\n\t * @fires addMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange Marker range.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertMarkerAdd( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n\t\tif ( !markerRange.root.document || markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// In markers' case, event name == consumable name.\n\t\tconst eventName = 'addMarker:' + markerName;\n\n\t\t// When range is collapsed - fire single event with collapsed range in consumable.\n\t\tif ( markerRange.isCollapsed ) {\n\t\t\tconst consumable = new Consumable();\n\t\t\tconsumable.add( markerRange, eventName );\n\n\t\t\tthis.conversionApi.consumable = consumable;\n\n\t\t\tthis.fire( eventName, { markerName, markerRange }, this.conversionApi );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Create consumable for each item in range.\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( markerRange, eventName );\n\n\t\t// Create separate event for each node in the range.\n\t\tfor ( const item of markerRange.getItems() ) {\n\t\t\t// Do not fire event for already consumed items.\n\t\t\tif ( !this.conversionApi.consumable.test( item, eventName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = { item, range: Range.createOn( item ), markerName, markerRange };\n\n\t\t\tthis.fire( eventName, data, this.conversionApi );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires conversion of marker removal. Fires {@link #event:removeMarker removeMarker} event with provided data.\n\t *\n\t * @fires removeMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange Marker range.\n\t * @param {module:engine/view/writer~Writer} writer View writer that should be used to modify view document.\n\t */\n\tconvertMarkerRemove( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n\t\tif ( !markerRange.root.document || markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'removeMarker:' + markerName, { markerName, markerRange }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range,\n\t * assuming that the range has just been inserted to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Inserted range.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createInsertConsumable( range ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\n\t\t\tconsumable.add( item, 'insert' );\n\n\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\tconsumable.add( item, 'attribute:' + key );\n\t\t\t}\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for given range.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Affected range.\n\t * @param {String} type Consumable type.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createConsumableForRange( range, type ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tconsumable.add( item, type );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.\n\t * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createSelectionConsumable( selection, markers ) {\n\t\tconst consumable = new Consumable();\n\n\t\tconsumable.add( selection, 'selection' );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tconsumable.add( selection, 'addMarker:' + marker.name );\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconsumable.add( selection, 'attribute:' + key );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n\t *\n\t * @private\n\t * @fires insert\n\t * @fires attribute\n\t * @param {String} type Event type.\n\t * @param {Object} data Event data.\n\t */\n\t_testAndFire( type, data ) {\n\t\tif ( !this.conversionApi.consumable.test( data.item, type ) ) {\n\t\t\t// Do not fire event if the item was consumed.\n\t\t\treturn;\n\t\t}\n\n\t\tconst name = data.item.name || '$text';\n\n\t\tthis.fire( type + ':' + name, data, this.conversionApi );\n\t}\n\n\t/**\n\t * Clears conversion API object.\n\t *\n\t * @private\n\t */\n\t_clearConversionApi() {\n\t\tdelete this.conversionApi.writer;\n\t\tdelete this.conversionApi.consumable;\n\t}\n\n\t/**\n\t * Fired for inserted nodes.\n\t *\n\t * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n\t * or {@link module:engine/model/element~Element#name name} of inserted element.\n\t *\n\t * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n\t *\n\t * @event insert\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item} data.item Inserted item.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for removed nodes.\n\t *\n\t * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n\t * or the {@link module:engine/model/element~Element#name name} of removed element.\n\t *\n\t * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n\t *\n\t * @event remove\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/position~Position} data.sourcePosition Position from where the range has been removed.\n\t * @param {module:engine/model/range~Range} data.range Removed range (in {@link module:engine/model/document~Document#graveyard\n\t * graveyard root}).\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when attribute has been added/changed/removed from a node. Also fired when collapsed model selection attribute is converted.\n\t *\n\t * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n\t * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n\t * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n\t *\n\t * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:image`).\n\t *\n\t * @event attribute\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n\t * or converted selection.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n\t * @param {String} data.attributeKey Attribute key.\n\t * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n\t * @param {*} data.attributeNewValue New attribute value.\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for {@link module:engine/model/selection~Selection selection} changes.\n\t *\n\t * @event selection\n\t * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a new marker is added to the model. Also fired when collapsed model selection that is inside marker is converted.\n\t *\n\t * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n\t * `addMarker:foo:bar` events.\n\t *\n\t * If the marker range is not collapsed:\n\t *\n\t * * the event is fired for each item in the marker range one by one,\n\t * * consumables object includes each item of the marker range and the consumable value is same as event name.\n\t *\n\t * If the marker range is collapsed:\n\t *\n\t * * there is only one event,\n\t * * consumables object includes marker range with event name.\n\t *\n\t * If selection inside a marker is converted:\n\t *\n\t * * there is only one event,\n\t * * consumables object includes selection instance with event name.\n\t *\n\t * @event addMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n\t * the selection that is being converted.\n\t * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n\t * the marker range was not collapsed.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when marker is removed from the model.\n\t *\n\t * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n\t * `removeMarker:foo:bar` events.\n\t *\n\t * @event removeMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {Object} conversionApi Conversion interface to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n}\n\nmix( DowncastDispatcher, EmitterMixin );\n\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted( modelPosition, marker, mapper ) {\n\tconst range = marker.getRange();\n\tconst ancestors = Array.from( modelPosition.getAncestors() );\n\tancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\tancestors.reverse();\n\n\tconst hasCustomHandling = ancestors.some( element => {\n\t\tif ( range.containsItem( element ) ) {\n\t\t\tconst viewElement = mapper.toViewElement( element );\n\n\t\t\treturn !!viewElement.getCustomProperty( 'addHighlight' );\n\t\t}\n\t} );\n\n\treturn !hasCustomHandling;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/selection\n */\n\nimport Position from './position';\nimport Element from './element';\nimport Node from './node';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n/**\n * `Selection` is a group of {@link module:engine/model/range~Range ranges} which has a direction specified by\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}.\n * Additionally, `Selection` may have it's own attributes.\n *\n * @mixes {module:utils/emittermixin~EmitterMixin}\n */\nexport default class Selection {\n\t/**\n\t * Creates new selection instance on the given\n\t * {@link module:engine/model/selection~Selection selection}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/element~Element element}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/range~Range range}, an iterable of {@link module:engine/model/range~Range ranges}\n\t * or creates an empty selection if no arguments passed.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = new Selection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tconst selection = new Selection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tconst selection = new Selection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tconst selection = new Selection( otherSelection );\n\t *\n\t * \t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = new DocumentSelection( doc );\n\t *\t\tconst selection = new Selection( documentSelection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tconst selection = new Selection( position );\n\t *\n\t * \t\t// Creates selection at the start position of the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = new Selection( paragraph, offset );\n\t *\n\t * \t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t * \t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = new Selection( paragraph, 'in' );\n\t *\n\t * \t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t * \t\t// just after the item.\n\t *\t\tconst selection = new Selection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`) as the last argument.\n\t *\n\t * \t\t// Creates backward selection.\n\t *\t\tconst selection = new Selection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/position~Position|module:engine/model/element~Element|\n\t * Iterable.<module:engine/model/range~Range>|module:engine/model/range~Range|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tconstructor( selectable, placeOrOffset, options ) {\n\t\t/**\n\t\t * Specifies whether the last added range was added as a backward or forward range.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._lastRangeBackward = false;\n\n\t\t/**\n\t\t * Stores selection ranges.\n\t\t *\n\t\t * @protected\n\t\t * @type {Array.<module:engine/model/range~Range>}\n\t\t */\n\t\tthis._ranges = [];\n\n\t\t/**\n\t\t * List of attributes set on current selection.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String,*>}\n\t\t */\n\t\tthis._attrs = new Map();\n\n\t\tif ( selectable ) {\n\t\t\tthis.setTo( selectable, placeOrOffset, options );\n\t\t}\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n\t * Together with {@link #focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.end : range.start;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.start : range.end;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\tif ( length === 1 ) {\n\t\t\treturn this._ranges[ 0 ].isCollapsed;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._ranges.length;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus}\n\t * precedes {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn !this.isCollapsed && this._lastRangeBackward;\n\t}\n\n\t/**\n\t * Checks whether this selection is equal to given selection. Selections are equal if they have same directions,\n\t * same number of ranges and all ranges from one selection equal to a range from other selection.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\tif ( this.rangeCount != otherSelection.rangeCount ) {\n\t\t\treturn false;\n\t\t} else if ( this.rangeCount === 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const thisRange of this._ranges ) {\n\t\t\tlet found = false;\n\n\t\t\tfor ( const otherRange of otherSelection._ranges ) {\n\t\t\t\tif ( thisRange.isEqual( otherRange ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns an iterable that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\t* getRanges() {\n\t\tfor ( const range of this._ranges ) {\n\t\t\tyield Range.createFromRange( range );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\tlet first = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !first || range.start.isBefore( first.start ) ) {\n\t\t\t\tfirst = range;\n\t\t\t}\n\t\t}\n\n\t\treturn first ? Range.createFromRange( first ) : null;\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\tlet last = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !last || range.end.isAfter( last.end ) ) {\n\t\t\t\tlast = range;\n\t\t\t}\n\t\t}\n\n\t\treturn last ? Range.createFromRange( last ) : null;\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\tconst first = this.getFirstRange();\n\n\t\treturn first ? Position.createFromPosition( first.start ) : null;\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\tconst lastRange = this.getLastRange();\n\n\t\treturn lastRange ? Position.createFromPosition( lastRange.end ) : null;\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selection selection}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/element~Element element}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/range~Range range}, an iterable of {@link module:engine/model/range~Range ranges} or null.\n\t *\n\t * \t\t// Removes all selection's ranges.\n\t *\t\tselection.setTo( null );\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\tselection.setTo( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\tselection.setTo( otherSelection );\n\t *\n\t * \t\t// Sets selection to the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = new DocumentSelection( doc );\n\t *\t\tselection.setTo( documentSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\tselection.setTo( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\tselection.setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\tselection.setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tselection.setTo( paragraph, 'on' );\n\t *\n\t * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n\t *\n\t * \t\t// Sets backward selection.\n\t *\t\tconst selection = new Selection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/position~Position|module:engine/model/node~Node|\n\t * Iterable.<module:engine/model/range~Range>|module:engine/model/range~Range|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetTo( selectable, placeOrOffset, options ) {\n\t\tif ( selectable === null ) {\n\t\t\tthis._setRanges( [] );\n\t\t} else if ( selectable instanceof Selection ) {\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable && typeof selectable.getRanges == 'function' ) {\n\t\t\t// We assume that the selectable is a DocumentSelection.\n\t\t\t// It can't be imported here, because it would lead to circular imports.\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable instanceof Range ) {\n\t\t\tthis._setRanges( [ selectable ], !!placeOrOffset && !!placeOrOffset.backward );\n\t\t} else if ( selectable instanceof Position ) {\n\t\t\tthis._setRanges( [ new Range( selectable ) ] );\n\t\t} else if ( selectable instanceof Node ) {\n\t\t\tconst backward = !!options && !!options.backward;\n\t\t\tlet range;\n\n\t\t\tif ( placeOrOffset == 'in' ) {\n\t\t\t\trange = Range.createIn( selectable );\n\t\t\t} else if ( placeOrOffset == 'on' ) {\n\t\t\t\trange = Range.createOn( selectable );\n\t\t\t} else if ( placeOrOffset !== undefined ) {\n\t\t\t\trange = Range.createCollapsedAt( selectable, placeOrOffset );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * selection.setTo requires the second parameter when the first parameter is a node.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-setTo-required-second-parameter\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-setTo-required-second-parameter: ' +\n\t\t\t\t\t'selection.setTo requires the second parameter when the first parameter is a node.' );\n\t\t\t}\n\n\t\t\tthis._setRanges( [ range ], backward );\n\t\t} else if ( isIterable( selectable ) ) {\n\t\t\t// We assume that the selectable is an iterable of ranges.\n\t\t\tthis._setRanges( selectable, placeOrOffset && !!placeOrOffset.backward );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Cannot set selection to given place.\n\t\t\t *\n\t\t\t * @error model-selection-setTo-not-selectable\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-selection-setTo-not-selectable: Cannot set selection to given place.' );\n\t\t}\n\t}\n\n\t/**\n\t * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n\t * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n\t * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n\t *\n\t * @protected\n\t * @fires change:range\n\t * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n\t * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n\t * or backward - from end to start (`true`).\n\t */\n\t_setRanges( newRanges, isLastBackward = false ) {\n\t\tnewRanges = Array.from( newRanges );\n\n\t\t// Check whether there is any range in new ranges set that is different than all already added ranges.\n\t\tconst anyNewRange = newRanges.some( newRange => {\n\t\t\tif ( !( newRange instanceof Range ) ) {\n\t\t\t\tthrow new CKEditorError( 'model-selection-added-not-range: Trying to add an object that is not an instance of Range.' );\n\t\t\t}\n\n\t\t\treturn this._ranges.every( oldRange => {\n\t\t\t\treturn !oldRange.isEqual( newRange );\n\t\t\t} );\n\t\t} );\n\n\t\t// Don't do anything if nothing changed.\n\t\tif ( newRanges.length === this._ranges.length && !anyNewRange ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._removeAllRanges();\n\n\t\tfor ( const range of newRanges ) {\n\t\t\tthis._pushRange( range );\n\t\t}\n\n\t\tthis._lastRangeBackward = !!isLastBackward;\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/model/position~Position.createAt} parameters.\n\t *\n\t * @fires change:range\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetFocus( itemOrPosition, offset ) {\n\t\tif ( this.anchor === null ) {\n\t\t\t/**\n\t\t\t * Cannot set selection focus if there are no ranges in selection.\n\t\t\t *\n\t\t\t * @error model-selection-setFocus-no-ranges\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.'\n\t\t\t);\n\t\t}\n\n\t\tconst newFocus = Position.createAt( itemOrPosition, offset );\n\n\t\tif ( newFocus.compareWith( this.focus ) == 'same' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst anchor = this.anchor;\n\n\t\tif ( this._ranges.length ) {\n\t\t\tthis._popRange();\n\t\t}\n\n\t\tif ( newFocus.compareWith( anchor ) == 'before' ) {\n\t\t\tthis._pushRange( new Range( newFocus, anchor ) );\n\t\t\tthis._lastRangeBackward = true;\n\t\t} else {\n\t\t\tthis._pushRange( new Range( anchor, newFocus ) );\n\t\t\tthis._lastRangeBackward = false;\n\t\t}\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t *\n\t * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n\t * removed attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to remove.\n\t */\n\tremoveAttribute( key ) {\n\t\tif ( this.hasAttribute( key ) ) {\n\t\t\tthis._attrs.delete( key );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * If the attribute value has changed, fires the {@link #event:change:range} event with\n\t * the attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\tsetAttribute( key, value ) {\n\t\tif ( this.getAttribute( key ) !== value ) {\n\t\t\tthis._attrs.set( key, value );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\tif ( this.rangeCount !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = this.getFirstRange();\n\t\tconst nodeAfterStart = range.start.nodeAfter;\n\t\tconst nodeBeforeEnd = range.end.nodeBefore;\n\n\t\treturn ( nodeAfterStart instanceof Element && nodeAfterStart == nodeBeforeEnd ) ? nodeAfterStart : null;\n\t}\n\n\t/**\n\t * Gets elements of type \"block\" touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` always returns the deepest block.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs:\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<quote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</quote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterable.<module:engine/model/element~Element>}\n\t */\n\t* getSelectedBlocks() {\n\t\tconst visited = new WeakSet();\n\n\t\tfor ( const range of this.getRanges() ) {\n\t\t\tconst startBlock = getParentBlock( range.start, visited );\n\n\t\t\tif ( startBlock ) {\n\t\t\t\tyield startBlock;\n\t\t\t}\n\n\t\t\tfor ( const value of range.getWalker() ) {\n\t\t\t\tif ( value.type == 'elementEnd' && isUnvisitedBlockContainer( value.item, visited ) ) {\n\t\t\t\t\tyield value.item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst endBlock = getParentBlock( range.end, visited );\n\n\t\t\t// #984. Don't return the end block if the range ends right at its beginning.\n\t\t\tif ( endBlock && !range.end.isTouching( Position.createAt( endBlock ) ) ) {\n\t\t\t\tyield endBlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element = this.anchor.root ) {\n\t\tconst limitStartPosition = Position.createAt( element );\n\t\tconst limitEndPosition = Position.createAt( element, 'end' );\n\n\t\treturn limitStartPosition.isTouching( this.getFirstPosition() ) &&\n\t\t\tlimitEndPosition.isTouching( this.getLastPosition() );\n\t}\n\n\t/**\n\t * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n\t * if given range is intersecting with any range that is already stored in this selection.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to add.\n\t */\n\t_pushRange( range ) {\n\t\tthis._checkRange( range );\n\t\tthis._ranges.push( Range.createFromRange( range ) );\n\t}\n\n\t/**\n\t * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to check.\n\t */\n\t_checkRange( range ) {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tif ( range.isIntersecting( this._ranges[ i ] ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to add a range that intersects with another range from selection.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-range-intersects\n\t\t\t\t * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n\t\t\t\t * @param {module:engine/model/range~Range} intersectingRange Range from selection that intersects with `addedRange`.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-range-intersects: Trying to add a range that intersects with another range from selection.',\n\t\t\t\t\t{ addedRange: range, intersectingRange: this._ranges[ i ] }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n\t * ensure proper ranges removal.\n\t *\n\t * @protected\n\t */\n\t_removeAllRanges() {\n\t\twhile ( this._ranges.length > 0 ) {\n\t\t\tthis._popRange();\n\t\t}\n\t}\n\n\t/**\n\t * Removes most recently added range from the selection.\n\t *\n\t * @protected\n\t */\n\t_popRange() {\n\t\tthis._ranges.pop();\n\t}\n\n\t/**\n\t * Fired when selection range(s) changed.\n\t *\n\t * @event change:range\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n\t * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed because the structure of the model has been changed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t */\n\n\t/**\n\t * Fired when selection attribute changed.\n\t *\n\t * @event change:attribute\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n\t * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed in the model and its attributes were refreshed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n\t */\n}\n\nmix( Selection, EmitterMixin );\n\n// Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\nfunction isUnvisitedBlockContainer( element, visited ) {\n\tif ( visited.has( element ) ) {\n\t\treturn false;\n\t}\n\n\tvisited.add( element );\n\n\treturn element.document.model.schema.isBlock( element ) && element.parent;\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// Marks all ancestors as already visited to not include any of them later on.\nfunction getParentBlock( position, visited ) {\n\tconst ancestors = position.parent.getAncestors( { parentFirst: true, includeSelf: true } );\n\tconst block = ancestors.find( element => isUnvisitedBlockContainer( element, visited ) );\n\n\t// Mark all ancestors of this position's parent, because find() might've stopped early and\n\t// the found block may be a child of another block.\n\tancestors.forEach( element => visited.add( element ) );\n\n\treturn block;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/liverange\n */\n\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * `LiveRange` is a type of {@link module:engine/model/range~Range Range}\n * that updates itself as {@link module:engine/model/document~Document document}\n * is changed through operations. It may be used as a bookmark.\n *\n * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might\n * have to be unbound. Use {@link module:engine/model/liverange~LiveRange#detach detach} whenever you don't need `LiveRange` anymore.\n */\nexport default class LiveRange extends Range {\n\t/**\n\t * Creates a live range.\n\t *\n\t * @see module:engine/model/range~Range\n\t */\n\tconstructor( start, end ) {\n\t\tsuper( start, end );\n\n\t\tbindWithDocument.call( this );\n\t}\n\n\t/**\n\t * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance\n\t * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was\n\t * referring to it).\n\t */\n\tdetach() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * @see module:engine/model/range~Range.createIn\n\t * @static\n\t * @method module:engine/model/liverange~LiveRange.createIn\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {module:engine/model/liverange~LiveRange}\n\t */\n\n\t/**\n\t * @see module:engine/model/range~Range.createFromPositionAndShift\n\t * @static\n\t * @method module:engine/model/liverange~LiveRange.createFromPositionAndShift\n\t * @param {module:engine/model/position~Position} position\n\t * @param {Number} shift\n\t * @returns {module:engine/model/liverange~LiveRange}\n\t */\n\n\t/**\n\t * @see module:engine/model/range~Range.createFromParentsAndOffsets\n\t * @static\n\t * @method module:engine/model/liverange~LiveRange.createFromParentsAndOffsets\n\t * @param {module:engine/model/element~Element} startElement\n\t * @param {Number} startOffset\n\t * @param {module:engine/model/element~Element} endElement\n\t * @param {Number} endOffset\n\t * @returns {module:engine/model/liverange~LiveRange}\n\t */\n\n\t/**\n\t * @see module:engine/model/range~Range.createFromRange\n\t * @static\n\t * @method module:engine/model/liverange~LiveRange.createFromRange\n\t * @param {module:engine/model/range~Range} range\n\t * @returns {module:engine/model/liverange~LiveRange}\n\t */\n\n\t/**\n\t * Fired when `LiveRange` instance boundaries have changed due to changes in the\n\t * {@link module:engine/model/document~Document document}.\n\t *\n\t * @event change:range\n\t * @param {module:engine/model/range~Range} oldRange Range with start and end position equal to start and end position of this live\n\t * range before it got changed.\n\t * @param {Object} data Object with additional information about the change. Those parameters are passed from\n\t * {@link module:engine/model/document~Document#event:change document change event}.\n\t * @param {String} data.type Change type.\n\t * @param {module:engine/model/batch~Batch} data.batch Batch which changed the live range.\n\t * @param {module:engine/model/range~Range} data.range Range containing the result of applied change.\n\t * @param {module:engine/model/position~Position} data.sourcePosition Source position for move, remove and reinsert change types.\n\t */\n\n\t/**\n\t * Fired when `LiveRange` instance boundaries have not changed after a change in {@link module:engine/model/document~Document document}\n\t * but the change took place inside the range, effectively changing its content.\n\t *\n\t * @event change:content\n\t * @param {module:engine/model/range~Range} range Range with start and end position equal to start and end position of\n\t * change range.\n\t * @param {Object} data Object with additional information about the change. Those parameters are passed from\n\t * {@link module:engine/model/document~Document#event:change document change event}.\n\t * @param {String} data.type Change type.\n\t * @param {module:engine/model/batch~Batch} data.batch Batch which changed the live range.\n\t * @param {module:engine/model/range~Range} data.range Range containing the result of applied change.\n\t * @param {module:engine/model/position~Position} data.sourcePosition Source position for move, remove and reinsert change types.\n\t */\n}\n\n/**\n * Binds this `LiveRange` to the {@link module:engine/model/document~Document document}\n * that owns this range's {@link module:engine/model/range~Range#root root}.\n *\n * @ignore\n * @private\n * @method module:engine/model/liverange~LiveRange#bindWithDocument\n */\nfunction bindWithDocument() {\n\t// Operation types that a range can be transformed by.\n\tconst supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );\n\n\tthis.listenTo(\n\t\tthis.root.document.model,\n\t\t'applyOperation',\n\t\t( event, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( !operation.isDocumentOperation ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( supportedTypes.has( operation.type ) ) {\n\t\t\t\ttransform.call( this, operation );\n\t\t\t}\n\t\t},\n\t\t{ priority: 'low' }\n\t);\n}\n\n/**\n * Updates this range accordingly to the updates applied to the model. Bases on change events.\n *\n * @ignore\n * @private\n * @method transform\n * @param {module:engine/model/operation/operation~Operation} operation Executed operation.\n */\nfunction transform( operation ) {\n\tconst changeType = operation.type;\n\tconst batch = operation.delta.batch;\n\n\tlet targetRange;\n\tlet sourcePosition;\n\n\tif ( changeType == 'insert' ) {\n\t\ttargetRange = Range.createFromPositionAndShift( operation.position, operation.nodes.maxOffset );\n\t} else {\n\t\ttargetRange = Range.createFromPositionAndShift( operation.getMovedRangeStart(), operation.howMany );\n\t\tsourcePosition = operation.sourcePosition;\n\t}\n\n\tconst howMany = targetRange.end.offset - targetRange.start.offset;\n\tlet targetPosition = targetRange.start;\n\n\tif ( changeType == 'move' || changeType == 'remove' || changeType == 'reinsert' ) {\n\t\t// Range._getTransformedByDocumentChange is expecting `targetPosition` to be \"before\" move\n\t\t// (before transformation). `targetRange.start` is already after the move happened.\n\t\t// We have to revert `targetPosition` to the state before the move.\n\t\ttargetPosition = targetPosition._getTransformedByInsertion( sourcePosition, howMany );\n\t}\n\n\tconst result = this._getTransformedByDocumentChange( changeType, operation.delta.type, targetPosition, howMany, sourcePosition );\n\n\t// Decide whether moved part should be included in the range.\n\t//\n\t// First, this concerns only `move` change, because insert change includes inserted part always (changeType == 'move').\n\t// Second, this is a case only if moved range was intersecting with this range and was inserted into this range (result.length == 3).\n\tif ( ( changeType == 'move' || changeType == 'remove' || changeType == 'reinsert' ) && result.length == 3 ) {\n\t\t// `result[ 2 ]` is a \"common part\" of this range and moved range. We substitute that common part with the whole\n\t\t// `targetRange` because we want to include whole `targetRange` in this range.\n\t\tresult[ 2 ] = targetRange;\n\t}\n\n\tconst updated = Range.createFromRanges( result );\n\n\tconst boundariesChanged = !updated.isEqual( this );\n\n\tconst rangeExpanded = this.containsPosition( targetPosition );\n\tconst rangeShrunk = sourcePosition && ( this.containsPosition( sourcePosition ) || this.start.isEqual( sourcePosition ) );\n\tconst contentChanged = rangeExpanded || rangeShrunk;\n\n\tif ( boundariesChanged ) {\n\t\t// If range boundaries have changed, fire `change:range` event.\n\t\tconst oldRange = Range.createFromRange( this );\n\n\t\tthis.start = updated.start;\n\t\tthis.end = updated.end;\n\n\t\tthis.fire( 'change:range', oldRange, {\n\t\t\ttype: changeType,\n\t\t\tbatch,\n\t\t\trange: targetRange,\n\t\t\tsourcePosition\n\t\t} );\n\t} else if ( contentChanged ) {\n\t\t// If range boundaries have not changed, but there was change inside the range, fire `change:content` event.\n\t\tthis.fire( 'change:content', Range.createFromRange( this ), {\n\t\t\ttype: changeType,\n\t\t\tbatch,\n\t\t\trange: targetRange,\n\t\t\tsourcePosition\n\t\t} );\n\t}\n}\n\nmix( LiveRange, EmitterMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/documentselection\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\nimport Selection from './selection';\nimport Position from './position';\nimport LiveRange from './liverange';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nconst storePrefix = 'selection:';\n\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n */\nexport default class DocumentSelection {\n\t/**\n\t * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t *\n\t * @param {module:engine/model/document~Document} doc Document which owns this selection.\n\t */\n\tconstructor( doc ) {\n\t\t/**\n\t\t * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n\t\t *\n\t\t * @protected\n\t\t */\n\t\tthis._selection = new LiveSelection( doc );\n\n\t\tthis._selection.delegate( 'change:range' ).to( this );\n\t\tthis._selection.delegate( 'change:attribute' ).to( this );\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this._selection.isCollapsed;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n\t * Together with {@link #focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\treturn this._selection.anchor;\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\treturn this._selection.focus;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._selection.rangeCount;\n\t}\n\n\t/**\n\t * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n\t * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget hasOwnRange() {\n\t\treturn this._selection.hasOwnRange;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus}\n\t * precedes {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn this._selection.isBackward;\n\t}\n\n\t/**\n\t * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n\t *\n\t * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n\t *\n\t * @readonly\n\t * @returns {Boolean}\n\t */\n\tget isGravityOverridden() {\n\t\treturn this._selection.isGravityOverridden;\n\t}\n\n\t/**\n\t * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n\t *\n\t * @protected\n\t */\n\tget _ranges() {\n\t\treturn this._selection._ranges;\n\t}\n\n\t/**\n\t * Returns an iterable that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\tgetRanges() {\n\t\treturn this._selection.getRanges();\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\treturn this._selection.getFirstPosition();\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\treturn this._selection.getLastPosition();\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\treturn this._selection.getFirstRange();\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\treturn this._selection.getLastRange();\n\t}\n\n\t/**\n\t * Gets elements of type \"block\" touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` always returns the deepest block.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs:\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<quote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</quote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterator.<module:engine/model/element~Element>}\n\t */\n\tgetSelectedBlocks() {\n\t\treturn this._selection.getSelectedBlocks();\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\treturn this._selection.getSelectedElement();\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element ) {\n\t\treturn this._selection.containsEntireContent( element );\n\t}\n\n\t/**\n\t * Unbinds all events previously bound by document selection.\n\t */\n\tdestroy() {\n\t\tthis._selection.destroy();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._selection.getAttributeKeys();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._selection.getAttributes();\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._selection.getAttribute( key );\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._selection.hasAttribute( key );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/model/position~Position.createAt} parameters.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionFocus\n\t * @protected\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\t_setFocus( itemOrPosition, offset ) {\n\t\tthis._selection.setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selection selection}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/node~Node node}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/range~Range range}, an iterable of {@link module:engine/model/range~Range ranges} or null.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelection\n\t * @protected\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/position~Position|module:engine/model/node~Node|\n\t * Iterable.<module:engine/model/range~Range>|module:engine/model/range~Range|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\t_setTo( selectable, placeOrOffset, options ) {\n\t\tthis._selection.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._selection.setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n\t * event with removed attribute key.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#removeSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeAttribute( key ) {\n\t\tthis._selection.removeAttribute( key );\n\t}\n\n\t/**\n\t * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t *\n\t * @protected\n\t * @returns {Iterable.<*>}\n\t */\n\t_getStoredAttributes() {\n\t\treturn this._selection._getStoredAttributes();\n\t}\n\n\t/**\n\t * Temporarily changes the gravity of the selection from the left to the right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n\t * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @see module:engine/model/writer~Writer#overrideSelectionGravity\n\t * @protected\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\t_overrideGravity() {\n\t\treturn this._selection.overrideGravity();\n\t}\n\n\t/**\n\t * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @see module:engine/model/writer~Writer#restoreSelectionGravity\n\t * @protected\n\t * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n\t */\n\t_restoreGravity( uid ) {\n\t\tthis._selection.restoreGravity( uid );\n\t}\n\n\t/**\n\t * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n\t *\n\t * @protected\n\t * @param {String} key Attribute key to convert.\n\t * @returns {String} Converted attribute key, applicable for selection store.\n\t */\n\tstatic _getStoreAttributeKey( key ) {\n\t\treturn storePrefix + key;\n\t}\n\n\t/**\n\t * Checks whether the given attribute key is an attribute stored on an element.\n\t *\n\t * @protected\n\t * @param {String} key\n\t * @returns {Boolean}\n\t */\n\tstatic _isStoreAttributeKey( key ) {\n\t\treturn key.startsWith( storePrefix );\n\t}\n}\n\nmix( DocumentSelection, EmitterMixin );\n\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\n\nclass LiveSelection extends Selection {\n\t// Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t// @param {module:engine/model/document~Document} doc Document which owns this selection.\n\tconstructor( doc ) {\n\t\tsuper();\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/model~Model}\n\t\tthis._model = doc.model;\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/document~Document}\n\t\tthis._document = doc;\n\n\t\t// Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n\t\t// last time. Possible values of priority are: `'low'` and `'normal'`.\n\t\t//\n\t\t// Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n\t\t// attributes API are set with `'normal'` priority.\n\t\t//\n\t\t// @private\n\t\t// @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\t\tthis._attributePriority = new Map();\n\n\t\t// Contains data required to fix ranges which have been moved to the graveyard.\n\t\t// @private\n\t\t// @member {Array} module:engine/model/liveselection~LiveSelection#_fixGraveyardRangesData\n\t\tthis._fixGraveyardRangesData = [];\n\n\t\t// Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n\t\t// @private\n\t\t// @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\t\tthis._hasChangedRange = false;\n\n\t\t// Each overriding gravity adds an UID to the set and each removal removes it.\n\t\t// Gravity is overridden when there's at least one UID in the set.\n\t\t// Gravity is restored when the set is empty.\n\t\t// This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n\t\t// @private\n\t\t// @type {Set}\n\t\tthis._overriddenGravityRegister = new Set();\n\n\t\t// Add events that will ensure selection correctness.\n\t\tthis.on( 'change:range', () => {\n\t\t\tfor ( const range of this.getRanges() ) {\n\t\t\t\tif ( !this._document._validateSelectionRange( range ) ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n\t\t\t\t\t * starts or ends at incorrect position.\n\t\t\t\t\t *\n\t\t\t\t\t * @error document-selection-wrong-position\n\t\t\t\t\t * @param {module:engine/model/range~Range} range\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'document-selection-wrong-position: Range from document selection starts or ends at incorrect position.',\n\t\t\t\t\t\t{ range }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tthis.listenTo( this._document, 'change', ( evt, batch ) => {\n\t\t\t// Update selection's attributes.\n\t\t\tthis._updateAttributes( false );\n\n\t\t\t// Clear selection attributes from element if no longer empty.\n\t\t\tclearAttributesStoredInElement( this._model, batch );\n\t\t} );\n\n\t\tthis.listenTo( this._model, 'applyOperation', () => {\n\t\t\twhile ( this._fixGraveyardRangesData.length ) {\n\t\t\t\tconst { liveRange, sourcePosition } = this._fixGraveyardRangesData.shift();\n\n\t\t\t\tthis._fixGraveyardSelection( liveRange, sourcePosition );\n\t\t\t}\n\n\t\t\tif ( this._hasChangedRange ) {\n\t\t\t\tthis._hasChangedRange = false;\n\n\t\t\t\tthis.fire( 'change:range', { directChange: false } );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\treturn length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n\t}\n\n\tget anchor() {\n\t\treturn super.anchor || this._document._getDefaultRange().start;\n\t}\n\n\tget focus() {\n\t\treturn super.focus || this._document._getDefaultRange().end;\n\t}\n\n\tget rangeCount() {\n\t\treturn this._ranges.length ? this._ranges.length : 1;\n\t}\n\n\t// Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n\t// {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t//\n\t// @readonly\n\t// @type {Boolean}\n\tget hasOwnRange() {\n\t\treturn this._ranges.length > 0;\n\t}\n\n\t// When set to `true` then selection attributes on node before the caret won't be taken\n\t// into consideration while updating selection attributes.\n\t//\n\t// @protected\n\t// @type {Boolean}\n\tget isGravityOverridden() {\n\t\treturn !!this._overriddenGravityRegister.size;\n\t}\n\n\t// Unbinds all events previously bound by live selection.\n\tdestroy() {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tthis._ranges[ i ].detach();\n\t\t}\n\n\t\tthis.stopListening();\n\t}\n\n\t* getRanges() {\n\t\tif ( this._ranges.length ) {\n\t\t\tyield* super.getRanges();\n\t\t} else {\n\t\t\tyield this._document._getDefaultRange();\n\t\t}\n\t}\n\n\tgetFirstRange() {\n\t\treturn super.getFirstRange() || this._document._getDefaultRange();\n\t}\n\n\tgetLastRange() {\n\t\treturn super.getLastRange() || this._document._getDefaultRange();\n\t}\n\n\tsetTo( selectable, optionsOrPlaceOrOffset, options ) {\n\t\tsuper.setTo( selectable, optionsOrPlaceOrOffset, options );\n\t\tthis._refreshAttributes();\n\t}\n\n\tsetFocus( itemOrPosition, offset ) {\n\t\tsuper.setFocus( itemOrPosition, offset );\n\t\tthis._refreshAttributes();\n\t}\n\n\tsetAttribute( key, value ) {\n\t\tif ( this._setAttribute( key, value ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\tremoveAttribute( key ) {\n\t\tif ( this._removeAttribute( key ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\toverrideGravity() {\n\t\tconst overrideUid = uid();\n\n\t\t// Remember that another overriding has been requested. It will need to be removed\n\t\t// before the gravity is to be restored.\n\t\tthis._overriddenGravityRegister.add( overrideUid );\n\n\t\tif ( this._overriddenGravityRegister.size === 1 ) {\n\t\t\tthis._refreshAttributes();\n\t\t}\n\n\t\treturn overrideUid;\n\t}\n\n\trestoreGravity( uid ) {\n\t\tif ( !this._overriddenGravityRegister.has( uid ) ) {\n\t\t\t/**\n\t\t\t * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n\t\t\t * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n\t\t\t *\n\t\t\t * @error document-selection-gravity-wrong-restore\n\t\t\t * @param {String} uid The unique identifier returned by {@link #overrideGravity}.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.',\n\t\t\t\t{ uid }\n\t\t\t);\n\t\t}\n\n\t\tthis._overriddenGravityRegister.delete( uid );\n\n\t\t// Restore gravity only when all overriding have been restored.\n\t\tif ( !this.isGravityOverridden ) {\n\t\t\tthis._refreshAttributes();\n\t\t}\n\t}\n\n\t// Removes all attributes from the selection and sets attributes according to the surrounding nodes.\n\t_refreshAttributes() {\n\t\tthis._updateAttributes( true );\n\t}\n\n\t_popRange() {\n\t\tthis._ranges.pop().detach();\n\t}\n\n\t_pushRange( range ) {\n\t\tconst liveRange = this._prepareRange( range );\n\n\t\t// `undefined` is returned when given `range` is in graveyard root.\n\t\tif ( liveRange ) {\n\t\t\tthis._ranges.push( liveRange );\n\t\t}\n\t}\n\n\t// Prepares given range to be added to selection. Checks if it is correct,\n\t// converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n\t// and sets listeners listening to the range's change event.\n\t//\n\t// @private\n\t// @param {module:engine/model/range~Range} range\n\t_prepareRange( range ) {\n\t\tthis._checkRange( range );\n\n\t\tif ( range.root == this._document.graveyard ) {\n\t\t\t/**\n\t\t\t * Trying to add a Range that is in the graveyard root. Range rejected.\n\t\t\t *\n\t\t\t * @warning model-selection-range-in-graveyard\n\t\t\t */\n\t\t\tlog.warn( 'model-selection-range-in-graveyard: Trying to add a Range that is in the graveyard root. Range rejected.' );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst liveRange = LiveRange.createFromRange( range );\n\n\t\tliveRange.on( 'change:range', ( evt, oldRange, data ) => {\n\t\t\tthis._hasChangedRange = true;\n\n\t\t\t// If `LiveRange` is in whole moved to the graveyard, save necessary data. It will be fixed on `Model#applyOperation` event.\n\t\t\tif ( liveRange.root == this._document.graveyard ) {\n\t\t\t\tthis._fixGraveyardRangesData.push( {\n\t\t\t\t\tliveRange,\n\t\t\t\t\tsourcePosition: data.sourcePosition\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\treturn liveRange;\n\t}\n\n\t// Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n\t//\n\t// @protected\n\t// @param {Boolean} clearAll\n\t// @fires change:attribute\n\t_updateAttributes( clearAll ) {\n\t\tconst newAttributes = toMap( this._getSurroundingAttributes() );\n\t\tconst oldAttributes = toMap( this.getAttributes() );\n\n\t\tif ( clearAll ) {\n\t\t\t// If `clearAll` remove all attributes and reset priorities.\n\t\t\tthis._attributePriority = new Map();\n\t\t\tthis._attrs = new Map();\n\t\t} else {\n\t\t\t// If not, remove only attributes added with `low` priority.\n\t\t\tfor ( const [ key, priority ] of this._attributePriority ) {\n\t\t\t\tif ( priority == 'low' ) {\n\t\t\t\t\tthis._attrs.delete( key );\n\t\t\t\t\tthis._attributePriority.delete( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._setAttributesTo( newAttributes );\n\n\t\t// Let's evaluate which attributes really changed.\n\t\tconst changed = [];\n\n\t\t// First, loop through all attributes that are set on selection right now.\n\t\t// Check which of them are different than old attributes.\n\t\tfor ( const [ newKey, newValue ] of this.getAttributes() ) {\n\t\t\tif ( !oldAttributes.has( newKey ) || oldAttributes.get( newKey ) !== newValue ) {\n\t\t\t\tchanged.push( newKey );\n\t\t\t}\n\t\t}\n\n\t\t// Then, check which of old attributes got removed.\n\t\tfor ( const [ oldKey ] of oldAttributes ) {\n\t\t\tif ( !this.hasAttribute( oldKey ) ) {\n\t\t\t\tchanged.push( oldKey );\n\t\t\t}\n\t\t}\n\n\t\t// Fire event with exact data (fire only if anything changed).\n\t\tif ( changed.length > 0 ) {\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: changed, directChange: false } );\n\t\t}\n\t}\n\n\t// Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {*} value Attribute value.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether value has changed.\n\t_setAttribute( key, value, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst oldValue = super.getAttribute( key );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( oldValue === value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.set( key, value );\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n\t// be changed according to `directChange` parameter.\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n\t// existing attribute had higher priority.\n\t_removeAttribute( key, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( !super.hasAttribute( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.delete( key );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n\t// `directChange` parameter).\n\t//\n\t// @private\n\t// @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n\t// @returns {Set.<String>} Changed attribute keys.\n\t_setAttributesTo( attrs ) {\n\t\tconst changed = new Set();\n\n\t\tfor ( const [ oldKey, oldValue ] of this.getAttributes() ) {\n\t\t\t// Do not remove attribute if attribute with same key and value is about to be set.\n\t\t\tif ( attrs.get( oldKey ) === oldValue ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// All rest attributes will be removed so changed attributes won't change .\n\t\t\tthis._removeAttribute( oldKey, false );\n\t\t}\n\n\t\tfor ( const [ key, value ] of attrs ) {\n\t\t\t// Attribute may not be set because of attributes or because same key/value is already added.\n\t\t\tconst gotAdded = this._setAttribute( key, value, false );\n\n\t\t\tif ( gotAdded ) {\n\t\t\t\tchanged.add( key );\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\t// Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t//\n\t// @protected\n\t// @returns {Iterable.<*>}\n\t* _getStoredAttributes() {\n\t\tconst selectionParent = this.getFirstPosition().parent;\n\n\t\tif ( this.isCollapsed && selectionParent.isEmpty ) {\n\t\t\tfor ( const key of selectionParent.getAttributeKeys() ) {\n\t\t\t\tif ( key.startsWith( storePrefix ) ) {\n\t\t\t\t\tconst realKey = key.substr( storePrefix.length );\n\n\t\t\t\t\tyield [ realKey, selectionParent.getAttribute( key ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Checks model text nodes that are closest to the selection's first position and returns attributes of first\n\t// found element. If there are no text nodes in selection's first position parent, it returns selection\n\t// attributes stored in that parent.\n\t//\n\t// @private\n\t// @returns {Iterable.<*>} Collection of attributes.\n\t_getSurroundingAttributes() {\n\t\tconst position = this.getFirstPosition();\n\t\tconst schema = this._model.schema;\n\n\t\tlet attrs = null;\n\n\t\tif ( !this.isCollapsed ) {\n\t\t\t// 1. If selection is a range...\n\t\t\tconst range = this.getFirstRange();\n\n\t\t\t// ...look for a first character node in that range and take attributes from it.\n\t\t\tfor ( const value of range ) {\n\t\t\t\t// If the item is an object, we don't want to get attributes from its children.\n\t\t\t\tif ( value.item.is( 'element' ) && schema.isObject( value.item ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.\n\t\t\t\t// It can be done better by using `break;` instead of checking `attrs === null`.\n\t\t\t\tif ( value.type == 'text' && attrs === null ) {\n\t\t\t\t\tattrs = value.item.getAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// 2. If the selection is a caret or the range does not contain a character node...\n\n\t\t\tconst nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n\t\t\tconst nodeAfter = position.textNode ? position.textNode : position.nodeAfter;\n\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden ) {\n\t\t\t\t// ...look at the node before caret and take attributes from it if it is a character node.\n\t\t\t\tattrs = getAttrsIfCharacter( nodeBefore );\n\t\t\t}\n\n\t\t\t// 3. If not, look at the node after caret...\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = getAttrsIfCharacter( nodeAfter );\n\t\t\t}\n\n\t\t\t// 4. If not, try to find the first character on the left, that is in the same node.\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden && !attrs ) {\n\t\t\t\tlet node = nodeBefore;\n\n\t\t\t\twhile ( node && !attrs ) {\n\t\t\t\t\tnode = node.previousSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 5. If not found, try to find the first character on the right, that is in the same node.\n\t\t\tif ( !attrs ) {\n\t\t\t\tlet node = nodeAfter;\n\n\t\t\t\twhile ( node && !attrs ) {\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 6. If not found, selection should retrieve attributes from parent.\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = this._getStoredAttributes();\n\t\t\t}\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\t// Fixes a selection range after it ends up in graveyard root.\n\t//\n\t// @private\n\t// @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.\n\t// @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.\n\t_fixGraveyardSelection( liveRange, removedRangeStart ) {\n\t\t// The start of the removed range is the closest position to the `liveRange` - the original selection range.\n\t\t// This is a good candidate for a fixed selection range.\n\t\tconst positionCandidate = Position.createFromPosition( removedRangeStart );\n\n\t\t// Find a range that is a correct selection range and is closest to the start of removed range.\n\t\tconst selectionRange = this._model.schema.getNearestSelectionRange( positionCandidate );\n\n\t\t// Remove the old selection range before preparing and adding new selection range. This order is important,\n\t\t// because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).\n\t\tconst index = this._ranges.indexOf( liveRange );\n\t\tthis._ranges.splice( index, 1 );\n\t\tliveRange.detach();\n\n\t\t// If nearest valid selection range has been found - add it in the place of old range.\n\t\tif ( selectionRange ) {\n\t\t\t// Check the range, convert it to live range, bind events, etc.\n\t\t\tconst newRange = this._prepareRange( selectionRange );\n\n\t\t\t// Add new range in the place of old range.\n\t\t\tthis._ranges.splice( index, 0, newRange );\n\t\t}\n\t\t// If nearest valid selection range cannot be found - just removing the old range is fine.\n\t}\n}\n\n// Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\nfunction getAttrsIfCharacter( node ) {\n\tif ( node instanceof TextProxy || node instanceof Text ) {\n\t\treturn node.getAttributes();\n\t}\n\n\treturn null;\n}\n\n// Removes selection attributes from element which is not empty anymore.\n//\n// @private\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\nfunction clearAttributesStoredInElement( model, batch ) {\n\tconst differ = model.document.differ;\n\n\tfor ( const entry of differ.getChanges() ) {\n\t\tif ( entry.type != 'insert' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst changeParent = entry.position.parent;\n\t\tconst isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n\t\tif ( isNoLongerEmpty ) {\n\t\t\tmodel.enqueueChange( batch, writer => {\n\t\t\t\tconst storedAttributes = Array.from( changeParent.getAttributeKeys() )\n\t\t\t\t\t.filter( key => key.startsWith( storePrefix ) );\n\n\t\t\t\tfor ( const key of storedAttributes ) {\n\t\t\t\t\twriter.removeAttribute( key, changeParent );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n}\n","import baseClone from './_baseClone';\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\nexport default cloneDeep;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\n\nimport ViewAttributeElement from '../view/attributeelement';\nimport ViewRange from '../view/range';\nimport DocumentSelection from '../model/documentselection';\n\nimport cloneDeep from '@ckeditor/ckeditor5-utils/src/lib/lodash/cloneDeep';\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcast-converters\n */\n\n/**\n * Model element to view element conversion helper.\n *\n * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n *\n *\t\tdowncastElementToElement( { model: 'paragraph', view: 'p' } );\n *\n *\t\tdowncastElementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n *\n *\t\tdowncastElementToElement( {\n *\t\t\tmodel: 'fancyParagraph',\n *\t\t\tview: {\n *\t\t\t\tname: 'p',\n *\t\t\t\tclasses: 'fancy'\n *\t\t\t}\n *\t\t} );\n *\n * \t\tdowncastElementToElement( {\n * \t\t\tmodel: 'heading',\n * \t\t\tview: ( modelElement, viewWriter ) => viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )\n * \t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n * to the conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String} config.model The name of the model element to convert.\n * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n * that takes the model element and view writer as parameters and returns a view container element.\n * @returns {Function} Conversion helper.\n */\nexport function downcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = _normalizeToElementConfig( config.view, 'container' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'insert:' + config.model, insertElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * Model attribute to view element conversion helper.\n *\n * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n *\n *\t\tdowncastAttributeToElement( { model: 'bold', view: 'strong' } );\n *\n *\t\tdowncastAttributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n *\n *\t\tdowncastAttributeToElement( {\n *\t\t\tmodel: 'invert',\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n *\t\t\t}\n *\t\t} );\n *\n *\t\tdowncastAttributeToElement( {\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'fontSize',\n *\t\t\t\tvalues: [ 'big', 'small' ]\n *\t\t\t},\n *\t\t\tview: {\n *\t\t\t\tbig: {\n *\t\t\t\t\tname: 'span',\n *\t\t\t\t\tstyles: {\n *\t\t\t\t\t\t'font-size': '1.2em'\n *\t\t\t\t\t}\n *\t\t\t\t},\n *\t\t\t\tsmall: {\n *\t\t\t\t\tname: 'span',\n *\t\t\t\t\tstyles: {\n *\t\t\t\t\t\t'font-size': '0.8em'\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * \t\tdowncastAttributeToElement( {\n * \t\t\tmodel: 'bold',\n * \t\t\tview: ( modelAttributeValue, viewWriter ) => {\n * \t\t\t\treturn viewWriter.createAttributeElement( 'span', { style: 'font-weight:' + modelAttributeValue } );\n * \t\t\t}\n * \t\t} );\n *\n *\t\tdowncastAttributeToElement( {\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'color',\n *\t\t\t\tname: '$text'\n *\t\t\t},\n *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n *\t\t\t\treturn viewWriter.createAttributeElement( 'span', { style: 'color:' + modelAttributeValue } );\n *\t\t\t}\n *\t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n * to the conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n * of `String`s with possible values if the model attribute is an enumerable.\n * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n * that takes the model attribute value and view writer as parameters and returns a view attribute element. If `config.model.values` is\n * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function downcastAttributeToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = _normalizeToElementConfig( config.view[ modelValue ], 'attribute' );\n\t\t}\n\t} else {\n\t\tconfig.view = _normalizeToElementConfig( config.view, 'attribute' );\n\t}\n\n\tconst elementCreator = _getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, wrap( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * Model attribute to view attribute conversion helper.\n *\n * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n *\n *\t\tdowncastAttributeToAttribute( { model: 'source', view: 'src' } );\n *\n *\t\tdowncastAttributeToAttribute( { model: 'source', view: 'href', converterPriority: 'high' } );\n *\n *\t\tdowncastAttributeToAttribute( {\n *\t\t\tmodel: {\n *\t\t\t\tname: 'image',\n *\t\t\t\tkey: 'source'\n *\t\t\t},\n *\t\t\tview: 'src'\n *\t\t} );\n *\n *\t\tdowncastAttributeToAttribute( {\n *\t\t\tmodel: {\n *\t\t\t\tname: 'styled',\n *\t\t\t\tvalues: [ 'dark', 'light' ]\n *\t\t\t},\n *\t\t\tview: {\n *\t\t\t\tdark: {\n *\t\t\t\t\tkey: 'class',\n *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n *\t\t\t\t},\n *\t\t\t\tlight: {\n *\t\t\t\t\tkey: 'class',\n *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\tdowncastAttributeToAttribute( {\n *\t\t\tmodel: 'styled',\n *\t\t\tview: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )\n *\t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n * to the conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n * the attribute key, possible values and, optionally, an element name to convert from.\n * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n * `{ key, value }` objects or a functions.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function downcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = _normalizeToAttributeConfig( config.view[ modelValue ] );\n\t\t}\n\t} else {\n\t\tconfig.view = _normalizeToAttributeConfig( config.view );\n\t}\n\n\tconst elementCreator = _getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, changeAttribute( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * Model marker to view element conversion helper.\n *\n * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n *\n *\t\tdowncastMarkerToElement( { model: 'search', view: 'marker-search' } );\n *\n *\t\tdowncastMarkerToElement( { model: 'search', view: 'search-result', converterPriority: 'high' } );\n *\n *\t\tdowncastMarkerToElement( {\n *\t\t\tmodel: 'search',\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tattributes: {\n *\t\t\t\t\t'data-marker': 'search'\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * \t\tdowncastMarkerToElement( {\n * \t\t\tmodel: 'search',\n * \t\t\tview: ( markerData, viewWriter ) => {\n *\t \t\t\treturn viewWriter.createUIElement( 'span', { 'data-marker': 'search', 'data-start': markerData.isOpening } );\n * \t\t\t}\n * \t\t} );\n *\n * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n * receives the `data` object as a parameter and should return an instance of the\n * {@link module:engine/view/uielement~UIElement view UI element}. The `data` and `conversionApi` objects are passed from\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n * the marker end boundary element.\n *\n * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add a converter to the conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String} config.model The name of the model marker (or model marker group) to convert.\n * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n * that takes the model marker data as a parameter and returns a view UI element.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function downcastMarkerToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = _normalizeToElementConfig( config.view, 'ui' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, insertUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * Model marker to highlight conversion helper.\n *\n * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n * {@link module:engine/conversion/downcast-converters~HighlightDescriptor} should be provided.\n *\n * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n *\n * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n * in the view.\n *\n * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n *\n *\t\tdowncastMarkerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n *\n *\t\tdowncastMarkerToHighlight( { model: 'comment', view: { classes: 'new-comment' }, converterPriority: 'high' } );\n *\n * \t\tdowncastMarkerToHighlight( {\n * \t\t\tmodel: 'comment',\n * \t\t\tview: data => {\n * \t\t\t\t// Assuming that the marker name is in a form of comment:commentType.\n *\t \t\t\tconst commentType = data.markerName.split( ':' )[ 1 ];\n *\n *\t \t\t\treturn {\n *\t \t\t\t\tclasses: [ 'comment', 'comment-' + commentType ]\n *\t \t\t\t};\n * \t\t\t}\n * \t\t} );\n *\n * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n * receives the `data` object as a parameter and should return a\n * {@link module:engine/conversion/downcast-converters~HighlightDescriptor highlight descriptor}.\n * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add a converter to the conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String} config.model The name of the model marker (or model marker group) to convert.\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor|Function} config.view A highlight descriptor\n * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function downcastMarkerToHighlight( config ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightText( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeHighlight( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction _normalizeToElementConfig( view, viewElementType ) {\n\tif ( typeof view == 'function' ) {\n\t\t// If `view` is already a function, don't do anything.\n\t\treturn view;\n\t}\n\n\treturn ( modelData, viewWriter ) => _createViewElementFromDefinition( view, viewWriter, viewElementType );\n}\n\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/writer~Writer} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction _createViewElementFromDefinition( viewElementDefinition, viewWriter, viewElementType ) {\n\tif ( typeof viewElementDefinition == 'string' ) {\n\t\t// If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n\t\tviewElementDefinition = { name: viewElementDefinition };\n\t}\n\n\tlet element;\n\tconst attributes = Object.assign( {}, viewElementDefinition.attributes );\n\n\tif ( viewElementType == 'container' ) {\n\t\telement = viewWriter.createContainerElement( viewElementDefinition.name, attributes );\n\t} else if ( viewElementType == 'attribute' ) {\n\t\tconst options = {\n\t\t\tpriority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n\t\t};\n\n\t\telement = viewWriter.createAttributeElement( viewElementDefinition.name, attributes, options );\n\t} else {\n\t\t// 'ui'.\n\t\telement = viewWriter.createUIElement( viewElementDefinition.name, attributes );\n\t}\n\n\tif ( viewElementDefinition.styles ) {\n\t\tconst keys = Object.keys( viewElementDefinition.styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tviewWriter.setStyle( key, viewElementDefinition.styles[ key ], element );\n\t\t}\n\t}\n\n\tif ( viewElementDefinition.classes ) {\n\t\tconst classes = viewElementDefinition.classes;\n\n\t\tif ( typeof classes == 'string' ) {\n\t\t\tviewWriter.addClass( classes, element );\n\t\t} else {\n\t\t\tfor ( const className of classes ) {\n\t\t\t\tviewWriter.addClass( className, element );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element;\n}\n\nfunction _getFromAttributeCreator( config ) {\n\tif ( config.model.values ) {\n\t\treturn ( modelAttributeValue, viewWriter ) => {\n\t\t\tconst view = config.view[ modelAttributeValue ];\n\n\t\t\tif ( view ) {\n\t\t\t\treturn view( modelAttributeValue, viewWriter );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\t} else {\n\t\treturn config.view;\n\t}\n}\n\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction _normalizeToAttributeConfig( view ) {\n\tif ( typeof view == 'string' ) {\n\t\treturn modelAttributeValue => ( { key: view, value: modelAttributeValue } );\n\t} else if ( typeof view == 'object' ) {\n\t\t// { key, value, ... }\n\t\tif ( view.value ) {\n\t\t\treturn () => view;\n\t\t}\n\t\t// { key, ... }\n\t\telse {\n\t\t\treturn modelAttributeValue => ( { key: view.key, value: modelAttributeValue } );\n\t\t}\n\t} else {\n\t\t// function.\n\t\treturn view;\n\t}\n}\n\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, viewWriter ) => {\n *\t\t\t\tconst text = viewWriter.createText( 'myText' );\n *\t\t\t\tconst myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewElement = elementCreator( data.item, conversionApi.writer );\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\t\tconst viewText = viewWriter.createText( data.item.data );\n\n\t\tviewWriter.insert( viewPosition, viewText );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Find view range start position by mapping model position at which the remove happened.\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position );\n\n\t\tconst modelEnd = data.position.getShiftedBy( data.length );\n\t\tconst viewEnd = conversionApi.mapper.toViewPosition( modelEnd, { isPhantom: true } );\n\n\t\tconst viewRange = new ViewRange( viewStart, viewEnd );\n\n\t\t// Trim the range to remove in case some UI elements are on the view range boundaries.\n\t\tconst removed = conversionApi.writer.remove( viewRange.getTrimmed() );\n\n\t\t// After the range is removed, unbind all view elements from the model.\n\t\t// Range inside view document fragment is used to unbind deeply.\n\t\tfor ( const child of ViewRange.createIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Create two view elements. One will be inserted at the beginning of marker, one at the end.\n\t\t// If marker is collapsed, only \"opening\" element will be inserted.\n\t\tdata.isOpening = true;\n\t\tconst viewStartElement = elementCreator( data, conversionApi.writer );\n\n\t\tdata.isOpening = false;\n\t\tconst viewEndElement = elementCreator( data, conversionApi.writer );\n\n\t\tif ( !viewStartElement || !viewEndElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\t// Marker that is collapsed has consumable build differently that non-collapsed one.\n\t\t// For more information see `addMarker` event description.\n\t\t// If marker's range is collapsed - check if it can be consumed.\n\t\tif ( markerRange.isCollapsed && !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If marker's range is not collapsed - consume all items inside.\n\t\tfor ( const value of markerRange ) {\n\t\t\tif ( !conversionApi.consumable.consume( value.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst mapper = conversionApi.mapper;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// Add \"opening\" element.\n\t\tviewWriter.insert( mapper.toViewPosition( markerRange.start ), viewStartElement );\n\t\tconversionApi.mapper.bindElementToMarker( viewStartElement, data.markerName );\n\n\t\t// Add \"closing\" element only if range is not collapsed.\n\t\tif ( !markerRange.isCollapsed ) {\n\t\t\tviewWriter.insert( mapper.toViewPosition( markerRange.end ), viewEndElement );\n\t\t\tconversionApi.mapper.bindElementToMarker( viewEndElement, data.markerName );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n/**\n * Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n * basing on marker remove change.\n *\n * This converter unbinds elements from the marker name.\n *\n * @returns {Function} Removed UI element converter.\n */\nexport function removeUIElement() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.mapper.unbindElementsFromMarkerName( data.markerName );\n\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\tfor ( const element of elements ) {\n\t\t\tviewWriter.clear( ViewRange.createOn( element ), element );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n *\n * Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n * a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n * attributes on a one-to-one basis.\n *\n * **Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n *\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n *\t\t\tconst key = 'class';\n *\t\t\tlet value = data.attributeNewValue;\n *\n *\t\t\t// Force attribute value to 'empty' if the model element is empty.\n *\t\t\tif ( data.item.childCount === 0 ) {\n *\t\t\t\tvalue = 'empty';\n *\t\t\t}\n *\n *\t\t\t// Return the key-value pair.\n *\t\t\treturn { key, value };\n *\t\t} ) );\n *\n * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n * represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n * The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n * @returns {Function} Set/change attribute converter.\n */\nexport function changeAttribute( attributeCreator ) {\n\tattributeCreator = attributeCreator || ( ( value, data ) => ( { value, key: data.attributeKey } ) );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst oldAttribute = attributeCreator( data.attributeOldValue, data );\n\t\tconst newAttribute = attributeCreator( data.attributeNewValue, data );\n\n\t\tif ( !oldAttribute && !newAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// First remove the old attribute if there was one.\n\t\tif ( data.attributeOldValue !== null && oldAttribute ) {\n\t\t\tif ( oldAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( oldAttribute.value ) ? oldAttribute.value : [ oldAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.removeClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( oldAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( oldAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.removeStyle( key, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.removeAttribute( oldAttribute.key, viewElement );\n\t\t\t}\n\t\t}\n\n\t\t// Then set the new attribute.\n\t\tif ( data.attributeNewValue !== null && newAttribute ) {\n\t\t\tif ( newAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( newAttribute.value ) ? newAttribute.value : [ newAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.addClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( newAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( newAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.setStyle( key, newAttribute.value[ key ], viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.setAttribute( newAttribute.key, newAttribute.value, viewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrapItem( ( modelAttributeValue, viewWriter ) => {\n *\t\t\treturn viewWriter.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n\t\t// or the attribute was removed.\n\t\tconst oldViewElement = elementCreator( data.attributeOldValue, conversionApi.writer );\n\n\t\t// Create node to wrap with.\n\t\tconst newViewElement = elementCreator( data.attributeNewValue, conversionApi.writer );\n\n\t\tif ( !oldViewElement && !newViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\t// Selection attribute conversion.\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), newViewElement );\n\t\t} else {\n\t\t\t// Node attribute conversion.\n\t\t\tlet viewRange = conversionApi.mapper.toViewRange( data.range );\n\n\t\t\t// First, unwrap the range from current wrapper.\n\t\t\tif ( data.attributeOldValue !== null && oldViewElement ) {\n\t\t\t\tviewRange = viewWriter.unwrap( viewRange, oldViewElement );\n\t\t\t}\n\n\t\t\tif ( data.attributeNewValue !== null && newViewElement ) {\n\t\t\t\tviewWriter.wrap( viewRange, newViewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n * {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n * See {link module:engine/conversion/downcast-converters~createViewElementFromHighlightDescriptor}.\n *\n * It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n * created and the selection will be put inside it.\n *\n * If the highlight descriptor does not provide the `priority` property, `10` will be used.\n *\n * If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n *\n * This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n * using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n *\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor|Function} highlightDescriptor\n * @returns {Function}\n */\nexport function highlightText( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) && !data.item.is( 'textProxy' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = _prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = createViewElementFromHighlightDescriptor( descriptor );\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), viewElement, viewSelection );\n\t\t} else {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( data.range );\n\t\t\tconst rangeAfterWrap = viewWriter.wrap( viewRange, viewElement );\n\n\t\t\tfor ( const element of rangeAfterWrap.getItems() ) {\n\t\t\t\tif ( element.is( 'attributeElement' ) && element.isSimilar( viewElement ) ) {\n\t\t\t\t\tconversionApi.mapper.bindElementToMarker( element, data.markerName );\n\n\t\t\t\t\t// One attribute element is enough, because all of them are bound together by the view writer.\n\t\t\t\t\t// Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n *\n * The converter checks if an element has the `addHighlight` function stored as a\n * {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n * In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n *\n * When the `addHighlight` custom property is not present, the element is not converted in any special way.\n * This means that converters will proceed to convert the element's child nodes.\n *\n * If the highlight descriptor does not provide the `priority` property, `10` will be used.\n *\n * If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n *\n * This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n * the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n *\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor|Function} highlightDescriptor\n * @returns {Function}\n */\nexport function highlightElement( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelElement ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = _prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\tif ( viewElement && viewElement.getCustomProperty( 'addHighlight' ) ) {\n\t\t\t// Consume element itself.\n\t\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\t\t// Consume all children nodes.\n\t\t\tfor ( const value of ModelRange.createIn( data.item ) ) {\n\t\t\t\tconversionApi.consumable.consume( value.item, evt.name );\n\t\t\t}\n\n\t\t\tviewElement.getCustomProperty( 'addHighlight' )( viewElement, descriptor, conversionApi.writer );\n\n\t\t\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts the removing model marker to the view.\n *\n * Both text nodes and elements are handled by this converter but they are handled a bit differently.\n *\n * Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n * provided highlight descriptor. See {link module:engine/conversion/downcast-converters~HighlightDescriptor}.\n *\n * For elements, the converter checks if an element has the `removeHighlight` function stored as a\n * {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n * In such case, the children of that element will not be converted.\n *\n * When `removeHighlight` is not present, the element is not converted in any special way.\n * The converter will proceed to convert the element's child nodes instead.\n *\n * If the highlight descriptor does not provide the `priority` property, `10` will be used.\n *\n * If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n *\n * This converter unbinds elements from the marker name.\n *\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor|Function} highlightDescriptor\n * @returns {Function}\n */\nexport function removeHighlight( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This conversion makes sense only for non-collapsed range.\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = _prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// View element that will be used to unwrap `AttributeElement`s.\n\t\tconst viewHighlightElement = createViewElementFromHighlightDescriptor( descriptor );\n\n\t\t// Get all elements bound with given marker name.\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.mapper.unbindElementsFromMarkerName( data.markerName );\n\n\t\tfor ( const element of elements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tconversionApi.writer.unwrap( ViewRange.createOn( element ), viewHighlightElement );\n\t\t\t} else {\n\t\t\t\t// if element.is( 'containerElement' ).\n\t\t\t\telement.getCustomProperty( 'removeHighlight' )( element, descriptor.id, conversionApi.writer );\n\t\t\t}\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction _prepareDescriptor( highlightDescriptor, data, conversionApi ) {\n\t// If passed descriptor is a creator function, call it. If not, just use passed value.\n\tconst descriptor = typeof highlightDescriptor == 'function' ?\n\t\thighlightDescriptor( data, conversionApi ) :\n\t\thighlightDescriptor;\n\n\tif ( !descriptor ) {\n\t\treturn null;\n\t}\n\n\t// Apply default descriptor priority.\n\tif ( !descriptor.priority ) {\n\t\tdescriptor.priority = 10;\n\t}\n\n\t// Default descriptor id is marker name.\n\tif ( !descriptor.id ) {\n\t\tdescriptor.id = data.markerName;\n\t}\n\n\treturn descriptor;\n}\n\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcast-converters~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor( descriptor ) {\n\tconst viewElement = new ViewAttributeElement( 'span', descriptor.attributes );\n\n\tif ( descriptor.classes ) {\n\t\tviewElement._addClass( descriptor.classes );\n\t}\n\n\tif ( descriptor.priority ) {\n\t\tviewElement._priority = descriptor.priority;\n\t}\n\n\tviewElement._id = descriptor.id;\n\n\treturn viewElement;\n}\n\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcast-converters~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/controller/editingcontroller\n */\n\nimport RootEditableElement from '../view/rooteditableelement';\nimport View from '../view/view';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText, remove } from '../conversion/downcast-converters';\nimport { convertSelectionChange } from '../conversion/upcast-selection-converters';\nimport { clearAttributes, convertCollapsedSelection, convertRangeSelection } from '../conversion/downcast-selection-converters';\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Controller for the editing pipeline. The editing pipeline controls {@link ~EditingController#model model} rendering,\n * including selection handling. It also creates the {@link ~EditingController#view view} which builds a\n * browser-independent virtualization over the DOM elements. The editing controller also attaches default converters.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class EditingController {\n\t/**\n\t * Creates an editing controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Editing model.\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * Editor model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Editing view controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/view~View}\n\t\t */\n\t\tthis.view = new View();\n\n\t\t/**\n\t\t * Mapper which describes the model-view binding.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher that converts changes from the model to {@link #view the editing view}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #downcastDispatcher\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper\n\t\t} );\n\n\t\tconst doc = this.model.document;\n\t\tconst selection = doc.selection;\n\t\tconst markers = this.model.markers;\n\n\t\t// Whenever model document is changed, convert those changes to the view (using model.Document#differ).\n\t\t// Do it on 'low' priority, so changes are converted after other listeners did their job.\n\t\t// Also convert model selection.\n\t\tthis.listenTo( doc, 'change', () => {\n\t\t\tthis.view.change( writer => {\n\t\t\t\tthis.downcastDispatcher.convertChanges( doc.differ, writer );\n\t\t\t\tthis.downcastDispatcher.convertSelection( selection, markers, writer );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\n\t\t// Convert selection from the view to the model when it changes in the view.\n\t\tthis.listenTo( this.view.document, 'selectionChange', convertSelectionChange( this.model, this.mapper ) );\n\n\t\t// Attach default model converters.\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\t\tthis.downcastDispatcher.on( 'remove', remove(), { priority: 'low' } );\n\n\t\t// Attach default model selection converters.\n\t\tthis.downcastDispatcher.on( 'selection', clearAttributes(), { priority: 'low' } );\n\t\tthis.downcastDispatcher.on( 'selection', convertRangeSelection(), { priority: 'low' } );\n\t\tthis.downcastDispatcher.on( 'selection', convertCollapsedSelection(), { priority: 'low' } );\n\n\t\t// Binds {@link module:engine/view/document~Document#roots view roots collection} to\n\t\t// {@link module:engine/model/document~Document#roots model roots collection} so creating\n\t\t// model root automatically creates corresponding view root.\n\t\tthis.view.document.roots.bindTo( this.model.document.roots ).using( root => {\n\t\t\t// $graveyard is a special root that has no reflection in the view.\n\t\t\tif ( root.rootName == '$graveyard' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewRoot = new RootEditableElement( root.name );\n\n\t\t\tviewRoot.rootName = root.rootName;\n\t\t\tviewRoot._document = this.view.document;\n\t\t\tthis.mapper.bindElements( root, viewRoot );\n\n\t\t\treturn viewRoot;\n\t\t} );\n\t}\n\n\t/**\n\t * Removes all event listeners attached to the `EditingController`. Destroys all objects created\n\t * by `EditingController` that need to be destroyed.\n\t */\n\tdestroy() {\n\t\tthis.view.destroy();\n\t\tthis.stopListening();\n\t}\n}\n\nmix( EditingController, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Contains {@link module:engine/view/documentselection~DocumentSelection view selection}\n * to {@link module:engine/model/selection~Selection model selection} conversion helpers.\n *\n * @module engine/conversion/upcast-selection-converters\n */\n\nimport ModelSelection from '../model/selection';\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\t\tconst modelSelection = new ModelSelection();\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tmodelSelection.setTo( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Contains {@link module:engine/model/selection~Selection model selection} to\n * {@link module:engine/view/documentselection~DocumentSelection view selection} converters for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}.\n *\n * @module engine/conversion/downcast-selection-converters\n */\n\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( range );\n\t\t\tviewRanges.push( viewRange );\n\t\t}\n\n\t\tconversionApi.writer.setSelection( viewRanges, { backward: selection.isBackward } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcast-selection-converters~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst modelPosition = selection.getFirstPosition();\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\t\tconst brokenPosition = viewWriter.breakAttributes( viewPosition );\n\n\t\tviewWriter.setSelection( brokenPosition );\n\t};\n}\n\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcast-selection-converters~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t// Not collapsed selection should not have artifacts.\n\t\t\tif ( range.isCollapsed ) {\n\t\t\t\t// Position might be in the node removed by the view writer.\n\t\t\t\tif ( range.end.parent.document ) {\n\t\t\t\t\tconversionApi.writer.mergeAttributes( range.start );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tviewWriter.setSelection( null );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/plugincollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n */\nexport default class PluginCollection {\n\t/**\n\t * Creates an instance of the PluginCollection class.\n\t * Allows loading and initializing plugins and their dependencies.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n\t * when {@link module:core/plugincollection~PluginCollection#load} is used with plugin names (strings, instead of constructors).\n\t * Usually, the editor will pass its built-in plugins to the collection so they can later be\n\t * used in `config.plugins` or `config.removePlugins` by names.\n\t */\n\tconstructor( editor, availablePlugins = [] ) {\n\t\t/**\n\t\t * @protected\n\t\t * @member {module:core/editor/editor~Editor} module:core/plugin~PluginCollection#_editor\n\t\t */\n\t\tthis._editor = editor;\n\n\t\t/**\n\t\t * Map of plugin constructors which can be retrieved by their names.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<String|Function,Function>} module:core/plugin~PluginCollection#_availablePlugins\n\t\t */\n\t\tthis._availablePlugins = new Map();\n\n\t\t/**\n\t\t * @protected\n\t\t * @member {Map} module:core/plugin~PluginCollection#_plugins\n\t\t */\n\t\tthis._plugins = new Map();\n\n\t\tfor ( const PluginConstructor of availablePlugins ) {\n\t\t\tthis._availablePlugins.set( PluginConstructor, PluginConstructor );\n\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tfor ( const entry of this._plugins ) {\n\t\t\tif ( typeof entry[ 0 ] == 'function' ) {\n\t\t\t\tyield entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the plugin instance by its constructor or name.\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {module:core/plugin~PluginInterface}\n\t */\n\tget( key ) {\n\t\treturn this._plugins.get( key );\n\t}\n\n\t/**\n\t * Loads a set of plugins and adds them to the collection.\n\t *\n\t * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n\t * `availablePlugins` were passed to the {@link #constructor}.\n\t * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n\t * that should not be loaded (despite being specified in the `plugins` array).\n\t * @returns {Promise} A promise which gets resolved once all plugins are loaded and available in the\n\t * collection.\n\t * @returns {Promise.<Array.<module:core/plugin~PluginInterface>>} returns.loadedPlugins The array of loaded plugins.\n\t */\n\tload( plugins, removePlugins = [] ) {\n\t\tconst that = this;\n\t\tconst editor = this._editor;\n\t\tconst loading = new Set();\n\t\tconst loaded = [];\n\n\t\tconst pluginConstructors = mapToAvailableConstructors( plugins );\n\t\tconst removePluginConstructors = mapToAvailableConstructors( removePlugins );\n\t\tconst missingPlugins = getMissingPluginNames( plugins );\n\n\t\tif ( missingPlugins ) {\n\t\t\t/**\n\t\t\t * Some plugins are not available and could not be loaded.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n\t\t\t * that you try to enable a plugin which was not included in that build. This may be due to a typo\n\t\t\t * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n\t\t\t * read more about {@glink builds/guides/development/custom-builds custom builds}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n\t\t\t * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n\t\t\t * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n\t\t\t * provide each plugin through reference (as a constructor function). Check out the examples in\n\t\t\t * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-found\n\t\t\t * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n\t\t\t */\n\t\t\tconst errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';\n\n\t\t\t// Log the error so it's more visible on the console. Hopefully, for better DX.\n\t\t\tlog.error( errorMsg, { plugins: missingPlugins } );\n\n\t\t\treturn Promise.reject( new CKEditorError( errorMsg, { plugins: missingPlugins } ) );\n\t\t}\n\n\t\treturn Promise.all( pluginConstructors.map( loadPlugin ) )\n\t\t\t.then( () => loaded );\n\n\t\tfunction loadPlugin( PluginConstructor ) {\n\t\t\tif ( removePluginConstructors.includes( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The plugin is already loaded or being loaded - do nothing.\n\t\t\tif ( that.get( PluginConstructor ) || loading.has( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn instantiatePlugin( PluginConstructor )\n\t\t\t\t.catch( err => {\n\t\t\t\t\t/**\n\t\t\t\t\t * It was not possible to load the plugin.\n\t\t\t\t\t *\n\t\t\t\t\t * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n\t\t\t\t\t * of one of the plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * If you correctly handled the promise returned by the editor's `create()` method (like shown below)\n\t\t\t\t\t * you will find the original error logged to the console, too:\n\t\t\t\t\t *\n\t\t\t\t\t *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n\t\t\t\t\t *\t\t\t.then( editor => {\n\t\t\t\t\t *\t\t\t\t// ...\n\t\t\t\t\t * \t\t\t} )\n\t\t\t\t\t *\t\t\t.catch( error => {\n\t\t\t\t\t *\t\t\t\tconsole.error( error );\n\t\t\t\t\t *\t\t\t} );\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-load\n\t\t\t\t\t * @param {String} plugin The name of the plugin that could not be loaded.\n\t\t\t\t\t */\n\t\t\t\t\tlog.error( 'plugincollection-load: It was not possible to load the plugin.', { plugin: PluginConstructor } );\n\n\t\t\t\t\tthrow err;\n\t\t\t\t} );\n\t\t}\n\n\t\tfunction instantiatePlugin( PluginConstructor ) {\n\t\t\treturn new Promise( resolve => {\n\t\t\t\tloading.add( PluginConstructor );\n\n\t\t\t\tif ( PluginConstructor.requires ) {\n\t\t\t\t\tPluginConstructor.requires.forEach( RequiredPluginConstructorOrName => {\n\t\t\t\t\t\tconst RequiredPluginConstructor = getPluginConstructor( RequiredPluginConstructorOrName );\n\n\t\t\t\t\t\tif ( removePlugins.includes( RequiredPluginConstructor ) ) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * @error plugincollection-required\n\t\t\t\t\t\t\t * @param {Function} plugin The required plugin.\n\t\t\t\t\t\t\t * @param {Function} requiredBy The parent plugin.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t\t\t'plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' +\n\t\t\t\t\t\t\t\t'the `removePlugins` option.',\n\t\t\t\t\t\t\t\t{ plugin: RequiredPluginConstructor, requiredBy: PluginConstructor }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadPlugin( RequiredPluginConstructor );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tconst plugin = new PluginConstructor( editor );\n\t\t\t\tthat._add( PluginConstructor, plugin );\n\t\t\t\tloaded.push( plugin );\n\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginConstructor( PluginConstructorOrName ) {\n\t\t\tif ( typeof PluginConstructorOrName == 'function' ) {\n\t\t\t\treturn PluginConstructorOrName;\n\t\t\t}\n\n\t\t\treturn that._availablePlugins.get( PluginConstructorOrName );\n\t\t}\n\n\t\tfunction getMissingPluginNames( plugins ) {\n\t\t\tconst missingPlugins = [];\n\n\t\t\tfor ( const pluginNameOrConstructor of plugins ) {\n\t\t\t\tif ( !getPluginConstructor( pluginNameOrConstructor ) ) {\n\t\t\t\t\tmissingPlugins.push( pluginNameOrConstructor );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn missingPlugins.length ? missingPlugins : null;\n\t\t}\n\n\t\tfunction mapToAvailableConstructors( plugins ) {\n\t\t\treturn plugins\n\t\t\t\t.map( pluginNameOrConstructor => getPluginConstructor( pluginNameOrConstructor ) )\n\t\t\t\t.filter( PluginConstructor => !!PluginConstructor );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all loaded plugins.\n\t *\n\t * @returns {Promise}\n\t */\n\tdestroy() {\n\t\tconst promises = Array.from( this )\n\t\t\t.map( ( [ , pluginInstance ] ) => pluginInstance )\n\t\t\t.filter( pluginInstance => typeof pluginInstance.destroy == 'function' )\n\t\t\t.map( pluginInstance => pluginInstance.destroy() );\n\n\t\treturn Promise.all( promises );\n\t}\n\n\t/**\n\t * Adds the plugin to the collection. Exposed mainly for testing purposes.\n\t *\n\t * @protected\n\t * @param {Function} PluginConstructor The plugin constructor.\n\t * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n\t */\n\t_add( PluginConstructor, plugin ) {\n\t\tthis._plugins.set( PluginConstructor, plugin );\n\n\t\tconst pluginName = PluginConstructor.pluginName;\n\n\t\tif ( !pluginName ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._plugins.has( pluginName ) ) {\n\t\t\t/**\n\t\t\t * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n\t\t\t * This will lead to runtime conflicts between these plugins.\n\t\t\t *\n\t\t\t * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n\t\t\t * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n\t\t\t * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n\t\t\t *\n\t\t\t * Check your import paths and the list of plugins passed to\n\t\t\t * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t\t * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n\t\t\t *\n\t\t\t * The second option is that your `node_modules/` directory contains duplicated versions of the same\n\t\t\t * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n\t\t\t * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n\t\t\t * of packages, their dependencies may need to be installed in more than one version which may lead to this\n\t\t\t * warning.\n\t\t\t *\n\t\t\t * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n\t\t\t * dependencies of this plugin are being duplicated.\n\t\t\t * They are already built into that editor build and now get added for the second time as dependencies\n\t\t\t * of the plugin you are installing.\n\t\t\t *\n\t\t\t * Read more about {@glink builds/guides/development/installing-plugins installing plugins}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-name-conflict\n\t\t\t * @param {String} pluginName The duplicated plugin name.\n\t\t\t * @param {Function} plugin1 The first plugin constructor.\n\t\t\t * @param {Function} plugin2 The second plugin constructor.\n\t\t\t */\n\t\t\tlog.warn(\n\t\t\t\t'plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',\n\t\t\t\t{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }\n\t\t\t);\n\t\t} else {\n\t\t\tthis._plugins.set( pluginName, plugin );\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/commandcollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Collection of commands. Its instance is available in {@link module:core/editor/editor~Editor#commands `editor.commands`}.\n */\nexport default class CommandCollection {\n\t/**\n\t * Creates collection instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Command map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._commands = new Map();\n\t}\n\n\t/**\n\t * Registers a new command.\n\t *\n\t * @param {String} commandName The name of the command.\n\t * @param {module:core/command~Command} command\n\t */\n\tadd( commandName, command ) {\n\t\tthis._commands.set( commandName, command );\n\t}\n\n\t/**\n\t * Retrieves a command from the collection.\n\t *\n\t * @param {String} commandName The name of the command.\n\t * @returns {module:core/command~Command}\n\t */\n\tget( commandName ) {\n\t\treturn this._commands.get( commandName );\n\t}\n\n\t/**\n\t * Executes a command.\n\t *\n\t * @param {String} commandName The name of the command.\n\t */\n\texecute( commandName, ...args ) {\n\t\tconst command = this.get( commandName );\n\n\t\tif ( !command ) {\n\t\t\t/**\n\t\t\t * Command does not exist.\n\t\t\t *\n\t\t\t * @error commandcollection-command-not-found\n\t\t\t * @param {String} commandName Name of the command.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'commandcollection-command-not-found: Command does not exist.', { commandName } );\n\t\t}\n\n\t\tcommand.execute( ...args );\n\t}\n\n\t/**\n\t * Returns iterator of command names.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* names() {\n\t\tyield* this._commands.keys();\n\t}\n\n\t/**\n\t * Returns iterator of command instances.\n\t *\n\t * @returns {Iterable.<module:core/command~Command>}\n\t */\n\t* commands() {\n\t\tyield* this._commands.values();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ commandName, commandInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._commands[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Destroys all collection commands.\n\t */\n\tdestroy() {\n\t\tfor ( const command of this.commands() ) {\n\t\t\tcommand.destroy();\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window */\n\n/**\n * @module utils/translation-service\n */\n\n/* istanbul ignore else */\nif ( !window.CKEDITOR_TRANSLATIONS ) {\n\twindow.CKEDITOR_TRANSLATIONS = {};\n}\n\n/**\n * Adds translations to existing ones.\n * These translations will later be available for the {@link module:utils/translation-service~translate `translate()`} function.\n *\n *\t\tadd( 'pl', {\n *\t\t\t'OK': 'OK',\n *\t\t\t'Cancel [context: reject]': 'Anuluj'\n *\t\t} );\n *\n * If you cannot import this function from this module (e.g. because you use a CKEditor 5 build), then you can\n * still add translations by extending the global `window.CKEDITOR_TRANSLATIONS` object by using a function like\n * the one below:\n *\n *\t\tfunction addTranslations( language, translations ) {\n *\t\t\tif ( !window.CKEDITOR_TRANSLATIONS ) {\n *\t\t\t\twindow.CKEDITOR_TRANSLATIONS = {};\n *\t\t\t}\n *\n *\t\t\tconst dictionary = window.CKEDITOR_TRANSLATIONS[ language ] || ( window.CKEDITOR_TRANSLATIONS[ language ] = {} );\n *\n *\t\t\t// Extend the dictionary for the given language.\n *\t\t\tObject.assign( dictionary, translations );\n *\t\t}\n *\n * @param {String} language Target language.\n * @param {Object.<String, String>} translations Translations which will be added to the dictionary.\n */\nexport function add( language, translations ) {\n\tconst dictionary = window.CKEDITOR_TRANSLATIONS[ language ] || ( window.CKEDITOR_TRANSLATIONS[ language ] = {} );\n\n\tObject.assign( dictionary, translations );\n}\n\n/**\n * Translates string if the translation of the string was previously added to the dictionary.\n * See {@link module:utils/translation-service Translation Service}.\n * This happens in a multi-language mode were translation modules are created by the bundler.\n *\n * When no translation is defined in the dictionary or the dictionary doesn't exist this function returns\n * the original string without the `'[context: ]'` (happens in development and single-language modes).\n *\n * In a single-language mode (when values passed to `t()` were replaced with target language strings) the dictionary\n * is left empty, so this function will return the original strings always.\n *\n *\t\ttranslate( 'pl', 'Cancel [context: reject]' );\n *\n * @param {String} language Target language.\n * @param {String} translationKey String that will be translated.\n * @returns {String} Translated sentence.\n */\nexport function translate( language, translationKey ) {\n\tconst numberOfLanguages = getNumberOfLanguages();\n\n\tif ( numberOfLanguages === 1 ) {\n\t\t// Override the language to the only supported one.\n\t\t// This can't be done in the `Locale` class, because the translations comes after the `Locale` class initialization.\n\t\tlanguage = Object.keys( window.CKEDITOR_TRANSLATIONS )[ 0 ];\n\t}\n\n\tif ( numberOfLanguages === 0 || !hasTranslation( language, translationKey ) ) {\n\t\treturn translationKey.replace( / \\[context: [^\\]]+\\]$/, '' );\n\t}\n\n\tconst dictionary = window.CKEDITOR_TRANSLATIONS[ language ];\n\n\t// In case of missing translations we still need to cut off the `[context: ]` parts.\n\treturn dictionary[ translationKey ].replace( / \\[context: [^\\]]+\\]$/, '' );\n}\n\n/**\n * Clears dictionaries for test purposes.\n *\n * @protected\n */\nexport function _clear() {\n\twindow.CKEDITOR_TRANSLATIONS = {};\n}\n\n// Checks whether the dictionary exists and translation in that dictionary exists.\nfunction hasTranslation( language, translationKey ) {\n\treturn (\n\t\t( language in window.CKEDITOR_TRANSLATIONS ) &&\n\t\t( translationKey in window.CKEDITOR_TRANSLATIONS[ language ] )\n\t);\n}\n\nfunction getNumberOfLanguages() {\n\treturn Object.keys( window.CKEDITOR_TRANSLATIONS ).length;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/locale\n */\n\nimport { translate } from './translation-service';\n\n/**\n * Represents the localization services.\n */\nexport default class Locale {\n\t/**\n\t * Creates a new instance of the Locale class.\n\t *\n\t * @param {String} [language='en'] The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.\n\t */\n\tconstructor( language ) {\n\t\t/**\n\t\t * The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.language = language || 'en';\n\n\t\t/**\n\t\t * Translates the given string to the {@link #language}. This method is also available in {@link module:core/editor/editor~Editor#t}\n\t\t * and {@link module:ui/view~View#t}.\n\t\t *\n\t\t * The strings may contain placeholders (`%<index>`) for values which are passed as the second argument.\n\t\t * `<index>` is the index in the `values` array.\n\t\t *\n\t\t *\t\teditor.t( 'Created file \"%0\" in %1ms.', [ fileName, timeTaken ] );\n\t\t *\n\t\t * This method's context is statically bound to Locale instance,\n\t\t * so it can be called as a function:\n\t\t *\n\t\t *\t\tconst t = this.t;\n\t\t *\t\tt( 'Label' );\n\t\t *\n\t\t * @method #t\n\t\t * @param {String} str The string to translate.\n\t\t * @param {String[]} values Values that should be used to interpolate the string.\n\t\t */\n\t\tthis.t = ( ...args ) => this._t( ...args );\n\t}\n\n\t/**\n\t * Base for the {@link #t} method.\n\t *\n\t * @private\n\t */\n\t_t( str, values ) {\n\t\tlet translatedString = translate( this.language, str );\n\n\t\tif ( values ) {\n\t\t\ttranslatedString = translatedString.replace( /%(\\d+)/g, ( match, index ) => {\n\t\t\t\treturn ( index < values.length ) ? values[ index ] : match;\n\t\t\t} );\n\t\t}\n\n\t\treturn translatedString;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/viewconsumable\n */\n\nimport isArray from '@ckeditor/ckeditor5-utils/src/lib/lodash/isArray';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n\t/**\n\t * Creates new ViewConsumable.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n\t\t * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n\t\t * For {@link module:engine/view/text~Text text nodes} and\n\t\t * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n\t\t*/\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n\t *\n\t *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n\t *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n\t *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n\t *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n\t *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n\t *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n\t *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing actual style/class.\n\t *\n\t *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\tadd( element, consumables ) {\n\t\tlet elementConsumables;\n\n\t\t// For text nodes and document fragments just mark them as consumable.\n\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\tthis._consumables.set( element, true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// For elements create new ViewElementConsumables or update already existing one.\n\t\tif ( !this._consumables.has( element ) ) {\n\t\t\telementConsumables = new ViewElementConsumables();\n\t\t\tthis._consumables.set( element, elementConsumables );\n\t\t} else {\n\t\t\telementConsumables = this._consumables.get( element );\n\t\t}\n\n\t\telementConsumables.add( consumables );\n\t}\n\n\t/**\n\t * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n\t * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n\t * first already consumed item is found and `null` when first non-consumable item is found.\n\t *\n\t *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n\t *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n\t *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n\t *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n\t *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n\t *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n\t *\t\tviewConsumable.test( textNode ); // Tests text node.\n\t *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n\t *\n\t * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n\t *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n\t * when first already consumed item is found and `null` when first non-consumable item is found.\n\t */\n\ttest( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// For text nodes and document fragments return stored boolean value.\n\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\treturn elementConsumables;\n\t\t}\n\n\t\t// For elements test consumables object.\n\t\treturn elementConsumables.test( consumables );\n\t}\n\n\t/**\n\t * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n\t *\n\t *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n\t *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n\t *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n\t *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n\t *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n\t *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n\t *\n\t * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n\t *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n\t * otherwise returns `false`.\n\t */\n\tconsume( element, consumables ) {\n\t\tif ( this.test( element, consumables ) ) {\n\t\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments set value to false.\n\t\t\t\tthis._consumables.set( element, false );\n\t\t\t} else {\n\t\t\t\t// For elements - consume consumables object.\n\t\t\t\tthis._consumables.get( element ).consume( consumables );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n\t * Method does not revert items that were never previously added for consumption, even if they are included in\n\t * method's call.\n\t *\n\t *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n\t *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n\t *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n\t *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n\t *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n\t *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n\t *\n\t * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n\t * consumption.\n\t *\n\t *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n\t *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\trevert( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables !== undefined ) {\n\t\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments - set consumable to true.\n\t\t\t\tthis._consumables.set( element, true );\n\t\t\t} else {\n\t\t\t\t// For elements - revert items from consumables object.\n\t\t\t\telementConsumables.revert( consumables );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n\t * element's name and all its attributes, classes and styles.\n\t *\n\t * @static\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Object} consumables\n\t */\n\tstatic consumablesFromElement( element ) {\n\t\tconst consumables = {\n\t\t\tname: true,\n\t\t\tattributes: [],\n\t\t\tclasses: [],\n\t\t\tstyles: []\n\t\t};\n\n\t\tconst attributes = element.getAttributeKeys();\n\n\t\tfor ( const attribute of attributes ) {\n\t\t\t// Skip classes and styles - will be added separately.\n\t\t\tif ( attribute == 'style' || attribute == 'class' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconsumables.attributes.push( attribute );\n\t\t}\n\n\t\tconst classes = element.getClassNames();\n\n\t\tfor ( const className of classes ) {\n\t\t\tconsumables.classes.push( className );\n\t\t}\n\n\t\tconst styles = element.getStyleNames();\n\n\t\tfor ( const style of styles ) {\n\t\t\tconsumables.styles.push( style );\n\t\t}\n\n\t\treturn consumables;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n\t * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n\t *\n\t * @static\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewConsumable` will be created.\n\t * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n\t * to add all consumables. It will be returned instead of a new instance.\n\t */\n\tstatic createFrom( from, instance ) {\n\t\tif ( !instance ) {\n\t\t\tinstance = new ViewConsumable();\n\t\t}\n\n\t\tif ( from.is( 'text' ) ) {\n\t\t\tinstance.add( from );\n\n\t\t\treturn instance;\n\t\t}\n\n\t\t// Add `from` itself, if it is an element.\n\t\tif ( from.is( 'element' ) ) {\n\t\t\tinstance.add( from, ViewConsumable.consumablesFromElement( from ) );\n\t\t}\n\n\t\tif ( from.is( 'documentFragment' ) ) {\n\t\t\tinstance.add( from );\n\t\t}\n\n\t\tfor ( const child of from.getChildren() ) {\n\t\t\tinstance = ViewConsumable.createFrom( child, instance );\n\t\t}\n\n\t\treturn instance;\n\t}\n}\n\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n\t/**\n\t * Creates ViewElementConsumables instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Flag indicating if name of the element can be consumed.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._canConsumeName = null;\n\n\t\t/**\n\t\t * Contains maps of element's consumables: attributes, classes and styles.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._consumables = {\n\t\t\tattributes: new Map(),\n\t\t\tstyles: new Map(),\n\t\t\tclasses: new Map()\n\t\t};\n\t}\n\n\t/**\n\t * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n\t * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n\t * styles still could be consumed):\n\t *\n\t *\t\tconsumables.add( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n\t *\n\t * @param {Object} consumables Object describing which parts of the element can be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n\t */\n\tadd( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._add( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n\t *\n\t * Element's name can be tested:\n\t *\n\t *\t\tconsumables.test( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be tested.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n\t * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n\t * was never marked for consumption and `false` when even one of the items was already consumed.\n\t */\n\ttest( consumables ) {\n\t\t// Check if name can be consumed.\n\t\tif ( consumables.name && !this._canConsumeName ) {\n\t\t\treturn this._canConsumeName;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tconst value = this._test( type, consumables[ type ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return true only if all can be consumed.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n\t * is already consumed - it consumes all consumable items provided.\n\t * Element's name can be consumed:\n\t *\n\t *\t\tconsumables.consume( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n\t */\n\tconsume( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = false;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._consume( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n\t * Element's name can be reverted:\n\t *\n\t *\t\tconsumables.revert( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be reverted.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n\t */\n\trevert( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._revert( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that adds consumables of a given type: attribute, class or style.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * type is provided - it should be handled separately by providing actual style/class type.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_add( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Class and style attributes should be handled separately in\n\t\t\t\t * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n\t\t\t\t *\n\t\t\t\t * What you have done is trying to use:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n\t\t\t\t *\n\t\t\t\t * While each class and style should be registered separately:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n\t\t\t\t *\n\t\t\t\t * @error viewconsumable-invalid-attribute\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'viewconsumable-invalid-attribute: Classes and styles should be handled separately.' );\n\t\t\t}\n\n\t\t\tconsumables.set( name, true );\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that tests consumables of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n\t * consumed and `false` when one of the items is already consumed.\n\t */\n\t_test( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// Check all classes/styles if class/style attribute is tested.\n\t\t\t\tconst value = this._test( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\t\t\t\t// Return null if attribute is not found.\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ( !value ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper method that consumes items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_consume( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for consumption - consume them all.\n\t\t\t\tthis._consume( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconsumables.set( name, false );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that reverts items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_revert( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for reverting - revert them all.\n\t\t\t\tthis._revert( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\n\t\t\t\tif ( value === false ) {\n\t\t\t\t\tconsumables.set( name, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by features and based on them the editing framework and features\n * make decisions how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * # Schema definitions\n *\n * Schema defines allowed model structures and allowed attributes separately. They are also checked separately\n * by using the {@link ~Schema#checkChild} and {@link ~Schema#checkAttribute} methods.\n *\n * ## Defining allowed structures\n *\n * When a feature introduces a model element it should register it in the schema. Besides\n * defining that such an element may exist in the model, the feature also needs to define where\n * this element may be placed:\n *\n *\t\tschema.register( 'myElement', {\n *\t\t\tallowIn: '$root'\n *\t\t} );\n *\n * This lets the schema know that `<myElement>` may be a child of the `<$root>` element. `$root` is one of generic\n * nodes defined by the editing framework. By default, the editor names the main root element a `<$root>`,\n * so the above definition allows `<myElement>` in the main editor element.\n *\n * In other words, this would be correct:\n *\n *\t\t<$root><myElement></myElement></$root>\n *\n * While this would not be correct:\n *\n *\t\t<$root><foo><myElement></myElement></foo></$root>\n *\n * ## Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block'\n *\t\t} );\n *\n * These definitions can then be reused by features to create their own definitions in a more extensible way.\n * For example, the {@link module:paragraph/paragraph~Paragraph} feature will define its item as:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tinheritAllFrom: '$block'\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block'\n *\t\t} );\n *\n * Which can be read as:\n *\n * * The `<paragraph>` element will be allowed in elements in which `<$block>` is allowed (e.g. in `<$root>`).\n * * The `<paragraph>` element will allow all nodes which are allowed in `<$block>` (e.g. `$text`).\n * * The `<paragraph>` element will allow all attributes allowed on `<$block>`.\n * * The `<paragraph>` element will inherit all `is*` properties of `<$block>` (e.g. `isBlock`).\n *\n * Thanks to the fact that `<paragraph>`'s definition is inherited from `<$block>` other features can use the `<$block>`\n * type to indirectly extend `<paragraph>`'s definition. For example, the {@link module:block-quote/blockquote~BlockQuote}\n * feature does this:\n *\n *\t\tschema.register( 'blockQuote', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$root'\n *\t\t} );\n *\n * Thanks to that, despite the fact that block quote and paragraph features know nothing about themselves, paragraphs\n * will be allowed in block quotes and block quotes will be allowed in all places where blocks are. So if anyone will\n * register a `<section>` element (with `allowContentOf: '$root'` rule), that `<section>` elements will allow\n * block quotes too.\n *\n * The side effect of such a definition inheritance is that now `<blockQuote>` is allowed in `<blockQuote>` which needs to be\n * resolved by a callback which will disallow this specific structure.\n *\n * You can read more about the format of an item definition in {@link module:engine/model/schema~SchemaItemDefinition}.\n *\n * ## Defining advanced rules in `checkChild()`'s callbacks\n *\n * The {@link ~Schema#checkChild} method which is the base method used to check whether some element is allowed in a given structure\n * is {@link module:utils/observablemixin~ObservableMixin#decorate a decorated method}.\n * It means that you can add listeners to implement your specific rules which are not limited by the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition API}.\n *\n * Those listeners can be added either by listening directly to the {@link ~Schema#event:checkChild} event or\n * by using the handy {@link ~Schema#addChildCheck} method.\n *\n * For instance, the block quote feature defines such a listener to disallow nested `<blockQuote>` structures:\n *\n *\t\tschema.addChildCheck( context, childDefinition ) => {\n *\t\t\t// Note that context is automatically normalized to SchemaContext instance and\n *\t\t\t// child to its definition (SchemaCompiledItemDefinition).\n *\n *\t\t\t// If checkChild() is called with a context that ends with blockQuote and blockQuote as a child\n *\t\t\t// to check, make the checkChild() method return false.\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'blockQuote' ) {\n *\t\t\t\treturn false;\n *\t\t\t}\n *\t\t} );\n *\n * ## Defining attributes\n *\n * TODO\n *\n * ## Implementing additional constraints\n *\n * Schema's capabilities were limited to simple (and atomic) {@link ~Schema#checkChild} and\n * {@link ~Schema#checkAttribute} checks on purpose.\n * One may imagine that schema should support defining more complex rules such as\n * \"element `<x>` must be always followed by `<y>`\".\n * While it is feasible to create an API which would enable feeding the schema with such definitions,\n * it is unfortunately unrealistic to then expect that every editing feature will consider those rules when processing the model.\n * It is also unrealistic to expect that it will be done automatically by the schema and the editing engine themselves.\n *\n * For instance, let's get back to the \"element `<x>` must be always followed by `<y>`\" rule and this initial content:\n *\n *\t\t<$root>\n *\t\t\t<x>foo</x>\n *\t\t\t<y>bar[bom</y>\n *\t\t\t<z>bom]bar</z>\n *\t\t</$root>\n *\n * Now, imagine that the user presses the \"block quote\" button. Usually it would wrap the two selected blocks\n * (`<y>` and `<z>`) with a `<blockQuote>` element:\n *\n *\t\t<$root>\n *\t\t\t<x>foo</x>\n *\t\t\t<blockQuote>\n *\t\t\t\t<y>bar[bom</y>\n *\t\t\t\t<z>bom]bar</z>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * But it turns out that this creates an incorrect structure – `<x>` is not followed by `<y>` anymore.\n *\n * What should happen instead? There are at least 4 possible solutions: the block quote feature should not be\n * applicable in such a context, someone should create a new `<y>` right after `<x>`, `<x>` should be moved\n * inside `<blockQuote>` together with `<y>` or vice versa.\n *\n * While this is a relatively simple scenario (unlike most real-time collaboration scenarios),\n * it turns out that it's already hard to say what should happen and who should react to fix this content.\n *\n * Therefore, if your editor needs to implement such rules, you should do that through model's post-fixers\n * fixing incorrect content or actively prevent such situations (e.g. by disabling certain features).\n * It means that those constraints will be defined specifically for your scenario by your code which\n * makes their implementation much easier.\n *\n * So the answer for who and how should implement additional constraints is your features or your editor\n * through CKEditor 5's rich and open API.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t// TODO docs\n\t\t\tthrow new CKEditorError( 'schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.', {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t// TODO docs\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.', {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns all registered items.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if item is not registered.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( 'text' ) || item.is( 'textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a limit element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isLimit` or `isObject` property\n\t * (all objects are also limits).\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'image' ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a object element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isObject` property.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'image' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'image' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isObject );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'schema-check-merge-no-element-before: The node before the merge position must be an element.' );\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'schema-check-merge-no-element-after: The node after the merge position must be an element.' );\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addChildCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( [ ...selection.getFirstPosition().getAncestors(), '$text' ], attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Array.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\tgetValidRanges( ranges, attribute ) {\n\t\tconst validRanges = [];\n\n\t\tfor ( const range of ranges ) {\n\t\t\tlet last = range.start;\n\t\t\tlet from = range.start;\n\t\t\tconst to = range.end;\n\n\t\t\tfor ( const value of range.getWalker() ) {\n\t\t\t\tif ( !this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\tif ( !from.isEqual( last ) ) {\n\t\t\t\t\t\tvalidRanges.push( new Range( from, last ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tfrom = value.nextPosition;\n\t\t\t\t}\n\n\t\t\t\tlast = value.nextPosition;\n\t\t\t}\n\n\t\t\tif ( from && !from.isEqual( to ) ) {\n\t\t\t\tvalidRanges.push( new Range( from, to ) );\n\t\t\t}\n\t\t}\n\n\t\treturn validRanges;\n\t}\n\n\t/**\n\t * Basing on given the `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( { startPosition: position, direction: 'backward' } );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( { startPosition: position } );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range.createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allows to insert given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as {@link module:engine/model/schema~Schema#isLimit limit element},\n\t * {@link module:engine/model/schema~Schema#isObject object element} or top-most ancestor won't be reached.\n\t *\n\t * @params {module:engine/model/node~Node} node Node for which allowed parent should be found.\n\t * @params {module:engine/model/position~Position} position Position from searching will start.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( node, position ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\t\t\tif ( !this.checkAttribute( node, attribute ) ) {\n\t\t\t\t\twriter.removeAttribute( attribute, node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( node.is( 'element' ) ) {\n\t\t\t\tthis.removeDisallowedAttributes( node.getChildren(), writer );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior – e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you don't have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\" you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it's normally handled by\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior – e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it's\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you don't have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1` you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it's normally handled by\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * `allowIn` &ndash; A string or an array of strings. Defines in which other items this item will be allowed.\n * * `allowAttributes` &ndash; A string or an array of strings. Defines allowed attributes of the given item.\n * * `allowContentOf` &ndash; A string or an array of strings. Inherits \"allowed children\" from other items.\n * * `allowWhere` &ndash; A string or an array of strings. Inherits \"allowed in\" from other items.\n * * `allowAttributesOf` &ndash; A string or an array of strings. Inherits attributes from other items.\n * * `inheritTypesFrom` &ndash; A string or an array of strings. Inherits `is*` properties of other items.\n * * `inheritAllFrom` &ndash; A string. A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n * * Additionally, you can define the following `is*` properties: `isBlock`, `isLimit`, `isObject`. Read about them below.\n *\n * # The is* properties\n *\n * There are 3 commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * `isBlock` &ndash; Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n * * `isLimit` &ndash; It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content. **Note:** All objects (`isObject`) are treated as limit elements, too.\n * * `isObject` &ndash; Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `image`, `table`, `video`, etc. **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`}\n * returns `true` for object elements automatically.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block'\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@linkTODO Defining schema} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `image` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'image', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'image',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about definining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tif ( context[ 0 ] && typeof context[ 0 ] != 'string' && context[ 0 ].is( 'documentFragment' ) ) {\n\t\t\tcontext.shift();\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {module:engine/model/node~Node} that is already in the model tree will be added as the only item (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( Position.createAt( paragraphElement ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mising an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' ) {\n\t\treturn {\n\t\t\tname: ctxItem,\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\tupcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \tdata.viewToModel.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, Position.createAt( paragraph ) );\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = new Range( Position.createBefore( paragraph ), modelRange.end );\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates a `UpcastDispatcher` that operates using passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~ViewConversionApi\n\t * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n\t * by `UpcastDispatcher`.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * List of elements that will be checked after conversion process and if element in the list will be empty it\n\t\t * will be removed from conversion result.\n\t\t *\n\t\t * After conversion process list is cleared.\n\t\t *\n\t\t * @protected\n\t\t * @type {Set<module:engine/model/element~Element>}\n\t\t */\n\t\tthis._removeIfEmpty = new Set();\n\n\t\t/**\n\t\t * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n\t\t * the target position where the content will be inserted. This property is build based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~ViewConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n\t\t// instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * Part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create this fragment.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that was added to #_removeIfEmpty list.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that was converted to context tree to document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements.\n\t\tthis._removeIfEmpty.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~ViewConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( 'text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.' );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~ViewConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, modelCursor ) {\n\t\tconst modelRange = new ModelRange( modelCursor );\n\t\tlet nextModelCursor = modelCursor;\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~ViewConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\t// Try to find allowed parent.\n\t\tconst allowedParent = this.conversionApi.schema.findAllowedParent( node, modelCursor );\n\n\t\t// When there is no parent that allows to insert node then return `null`.\n\t\tif ( !allowedParent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When current position parent allows to insert node then return this position.\n\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\treturn { position: modelCursor };\n\t\t}\n\n\t\t// When allowed parent is in context tree.\n\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Remember all elements that are created as a result of split.\n\t\t// This is important because at the end of conversion we want to remove all empty split elements.\n\t\t//\n\t\t// Loop through positions between elements in range (except split result position) and collect parents.\n\t\t// <notSplit><split1><split2>[pos]</split2>[pos]</split1>[omit]<split1>[pos]<split2>[pos]</split2></split1></notSplit>\n\t\tfor ( const position of splitResult.range.getPositions() ) {\n\t\t\tif ( !position.isEqual( splitResult.position ) ) {\n\t\t\t\tthis._removeIfEmpty.add( position.parent );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent: splitResult.range.end.parent\n\t\t};\n\t}\n\n\t/**\n\t * Checks if {@link #_removeIfEmpty} contains empty elements and remove them.\n\t * We need to do it smart because there could be elements that are not empty because contains\n\t * other empty elements and after removing its children they become available to remove.\n\t * We need to continue iterating over split elements as long as any element will be removed.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet removed = false;\n\n\t\tfor ( const element of this._removeIfEmpty ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._removeIfEmpty.delete( element );\n\t\t\t\tremoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( removed ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem Part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n\t * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n\t * all elements conversion or to conversion of specific elements.\n\t *\n\t * @event element\n\t * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n\t * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n\t * be available in other callbacks.\n\t * @param {module:engine/view/item~Item} data.viewItem Converted item.\n\t * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n\t * Change this value for the next converter to tell where the conversion should continue.\n\t * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n\t * converted element should be reflected by setting or modifying this property.\n\t * @param {ViewConversionApi} conversionApi Conversion utilities to be used by callback.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange.createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = ModelPosition.createBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( ModelPosition.createFromPosition( currentPosition ) ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = ModelPosition.createFromPosition( currentPosition );\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in top element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition.createAt( current );\n\t}\n\n\treturn position;\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface ViewConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Instance of {@link module:engine/conversion/viewconsumable~ViewConsumable}. It stores\n * information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @param {Object} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @param {Object} #store\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport Matcher from '../view/matcher';\n\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\n\nimport cloneDeep from '@ckeditor/ckeditor5-utils/src/lib/lodash/cloneDeep';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcast-converters\n */\n\n/**\n * View element to model element conversion helper.\n *\n * This conversion results in creating a model element. For example, view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n *\n * Keep in mind that the element will be inserted only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n *\n *\t\tupcastElementToElement( { view: 'p', model: 'paragraph' } );\n *\n *\t\tupcastElementToElement( { view: 'p', model: 'paragraph', converterPriority: 'high' } );\n *\n *\t\tupcastElementToElement( {\n *\t\t\tview: {\n *\t\t\t\tname: 'p',\n *\t\t\t\tclasses: 'fancy'\n *\t\t\t},\n *\t\t\tmodel: 'fancyParagraph'\n *\t\t} );\n *\n *\t\tupcastElementToElement( {\n * \t\t\tview: {\n *\t\t\t\tname: 'p',\n *\t\t\t\tclasses: 'heading'\n * \t\t\t},\n * \t\t\tmodel: ( viewElement, modelWriter ) => {\n * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n * \t\t\t}\n * \t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add converter to conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = _prepareToElementConverter( config );\n\n\tconst elementName = _getViewElementNameFromConfig( config );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * View element to model attribute conversion helper.\n *\n * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n *\n * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n *\n *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n *\n * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n * {@link module:engine/conversion/upcast-converters~upcastAttributeToAttribute} for comparison.\n *\n * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n *\n *\t\tupcastElementToAttribute( { view: 'strong', model: 'bold' } );\n *\n *\t\tupcastElementToAttribute( { view: 'strong', model: 'bold', converterPriority: 'high' } );\n *\n *\t\tupcastElementToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tclasses: 'bold'\n *\t\t\t},\n *\t\t\tmodel: 'bold'\n *\t\t} );\n *\n *\t\tupcastElementToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n *\t\t\t},\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'styled',\n *\t\t\t\tvalue: 'dark'\n *\t\t\t}\n *\t\t} );\n *\n * \t\tupcastElementToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tstyles: {\n *\t\t\t\t\t'font-size': /[\\s\\S]+/\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'fontSize',\n *\t\t\t\tvalue: viewElement => {\n *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n *\n *\t\t\t\t\tif ( value <= 10 ) {\n *\t\t\t\t\t\treturn 'small';\n *\t\t\t\t\t} else if ( value > 12 ) {\n *\t\t\t\t\t\treturn 'big';\n *\t\t\t\t\t}\n *\n *\t\t\t\t\treturn null;\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add converter to conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n * If `String` is given, the model attribute value will be set to `true`.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\t_normalizeModelAttributeConfig( config );\n\n\tconst converter = _prepareToAttributeConverter( config, false );\n\n\tconst elementName = _getViewElementNameFromConfig( config );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n/**\n * View attribute to model attribute conversion helper.\n *\n * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n * `<image source=\"foo.jpg\"></image>` in the model.\n *\n * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n * is set only on the corresponding model node:\n *\n *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n *\n * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n * {@link module:engine/conversion/upcast-converters~upcastElementToAttribute} which sets attributes for all the children in the model:\n *\n *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n *\n * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n *\n * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n *\n *\t\tupcastAttributeToAttribute( { view: 'src', model: 'source' } );\n *\n *\t\tupcastAttributeToAttribute( { view: { key: 'src' }, model: 'source' } );\n *\n *\t\tupcastAttributeToAttribute( { view: { key: 'src' }, model: 'source', converterPriority: 'normal' } );\n *\n *\t\tupcastAttributeToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tkey: 'data-style',\n *\t\t\t\tvalue: /[\\s\\S]+/\n *\t\t\t},\n *\t\t\tmodel: 'styled'\n *\t\t} );\n *\n *\t\tupcastAttributeToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tname: 'img',\n *\t\t\t\tkey: 'class',\n *\t\t\t\tvalue: 'styled-dark'\n *\t\t\t},\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'styled',\n *\t\t\t\tvalue: 'dark'\n *\t\t\t}\n *\t\t} );\n *\n *\t\tupcastAttributeToAttribute( {\n *\t\t\tview: {\n *\t\t\t\tkey: 'class',\n *\t\t\t\tvalue: /styled-[\\S]+/\n *\t\t\t},\n *\t\t\tmodel: {\n *\t\t\t\tkey: 'styled'\n *\t\t\t\tvalue: viewElement => {\n *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n *\n *\t\t\t\t\treturn match[ 1 ];\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add converter to conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n * If `String` is given, the model attribute value will be same as view attribute value.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = _normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\t_normalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = _prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n/**\n * View element to model marker conversion helper.\n *\n * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n * after the conversion is done, the marker will be available in\n * {@link module:engine/model/model~Model#markers model document markers}.\n *\n *\t\tupcastElementToMarker( { view: 'marker-search', model: 'search' } );\n *\n *\t\tupcastElementToMarker( { view: 'marker-search', model: 'search', converterPriority: 'high' } );\n *\n *\t\tupcastElementToMarker( {\n *\t\t\tview: 'marker-search',\n *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n *\t\t} );\n *\n *\t\tupcastElementToMarker( {\n *\t\t\tview: {\n *\t\t\t\tname: 'span',\n *\t\t\t\tattributes: {\n *\t\t\t\t\t'data-marker': 'search'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\tmodel: 'search'\n *\t\t} );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for} to learn how to add converter to conversion process.\n *\n * @param {Object} config Conversion configuration.\n * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n * a model marker name.\n * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n * @returns {Function} Conversion helper.\n */\nexport function upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\t_normalizeToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction _getViewElementNameFromConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\treturn config.view;\n\t}\n\n\tif ( typeof config.view == 'object' && typeof config.view.name == 'string' ) {\n\t\treturn config.view.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction _prepareToElementConverter( config ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This will be usually just one pattern but we support matchers with many patterns too.\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Force consuming element's name.\n\t\tmatch.match.name = true;\n\n\t\t// Create model element basing on config.\n\t\tconst modelElement = _getModelElement( config.model, data.viewItem, conversionApi.writer );\n\n\t\t// Do not convert if element building function returned falsy value.\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When element was already consumed then skip it.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( modelElement, data.modelCursor );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tconversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\t// Convert children and insert to element.\n\t\tconst childrenResult = conversionApi.convertChildren( data.viewItem, ModelPosition.createAt( modelElement ) );\n\n\t\t// Consume appropriate value from consumable values list.\n\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\n\t\t// Set conversion result range.\n\t\tdata.modelRange = new ModelRange(\n\t\t\t// Range should start before inserted element\n\t\t\tModelPosition.createBefore( modelElement ),\n\t\t\t// Should end after but we need to take into consideration that children could split our\n\t\t\t// element, so we need to move range after parent of the last converted child.\n\t\t\t// before: <allowed>[]</allowed>\n\t\t\t// after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n\t\t\tModelPosition.createAfter( childrenResult.modelCursor.parent )\n\t\t);\n\n\t\t// Now we need to check where the modelCursor should be.\n\t\t// If we had to split parent to insert our element then we want to continue conversion inside split parent.\n\t\t//\n\t\t// before: <allowed><notAllowed>[]</notAllowed></allowed>\n\t\t// after:  <allowed><notAllowed></notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\t\tif ( splitResult.cursorParent ) {\n\t\t\tdata.modelCursor = ModelPosition.createAt( splitResult.cursorParent );\n\n\t\t\t// Otherwise just continue after inserted element.\n\t\t} else {\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\nfunction _getModelElement( model, input, writer ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, writer );\n\t} else {\n\t\treturn writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction _normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction _normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction _prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ? config.model.value( data.viewItem ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( _onlyViewNameIsDefined( config ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need an range on which we will set the attribute.\n\t\t// If the range is not created yet, we will create it.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = _setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion config.\n// @returns {Boolean}\nfunction _onlyViewNameIsDefined( config ) {\n\tif ( typeof config.view == 'object' && !_getViewElementNameFromConfig( config ) ) {\n\t\treturn false;\n\t}\n\n\treturn !config.view.classes && !config.view.attributes && !config.view.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {Object} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction _setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\tif ( conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction _normalizeToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, modelWriter ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement );\n\n\t\treturn modelWriter.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( conversionApi.schema.checkChild( data.modelCursor, '$text' ) ) {\n\t\t\tif ( conversionApi.consumable.consume( data.viewItem ) ) {\n\t\t\t\tconst text = conversionApi.writer.createText( data.viewItem.data );\n\n\t\t\t\tconversionApi.writer.insert( text, data.modelCursor );\n\n\t\t\t\tdata.modelRange = ModelRange.createFromPositionAndShift( data.modelCursor, text.offsetSize );\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t\t}\n\t\t}\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcast-converters';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcast-converters';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewWriter from '../view/writer';\n\nimport ModelRange from '../model/range';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/dataprocessor/dataprocessor~DataProcessor} [dataProcessor] Data processor that should be used\n\t * by the controller.\n\t */\n\tconstructor( model, dataProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/dataProcessor~DataProcessor}\n\t\t */\n\t\tthis.processor = dataProcessor;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @param {String} [rootName='main'] Root name.\n\t * @returns {String} Output data.\n\t */\n\tget( rootName = 'main' ) {\n\t\t// Get model range.\n\t\treturn this.stringify( this.model.document.getRoot( rootName ) );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment ) {\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange.createIn( modelElementOrFragment );\n\n\t\tconst viewDocumentFragment = new ViewDocumentFragment();\n\n\t\t// Create separate ViewWriter just for data conversion purposes.\n\t\t// We have no view controller and rendering do DOM in DataController so view.change() block is not used here.\n\t\tconst viewWriter = new ViewWriter( new ViewDocument() );\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\tif ( !modelElementOrFragment.is( 'documentFragment' ) ) {\n\t\t\t// Then, if a document element is converted, convert markers.\n\t\t\t// From all document markers, get those, which \"intersect\" with the converter element.\n\t\t\tconst markers = _getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\t\tfor ( const [ name, range ] of markers ) {\n\t\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t\t}\n\t\t}\n\n\t\t// Clear bindings so the next call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * @fires init\n\t * @param {String} data Input data.\n\t * @param {String} [rootName='main'] Root name.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data, rootName = 'main' ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty: Trying to set initial data to not empty document.' );\n\t\t}\n\n\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.insert( this.parse( data, modelRoot ), modelRoot );\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * @param {String} data Input data.\n\t * @param {String} [rootName='main'] Root name.\n\t */\n\tset( data, rootName = 'main' ) {\n\t\t// Save to model.\n\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\twriter.remove( ModelRange.createIn( modelRoot ) );\n\t\t\twriter.insert( this.parse( data, modelRoot ), modelRoot );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {}\n\n\t/**\n\t * Event fired by decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin.decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange.createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst intersection = elementRange.getIntersection( marker.getRange() );\n\n\t\tif ( intersection ) {\n\t\t\tresult.push( [ marker.name, intersection ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/conversion/conversion\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport {\n\tdowncastElementToElement,\n\tdowncastAttributeToElement,\n\tdowncastAttributeToAttribute\n} from './downcast-converters';\n\nimport {\n\tupcastElementToElement,\n\tupcastElementToAttribute,\n\tupcastAttributeToAttribute\n} from './upcast-converters';\n\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * The instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).add( downcastElementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).add( downcastElementToElement( config ) );\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).add( downcastElementToWidget( config ) );\n *\n * The functions used in `add()` calls are one-way converters (i.e. you need to remember yourself to add\n * a converter in the other direction, if your feature requires that). They are also called \"conversion helpers\".\n * You can find a set of them in the {@link module:engine/conversion/downcast-converters} and\n * {@link module:engine/conversion/upcast-converters} modules.\n *\n * Besides allowing to register converters to specific dispatchers, you can also use methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n */\nexport default class Conversion {\n\t/**\n\t * Creates a new conversion instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._dispatchersGroups = new Map();\n\t}\n\n\t/**\n\t * Registers one or more converters under a given group name. The group name can then be used to assign a converter\n\t * to multiple dispatchers at once.\n\t *\n\t * If a given group name is used for the second time, the\n\t * {@link module:utils/ckeditorerror~CKEditorError `conversion-register-group-exists` error} is thrown.\n\t *\n\t * @param {String} groupName The name for dispatchers group.\n\t * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} dispatchers Dispatchers to register\n\t * under the given name.\n\t */\n\tregister( groupName, dispatchers ) {\n\t\tif ( this._dispatchersGroups.has( groupName ) ) {\n\t\t\t/**\n\t\t\t * Trying to register a group name that was already registered.\n\t\t\t *\n\t\t\t * @error conversion-register-group-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-register-group-exists: Trying to register a group name that was already registered.' );\n\t\t}\n\n\t\tthis._dispatchersGroups.set( groupName, dispatchers );\n\t}\n\n\t/**\n\t * Provides chainable API to assign converters to dispatchers registered under a given group name. Converters are added\n\t * by calling the `.add()` method of an object returned by this function.\n\t *\n\t *\t\tconversion.for( 'downcast' )\n\t *\t\t\t.add( conversionHelperA )\n\t *\t\t\t.add( conversionHelperB );\n\t *\n\t * In this example `conversionHelperA` and `conversionHelperB` will be called for all dispatchers from the `'model'` group.\n\t *\n\t * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n\t * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n\t *\n\t * Conversion helpers for most common cases are already provided. They are flexible enough to cover most use cases.\n\t * See the documentation to learn how they can be configured.\n\t *\n\t * For downcast (model-to-view conversion), these are:\n\t *\n\t * * {@link module:engine/conversion/downcast-converters~downcastElementToElement Downcast element-to-element converter},\n\t * * {@link module:engine/conversion/downcast-converters~downcastAttributeToElement Downcast attribute-to-element converter},\n\t * * {@link module:engine/conversion/downcast-converters~downcastAttributeToAttribute Downcast attribute-to-attribute converter}.\n\t *\n\t * For upcast (view-to-model conversion), these are:\n\t *\n\t * * {@link module:engine/conversion/upcast-converters~upcastElementToElement Upcast element-to-element converter},\n\t * * {@link module:engine/conversion/upcast-converters~upcastElementToAttribute Upcast attribute-to-element converter},\n\t * * {@link module:engine/conversion/upcast-converters~upcastAttributeToAttribute Upcast attribute-to-attribute converter}.\n\t *\n\t * An example of using conversion helpers to convert the `paragraph` model element to the `p` view element (and back):\n\t *\n\t *\t\t// Define conversion configuration - model element 'paragraph' should be converted to view element 'p'.\n\t *\t\tconst config = { model: 'paragraph', view: 'p' };\n\t *\n\t *\t\t// Add converters to proper dispatchers using conversion helpers.\n\t *\t\tconversion.for( 'downcast' ).add( downcastElementToElement( config ) );\n\t *\t\tconversion.for( 'upcast' ).add( upcastElementToElement( config ) );\n\t *\n\t * An example of providing a custom conversion helper that uses a custom converter function:\n\t *\n\t *\t\t// Adding a custom `myConverter` converter for 'paragraph' element insertion, with the default priority ('normal').\n\t *\t\tconversion.for( 'downcast' ).add( conversion.customConverter( 'insert:paragraph', myConverter ) );\n\t *\n\t * @param {String} groupName The name of dispatchers group to add the converters to.\n\t * @returns {Object} An object with the `.add()` method, providing a way to add converters.\n\t */\n\tfor( groupName ) {\n\t\tconst dispatchers = this._getDispatchers( groupName );\n\n\t\treturn {\n\t\t\tadd( conversionHelper ) {\n\t\t\t\t_addToDispatchers( dispatchers, conversionHelper );\n\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n\t * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n\t *\t\tconversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\tconversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\tconversion.elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n\t *\t\tconversion.elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'div',\n\t *\t\t\t\t{\n\t *\t\t\t\t\t// Any element with the `display: block` style.\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\tdisplay: 'block'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\tconversion.elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: 'h2',\n\t *\t\t\t// Convert \"headling-like\" paragraphs to headings.\n\t *\t\t\tupcastAlso: viewElement => {\n\t *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\tif ( size > 26 ) {\n\t *\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * `definition.model` is a `String` with a model element name to convert from or to.\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\telementToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).add( downcastElementToElement( definition ) );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' ).add(\n\t\t\t\tupcastElementToElement( {\n\t\t\t\t\tmodel,\n\t\t\t\t\tview,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n\t * For example, a model text node with `\"Foo\"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n\t *\t\tconversion.attributeToElement( { model: 'bold', view: 'strong' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\tconversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\tconversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n\t *\t\t// The same attribute on different elements may then be handled by a different converter.\n\t *\t\tconversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'textDecoration',\n\t *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tunderline: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'underline'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tlineThrough: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'line-through'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n\t *\t\tconversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'b',\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tclasses: 'bold'\n\t *\t\t\t\t},\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tviewElement => {\n\t *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn {\n\t *\t\t\t\t\t\t\tname: true,\n\t *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n\t *\t\t\t\t\t\t};\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\tconversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tbig: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size > 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size < 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n\t * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\tattributeToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).add( downcastAttributeToElement( definition ) );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' ).add(\n\t\t\t\tupcastElementToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel,\n\t\t\t\t\tpriority: definition.priority\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).\n\t * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n\t *\n\t *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n\t *\t\tconversion.attributeToAttribute( { model: 'source', view: 'src' } );\n\t *\n\t *\t\t// Attribute values are strictly specified.\n\t *\t\tconversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Set the style attribute.\n\t *\t\tconversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'style',\n\t *\t\t\t\t\tvalue: {\n\t *\t\t\t\t\t\tfloat: 'right',\n\t *\t\t\t\t\t\twidth: '50%',\n\t *\t\t\t\t\t\tmargin: '5px'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n\t *\t\tconversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'align',\n\t *\t\t\t\tvalues: [ 'right', 'center' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-right'\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-center'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'right'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'center'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from and to.\n\t * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n\t * The `key` property is the model attribute key to convert from and to.\n\t * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the\n\t * view attribute value.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t *\n\t * The `definition.view` parameter specifies which view attribute should be converted from and to.\n\t * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n\t * The `key` property is the view attribute key to convert from and to.\n\t * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n\t * the same as the model attribute value.\n\t * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n\t * If `key` is `'style'`, `value` is an object with key-value pairs.\n\t * In other cases, `value` is a `String`.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n\t * to `{ key, value, [ name ] }` objects.\n\t *\n\t * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n\t * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n\t * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n\t *\n\t * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n\t * be given in both parameters.\n\t *\n\t * @param {Object} definition The converter definition.\n\t * @param {String|Object} definition.model The model attribute to convert from and to.\n\t * @param {String|Object} definition.view The view attribute to convert from and to.\n\t * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n\t * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n\t * is used only if `config.model.values` is specified.\n\t */\n\tattributeToAttribute( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).add( downcastAttributeToAttribute( definition ) );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' ).add(\n\t\t\t\tupcastAttributeToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel\n\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Returns dispatchers registered under a given group name.\n\t *\n\t * If the given group name has not been registered, the\n\t * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n\t *\n\t * @private\n\t * @param {String} groupName\n\t * @returns {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher>}\n\t */\n\t_getDispatchers( groupName ) {\n\t\tconst dispatchers = this._dispatchersGroups.get( groupName );\n\n\t\tif ( !dispatchers ) {\n\t\t\t/**\n\t\t\t * Trying to add a converter to an unknown dispatchers group.\n\t\t\t *\n\t\t\t * @error conversion-for-unknown-group\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.' );\n\t\t}\n\n\t\treturn dispatchers;\n\t}\n}\n\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n\n// Helper function for the `Conversion` `.add()` method.\n//\n// Calls `conversionHelper` on each dispatcher from the group specified earlier in the `.for()` call, effectively\n// adding converters to all specified dispatchers.\n//\n// @private\n// @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n// module:engine/conversion/upcastdispatcher~UpcastDispatcher>} dispatchers\n// @param {Function} conversionHelper\nfunction _addToDispatchers( dispatchers, conversionHelper ) {\n\tfor ( const dispatcher of dispatchers ) {\n\t\tconversionHelper( dispatcher );\n\t}\n}\n\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\nfunction* _getAllUpcastDefinitions( definition ) {\n\tif ( definition.model.values ) {\n\t\tfor ( const value of definition.model.values ) {\n\t\t\tconst model = { key: definition.model.key, value };\n\t\t\tconst view = definition.view[ value ];\n\t\t\tconst upcastAlso = definition.upcastAlso ? definition.upcastAlso[ value ] : undefined;\n\n\t\t\tyield* _getUpcastDefinition( model, view, upcastAlso );\n\t\t}\n\t} else {\n\t\tyield* _getUpcastDefinition( definition.model, definition.view, definition.upcastAlso );\n\t}\n}\n\nfunction* _getUpcastDefinition( model, view, upcastAlso ) {\n\tyield { model, view };\n\n\tif ( upcastAlso ) {\n\t\tupcastAlso = Array.isArray( upcastAlso ) ? upcastAlso : [ upcastAlso ];\n\n\t\tfor ( const upcastAlsoItem of upcastAlso ) {\n\t\t\tyield { model, view: upcastAlsoItem };\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/operation\n */\n\nimport clone from '@ckeditor/ckeditor5-utils/src/lib/lodash/clone';\n\n/**\n * Abstract base operation class.\n *\n * @abstract\n */\nexport default class Operation {\n\t/**\n\t * Base operation constructor.\n\t *\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( baseVersion ) {\n\t\t/**\n\t\t * {@link module:engine/model/document~Document#version} on which operation can be applied. If you try to\n\t\t * {@link module:engine/model/model~Model#applyOperation apply} operation with different base version than the\n\t\t * {@link module:engine/model/document~Document#version document version} the\n\t\t * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.\n\t\t *\n\t\t * @member {Number}\n\t\t */\n\t\tthis.baseVersion = baseVersion;\n\n\t\t/**\n\t\t * Defines whether operation is executed on attached or detached {@link module:engine/model/item~Item items}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isDocumentOperation\n\t\t */\n\t\tthis.isDocumentOperation = this.baseVersion !== null;\n\n\t\t/**\n\t\t * Operation type.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} #type\n\t\t */\n\n\t\t/**\n\t\t * {@link module:engine/model/delta/delta~Delta Delta} which the operation is a part of. This property is set by the\n\t\t * {@link module:engine/model/delta/delta~Delta delta} when the operations is added to it by the\n\t\t * {@link module:engine/model/delta/delta~Delta#addOperation} method.\n\t\t *\n\t\t * @member {module:engine/model/delta/delta~Delta} #delta\n\t\t */\n\n\t\t/**\n\t\t * Creates and returns an operation that has the same parameters as this operation.\n\t\t *\n\t\t * @method #clone\n\t\t * @returns {module:engine/model/operation/operation~Operation} Clone of this operation.\n\t\t */\n\n\t\t/**\n\t\t * Creates and returns a reverse operation. Reverse operation when executed right after\n\t\t * the original operation will bring back tree model state to the point before the original\n\t\t * operation execution. In other words, it reverses changes done by the original operation.\n\t\t *\n\t\t * Keep in mind that tree model state may change since executing the original operation,\n\t\t * so reverse operation will be \"outdated\". In that case you will need to\n\t\t * {@link module:engine/model/operation/transform~transform} it by all operations that were executed after the original operation.\n\t\t *\n\t\t * @method #getReversed\n\t\t * @returns {module:engine/model/operation/operation~Operation} Reversed operation.\n\t\t */\n\n\t\t/**\n\t\t * Executes the operation - modifications described by the operation properties will be applied to the model tree.\n\t\t *\n\t\t * @protected\n\t\t * @method #_execute\n\t\t */\n\t}\n\n\t/**\n\t * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws\n\t * an error if operation is not valid.\n\t *\n\t * @protected\n\t * @method #_validate\n\t */\n\t_validate() {\n\t}\n\n\t/**\n\t * Custom toJSON method to solve child-parent circular dependencies.\n\t *\n\t * @method #toJSON\n\t * @returns {Object} Clone of this object with the delta property replaced with string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this, true );\n\n\t\tjson.__className = this.constructor.className;\n\n\t\t// Remove parent delta to avoid circular dependencies.\n\t\tdelete json.delta;\n\n\t\t// Only document operations are shared with other clients so it is not necessary to keep this information.\n\t\tdelete json.isDocumentOperation;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Name of the operation class used for serialization.\n\t *\n\t * @type {String}\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.Operation';\n\t}\n\n\t/**\n\t * Creates Operation object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} doc Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/operation~Operation}\n\t */\n\tstatic fromJSON( json ) {\n\t\treturn new this( json.baseVersion );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\n\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but it's top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates an empty `DocumentFragment`.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * Nodes to be contained inside the `DocumentFragment`.\n\t */\n\tconstructor( children ) {\n\t\t/**\n\t\t * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n\t\t * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n\t\t * when DocumentFragment will be inserted to the document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n\t\t */\n\t\tthis.markers = new Map();\n\n\t\t/**\n\t\t * List of nodes contained inside the document fragment.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all nodes contained inside this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.getChildren();\n\t}\n\n\t/**\n\t * Number of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether given model tree object is of given type.\n\t *\n\t * Read more in {@link module:engine/model/node~Node#is}.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'documentFragment';\n\t}\n\n\t/**\n\t * Gets the child at the given index. Returns `null` if incorrect index was passed.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node|null} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this document fragment's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's index.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n\t *\n\t * @returns {Array}\n\t */\n\tgetPath() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts offset \"position\" to index \"position\".\n\t *\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n\t *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number} Index of a node that occupies given offset.\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Converts `DocumentFragment` instance to plain object and returns it.\n\t * Takes care of converting all of this document fragment's children.\n\t *\n\t * @returns {Object} `DocumentFragment` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = [];\n\n\t\tfor ( const node of this._children ) {\n\t\t\tjson.push( node.toJSON() );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `DocumentFragment` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `DocumentFragment`.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tconst children = [];\n\n\t\tfor ( const child of json ) {\n\t\t\tif ( child.name ) {\n\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t} else {\n\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new DocumentFragment( children );\n\t}\n\n\t/**\n\t * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_appendChild( items ) {\n\t\tthis._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this document fragment.\n\t *\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index\n\t * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/utils\n */\n\nimport Node from '../node';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport Range from '../range';\nimport DocumentFragment from '../documentfragment';\nimport NodeList from '../nodelist';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert( position, nodes ) {\n\tnodes = _normalizeNodes( nodes );\n\n\t// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\tconst offset = nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\tconst parent = position.parent;\n\n\t// Insertion might be in a text node, we should split it if that's the case.\n\t_splitNodeAtPosition( position );\n\tconst index = position.index;\n\n\t// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n\t// using basic `Element` API.\n\tparent._insertChild( index, nodes );\n\n\t// Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\t_mergeNodesAtIndex( parent, index + nodes.length );\n\t_mergeNodesAtIndex( parent, index );\n\n\treturn new Range( position, position.getShiftedBy( offset ) );\n}\n\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove( range ) {\n\tif ( !range.isFlat ) {\n\t\t/**\n\t\t * Trying to remove a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-remove-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError( 'operation-utils-remove-range-not-flat: ' +\n\t\t\t'Trying to remove a range which starts and ends in different element.' );\n\t}\n\n\tconst parent = range.start.parent;\n\n\t// Range may be inside text nodes, we have to split them if that's the case.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Remove the text nodes using basic `Element` API.\n\tconst removed = parent._removeChildren( range.start.index, range.end.index - range.start.index );\n\n\t// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n\t// touching at the position equal to the removed range beginning. We check merging possibility there.\n\t_mergeNodesAtIndex( parent, range.start.index );\n\n\treturn removed;\n}\n\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move( sourceRange, targetPosition ) {\n\tif ( !sourceRange.isFlat ) {\n\t\t/**\n\t\t * Trying to move a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-move-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError( 'operation-utils-move-range-not-flat: ' +\n\t\t\t'Trying to move a range which starts and ends in different element.' );\n\t}\n\n\tconst nodes = _remove( sourceRange );\n\n\t// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n\t// that change might have an impact on `targetPosition`.\n\ttargetPosition = targetPosition._getTransformedByDeletion( sourceRange.start, sourceRange.end.offset - sourceRange.start.offset );\n\n\treturn _insert( targetPosition, nodes );\n}\n\n/**\n * Sets given attribute on nodes in given range.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute( range, key, value ) {\n\t// Range might start or end in text nodes, so we have to split them.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Iterate over all items in the range.\n\tfor ( const item of range.getItems() ) {\n\t\t// Iterator will return `TextProxy` instances but we know that those text proxies will\n\t\t// always represent full text nodes (this is guaranteed thanks to splitting we did before).\n\t\t// So, we can operate on those text proxies' text nodes.\n\t\tconst node = item.is( 'textProxy' ) ? item.textNode : item;\n\n\t\tif ( value !== null ) {\n\t\t\tnode._setAttribute( key, value );\n\t\t} else {\n\t\t\tnode._removeAttribute( key );\n\t\t}\n\n\t\t// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\t\t_mergeNodesAtIndex( node.parent, node.index );\n\t}\n\n\t// Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\t_mergeNodesAtIndex( range.end.parent, range.end.index );\n}\n\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes( nodes ) {\n\tconst normalized = [];\n\n\tif ( !( nodes instanceof Array ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Convert instances of classes other than Node.\n\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\tif ( typeof nodes[ i ] == 'string' ) {\n\t\t\tnormalized.push( new Text( nodes[ i ] ) );\n\t\t} else if ( nodes[ i ] instanceof TextProxy ) {\n\t\t\tnormalized.push( new Text( nodes[ i ].data, nodes[ i ].getAttributes() ) );\n\t\t} else if ( nodes[ i ] instanceof DocumentFragment || nodes[ i ] instanceof NodeList ) {\n\t\t\tfor ( const child of nodes[ i ] ) {\n\t\t\t\tnormalized.push( child );\n\t\t\t}\n\t\t} else if ( nodes[ i ] instanceof Node ) {\n\t\t\tnormalized.push( nodes[ i ] );\n\t\t}\n\t\t// Skip unrecognized type.\n\t}\n\n\t// Merge text nodes.\n\tfor ( let i = 1; i < normalized.length; i++ ) {\n\t\tconst node = normalized[ i ];\n\t\tconst prev = normalized[ i - 1 ];\n\n\t\tif ( node instanceof Text && prev instanceof Text && _haveSameAttributes( node, prev ) ) {\n\t\t\t// Doing this instead changing prev.data because .data is readonly.\n\t\t\tnormalized.splice( i - 1, 2, new Text( prev.data + node.data, prev.getAttributes() ) );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn normalized;\n}\n\n/**\n * Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n * merges them into one node if they have same attributes.\n *\n * Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n *\n * @ignore\n * @private\n * @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n * @param {Number} index Index between nodes to merge.\n */\nfunction _mergeNodesAtIndex( element, index ) {\n\tconst nodeBefore = element.getChild( index - 1 );\n\tconst nodeAfter = element.getChild( index );\n\n\t// Check if both of those nodes are text objects with same attributes.\n\tif ( nodeBefore && nodeAfter && nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) && _haveSameAttributes( nodeBefore, nodeAfter ) ) {\n\t\t// Append text of text node after index to the before one.\n\t\tconst mergedNode = new Text( nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes() );\n\n\t\t// Remove separate text nodes.\n\t\telement._removeChildren( index - 1, 2 );\n\n\t\t// Insert merged text node.\n\t\telement._insertChild( index - 1, mergedNode );\n\t}\n}\n\n/**\n * Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n * containing a part of original text node.\n *\n * @ignore\n * @private\n * @param {module:engine/model/position~Position} position Position at which node should be split.\n */\nfunction _splitNodeAtPosition( position ) {\n\tconst textNode = position.textNode;\n\tconst element = position.parent;\n\n\tif ( textNode ) {\n\t\tconst offsetDiff = position.offset - textNode.startOffset;\n\t\tconst index = textNode.index;\n\n\t\telement._removeChildren( index, 1 );\n\n\t\tconst firstPart = new Text( textNode.data.substr( 0, offsetDiff ), textNode.getAttributes() );\n\t\tconst secondPart = new Text( textNode.data.substr( offsetDiff ), textNode.getAttributes() );\n\n\t\telement._insertChild( index, [ firstPart, secondPart ] );\n\t}\n}\n\n/**\n * Checks whether two given nodes have same attributes.\n *\n * @ignore\n * @private\n * @param {module:engine/model/node~Node} nodeA Node to check.\n * @param {module:engine/model/node~Node} nodeB Node to check.\n * @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\n */\nfunction _haveSameAttributes( nodeA, nodeB ) {\n\tconst iteratorA = nodeA.getAttributes();\n\tconst iteratorB = nodeB.getAttributes();\n\n\tfor ( const attr of iteratorA ) {\n\t\tif ( attr[ 1 ] !== nodeB.getAttribute( attr[ 0 ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\titeratorB.next();\n\t}\n\n\treturn iteratorB.next().done;\n}\n\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */\n","import baseIsEqual from './_baseIsEqual';\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are **not** supported.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent,\n *  else `false`.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var other = { 'user': 'fred' };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nexport default isEqual;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/attributeoperation\n */\n\nimport Operation from './operation';\nimport Range from '../range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { _setAttribute } from './utils';\nimport isEqual from '@ckeditor/ckeditor5-utils/src/lib/lodash/isEqual';\n\n/**\n * Operation to change nodes' attribute.\n *\n * Using this class you can add, remove or change value of the attribute.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class AttributeOperation extends Operation {\n\t/**\n\t * Creates an operation that changes, removes or adds attributes.\n\t *\n\t * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not\n\t * have an attribute with the same key as the added attribute.\n\t *\n\t * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range\n\t * must have an attribute with that key added.\n\t *\n\t * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in\n\t * operation's ranges must already have an attribute with given key and `oldValue` as value\n\t *\n\t * @param {module:engine/model/range~Range} range Range on which the operation should be applied.\n\t * @param {String} key Key of an attribute to change or remove.\n\t * @param {*} oldValue Old value of the attribute with given key or `null`, if attribute was not set before.\n\t * @param {*} newValue New value of the attribute with given key or `null`, if operation should remove attribute.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( range, key, oldValue, newValue, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Range on which operation should be applied.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range}\n\t\t */\n\t\tthis.range = Range.createFromRange( range );\n\n\t\t/**\n\t\t * Key of an attribute to change or remove.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.key = key;\n\n\t\t/**\n\t\t * Old value of the attribute with given key or `null`, if attribute was not set before.\n\t\t *\n\t\t * @readonly\n\t\t * @member {*}\n\t\t */\n\t\tthis.oldValue = oldValue === undefined ? null : oldValue;\n\n\t\t/**\n\t\t * New value of the attribute with given key or `null`, if operation should remove attribute.\n\t\t *\n\t\t * @readonly\n\t\t * @member {*}\n\t\t */\n\t\tthis.newValue = newValue === undefined ? null : newValue;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\tif ( this.oldValue === null ) {\n\t\t\treturn 'addAttribute';\n\t\t} else if ( this.newValue === null ) {\n\t\t\treturn 'removeAttribute';\n\t\t} else {\n\t\t\treturn 'changeAttribute';\n\t\t}\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/attributeoperation~AttributeOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new AttributeOperation( this.range, this.key, this.oldValue, this.newValue, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}\n\t */\n\tgetReversed() {\n\t\treturn new AttributeOperation( this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tfor ( const item of this.range.getItems() ) {\n\t\t\tif ( this.oldValue !== null && !isEqual( item.getAttribute( this.key ), this.oldValue ) ) {\n\t\t\t\t/**\n\t\t\t\t * Changed node has different attribute value than operation's old attribute value.\n\t\t\t\t *\n\t\t\t\t * @error attribute-operation-wrong-old-value\n\t\t\t\t * @param {module:engine/model/item~Item} item\n\t\t\t\t * @param {String} key\n\t\t\t\t * @param {*} value\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'attribute-operation-wrong-old-value: Changed node has different attribute value than operation\\'s ' +\n\t\t\t\t\t'old attribute value.',\n\t\t\t\t\t{ item, key: this.key, value: this.oldValue }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( this.oldValue === null && this.newValue !== null && item.hasAttribute( this.key ) ) {\n\t\t\t\t/**\n\t\t\t\t * The attribute with given key already exists for the given node.\n\t\t\t\t *\n\t\t\t\t * @error attribute-operation-attribute-exists\n\t\t\t\t * @param {module:engine/model/node~Node} node\n\t\t\t\t * @param {String} key\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'attribute-operation-attribute-exists: The attribute with given key already exists.',\n\t\t\t\t\t{ node: item, key: this.key }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\t// If value to set is same as old value, don't do anything.\n\t\tif ( !isEqual( this.oldValue, this.newValue ) ) {\n\t\t\t// Execution.\n\t\t\t_setAttribute( this.range, this.key, this.newValue );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.AttributeOperation';\n\t}\n\n\t/**\n\t * Creates `AttributeOperation` object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\treturn new AttributeOperation( Range.fromJSON( json.range, document ), json.key, json.oldValue, json.newValue, json.baseVersion );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/moveoperation\n */\n\nimport Operation from './operation';\nimport Position from '../position';\nimport Range from '../range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport { _move } from './utils';\n\n/**\n * Operation to move a range of {@link module:engine/model/item~Item model items}\n * to given {@link module:engine/model/position~Position target position}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class MoveOperation extends Operation {\n\t/**\n\t * Creates a move operation.\n\t *\n\t * @param {module:engine/model/position~Position} sourcePosition\n\t * Position before the first {@link module:engine/model/item~Item model item} to move.\n\t * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at\n\t * `sourcePosition` with offset shifted by `howMany`.\n\t * @param {module:engine/model/position~Position} targetPosition Position at which moved nodes will be inserted.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( sourcePosition, howMany, targetPosition, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Position before the first {@link module:engine/model/item~Item model item} to move.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#sourcePosition\n\t\t */\n\t\tthis.sourcePosition = Position.createFromPosition( sourcePosition );\n\n\t\t/**\n\t\t * Offset size of moved range.\n\t\t *\n\t\t * @member {Number} module:engine/model/operation/moveoperation~MoveOperation#howMany\n\t\t */\n\t\tthis.howMany = howMany;\n\n\t\t/**\n\t\t * Position at which moved nodes will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#targetPosition\n\t\t */\n\t\tthis.targetPosition = Position.createFromPosition( targetPosition );\n\n\t\t/**\n\t\t * Defines whether `MoveOperation` is sticky. If `MoveOperation` is sticky, during\n\t\t * {@link module:engine/model/operation/transform~transform operational transformation} if there will be an operation that\n\t\t * inserts some nodes at the position equal to the boundary of this `MoveOperation`, that operation will\n\t\t * get their insertion path updated to the position where this `MoveOperation` moves the range.\n\t\t *\n\t\t * @member {Boolean} module:engine/model/operation/moveoperation~MoveOperation#isSticky\n\t\t */\n\t\tthis.isSticky = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'move';\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/moveoperation~MoveOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\tconst op = new this.constructor( this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion );\n\t\top.isSticky = this.isSticky;\n\n\t\treturn op;\n\t}\n\n\t/**\n\t * Returns the start position of the moved range after it got moved. This may be different than\n\t * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved\n\t * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}\n\t * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.\n\t *\n\t *\t\t vv              vv\n\t *\t\tabcdefg ===> adefbcg\n\t *\t\t     ^          ^\n\t *\t\t     targetPos\tmovedRangeStart\n\t *\t\t     offset 6\toffset 4\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetMovedRangeStart() {\n\t\treturn this.targetPosition._getTransformedByDeletion( this.sourcePosition, this.howMany );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n\t */\n\tgetReversed() {\n\t\tconst newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );\n\n\t\tconst op = new this.constructor( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );\n\t\top.isSticky = this.isSticky;\n\n\t\treturn op;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tconst sourceElement = this.sourcePosition.parent;\n\t\tconst targetElement = this.targetPosition.parent;\n\t\tconst sourceOffset = this.sourcePosition.offset;\n\t\tconst targetOffset = this.targetPosition.offset;\n\n\t\t// Validate whether move operation has correct parameters.\n\t\t// Validation is pretty complex but move operation is one of the core ways to manipulate the document state.\n\t\t// We expect that many errors might be connected with one of scenarios described below.\n\t\tif ( !sourceElement || !targetElement ) {\n\t\t\t/**\n\t\t\t * Source position or target position is invalid.\n\t\t\t *\n\t\t\t * @error move-operation-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'move-operation-position-invalid: Source position or target position is invalid.'\n\t\t\t);\n\t\t} else if ( sourceOffset + this.howMany > sourceElement.maxOffset ) {\n\t\t\t/**\n\t\t\t * The nodes which should be moved do not exist.\n\t\t\t *\n\t\t\t * @error move-operation-nodes-do-not-exist\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.'\n\t\t\t);\n\t\t} else if ( sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany ) {\n\t\t\t/**\n\t\t\t * Trying to move a range of nodes into the middle of that range.\n\t\t\t *\n\t\t\t * @error move-operation-range-into-itself\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.'\n\t\t\t);\n\t\t} else if ( this.sourcePosition.root == this.targetPosition.root ) {\n\t\t\tif ( compareArrays( this.sourcePosition.getParentPath(), this.targetPosition.getParentPath() ) == 'prefix' ) {\n\t\t\t\tconst i = this.sourcePosition.path.length - 1;\n\n\t\t\t\tif ( this.targetPosition.path[ i ] >= sourceOffset && this.targetPosition.path[ i ] < sourceOffset + this.howMany ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Trying to move a range of nodes into one of nodes from that range.\n\t\t\t\t\t *\n\t\t\t\t\t * @error move-operation-node-into-itself\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\t_move( Range.createFromPositionAndShift( this.sourcePosition, this.howMany ), this.targetPosition );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.MoveOperation';\n\t}\n\n\t/**\n\t * Creates `MoveOperation` object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\tconst sourcePosition = Position.fromJSON( json.sourcePosition, document );\n\t\tconst targetPosition = Position.fromJSON( json.targetPosition, document );\n\n\t\tconst move = new this( sourcePosition, json.howMany, targetPosition, json.baseVersion );\n\n\t\tif ( json.isSticky ) {\n\t\t\tmove.isSticky = true;\n\t\t}\n\n\t\treturn move;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/reinsertoperation\n */\n\nimport MoveOperation from './moveoperation';\nimport RemoveOperation from './removeoperation';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to reinsert previously removed nodes back to the non-graveyard root. This operation acts like\n * {@link module:engine/model/operation/moveoperation~MoveOperation} but it returns\n * {@link module:engine/model/operation/removeoperation~RemoveOperation} when reversed\n * and fires different change event.\n */\nexport default class ReinsertOperation extends MoveOperation {\n\t/**\n\t * Position where nodes will be re-inserted.\n\t *\n\t * @type {module:engine/model/position~Position}\n\t */\n\tget position() {\n\t\treturn this.targetPosition;\n\t}\n\n\t/**\n\t * @param {module:engine/model/position~Position} pos\n\t */\n\tset position( pos ) {\n\t\tthis.targetPosition = pos;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'reinsert';\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/removeoperation~RemoveOperation}\n\t */\n\tgetReversed() {\n\t\tconst newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );\n\n\t\treturn new RemoveOperation( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tsuper._validate();\n\n\t\tif ( !this.sourcePosition.root.document ) {\n\t\t\tthrow new CKEditorError( 'reinsert-operation-on-detached-item: Cannot reinsert detached item.' );\n\t\t}\n\n\t\tif ( !this.targetPosition.root.document ) {\n\t\t\tthrow new CKEditorError( 'reinsert-operation-to-detached-parent: Cannot reinsert item to detached parent.' );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.ReinsertOperation';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/removeoperation\n */\n\nimport MoveOperation from './moveoperation';\nimport ReinsertOperation from './reinsertoperation';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to remove a range of nodes.\n */\nexport default class RemoveOperation extends MoveOperation {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'remove';\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/reinsertoperation~ReinsertOperation|module:engine/model/operation/nooperation~NoOperation}\n\t */\n\tgetReversed() {\n\t\tconst newTargetPosition = this.sourcePosition._getTransformedByInsertion( this.targetPosition, this.howMany );\n\n\t\treturn new ReinsertOperation( this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tsuper._validate();\n\n\t\tif ( !this.sourcePosition.root.document ) {\n\t\t\t/**\n\t\t\t * Item that is going to be removed needs to be a {@link module:engine/model/document~Document document} child.\n\t\t\t * To remove Item from detached document fragment use\n\t\t\t * {@link module:engine/model/operation/detachoperation~DetachOperation DetachOperation}.\n\t\t\t *\n\t\t\t * @error remove-operation-on-detached-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'remove-operation-on-detached-item: Cannot remove detached item.' );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.RemoveOperation';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/insertoperation\n */\n\nimport Operation from './operation';\nimport Position from '../position';\nimport NodeList from '../nodelist';\nimport RemoveOperation from './removeoperation';\nimport { _insert, _normalizeNodes } from './utils';\nimport Text from '../text';\nimport Element from '../element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to insert one or more nodes at given position in the model.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class InsertOperation extends Operation {\n\t/**\n\t * Creates an insert operation.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of insertion.\n\t * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( position, nodes, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Position of insertion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/insertoperation~InsertOperation#position\n\t\t */\n\t\tthis.position = Position.createFromPosition( position );\n\n\t\t/**\n\t\t * List of nodes to insert.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/operation/insertoperation~InsertOperation#nodeList\n\t\t */\n\t\tthis.nodes = new NodeList( _normalizeNodes( nodes ) );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'insert';\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/insertoperation~InsertOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\tconst nodes = new NodeList( [ ...this.nodes ].map( node => node._clone( true ) ) );\n\n\t\treturn new InsertOperation( this.position, nodes, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/removeoperation~RemoveOperation}\n\t */\n\tgetReversed() {\n\t\tconst graveyard = this.position.root.document.graveyard;\n\t\tconst gyPosition = new Position( graveyard, [ 0 ] );\n\n\t\treturn new RemoveOperation( this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tconst targetElement = this.position.parent;\n\n\t\tif ( !targetElement || targetElement.maxOffset < this.position.offset ) {\n\t\t\t/**\n\t\t\t * Insertion position is invalid.\n\t\t\t *\n\t\t\t * @error insert-operation-position-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'insert-operation-position-invalid: Insertion position is invalid.'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\t// What happens here is that we want original nodes be passed to writer because we want original nodes\n\t\t// to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added\n\t\t// to the operation, not modified. For example, text nodes can get merged or cropped while Elements can\n\t\t// get children. It is important that InsertOperation has the copy of original nodes in intact state.\n\t\tconst originalNodes = this.nodes;\n\t\tthis.nodes = new NodeList( [ ...originalNodes ].map( node => node._clone( true ) ) );\n\n\t\t_insert( this.position, originalNodes );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.InsertOperation';\n\t}\n\n\t/**\n\t * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/insertoperation~InsertOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\tconst children = [];\n\n\t\tfor ( const child of json.nodes ) {\n\t\t\tif ( child.name ) {\n\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t} else {\n\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new InsertOperation( Position.fromJSON( json.position, document ), children, json.baseVersion );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/markeroperation\n */\n\nimport Operation from './operation';\nimport Range from '../range';\n\n/**\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class MarkerOperation extends Operation {\n\t/**\n\t * @param {String} name Marker name.\n\t * @param {module:engine/model/range~Range} oldRange Marker range before the change.\n\t * @param {module:engine/model/range~Range} newRange Marker range after the change.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Marker collection on which change should be executed.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * @param {Boolean} affectsData Specifies whether the marker operation affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( name, oldRange, newRange, markers, baseVersion, affectsData ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Marker name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Marker range before the change.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range}\n\t\t */\n\t\tthis.oldRange = oldRange ? Range.createFromRange( oldRange ) : null;\n\n\t\t/**\n\t\t * Marker range after the change.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range}\n\t\t */\n\t\tthis.newRange = newRange ? Range.createFromRange( newRange ) : null;\n\n\t\t/**\n\t\t * Specifies whether the marker operation affects the data produced by the data pipeline\n\t\t * (is persisted in the editor's data).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.affectsData = affectsData;\n\n\t\t/**\n\t\t * Marker collection on which change should be executed.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markers = markers;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'marker';\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/markeroperation~MarkerOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new MarkerOperation( this.name, this.oldRange, this.newRange, this._markers, this.baseVersion, this.affectsData );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/markeroperation~MarkerOperation}\n\t */\n\tgetReversed() {\n\t\treturn new MarkerOperation( this.name, this.newRange, this.oldRange, this._markers, this.baseVersion + 1, this.affectsData );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\tconst type = this.newRange ? '_set' : '_remove';\n\n\t\tthis._markers[ type ]( this.name, this.newRange, true, this.affectsData );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tdelete json._markers;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.MarkerOperation';\n\t}\n\n\t/**\n\t * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/markeroperation~MarkerOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\treturn new MarkerOperation(\n\t\t\tjson.name,\n\t\t\tjson.oldRange ? Range.fromJSON( json.oldRange, document ) : null,\n\t\t\tjson.newRange ? Range.fromJSON( json.newRange, document ) : null,\n\t\t\tdocument.model.markers,\n\t\t\tjson.baseVersion,\n\t\t\tjson.affectsData\n\t\t);\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/nooperation\n */\n\nimport Operation from './operation';\n\n/**\n * Operation which is doing nothing (\"empty operation\", \"do-nothing operation\", \"noop\"). This is an operation,\n * which when executed does not change the tree model. It still has some parameters defined for transformation purposes.\n *\n * In most cases this operation is a result of transforming operations. When transformation returns\n * {@link module:engine/model/operation/nooperation~NoOperation} it means that changes done by the transformed operation\n * have already been applied.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class NoOperation extends Operation {\n\tget type() {\n\t\treturn 'noop';\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/nooperation~NoOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new NoOperation( this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/nooperation~NoOperation}\n\t */\n\tgetReversed() {\n\t\treturn new NoOperation( this.baseVersion + 1 );\n\t}\n\n\t_execute() {\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.NoOperation';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/renameoperation\n */\n\nimport Operation from './operation';\nimport Element from '../element';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Position from '../position';\n\n/**\n * Operation to change element's name.\n *\n * Using this class you can change element's name.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class RenameOperation extends Operation {\n\t/**\n\t * Creates an operation that changes element's name.\n\t *\n\t * @param {module:engine/model/position~Position} position Position before an element to change.\n\t * @param {String} oldName Current name of the element.\n\t * @param {String} newName New name for the element.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( position, oldName, newName, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Position before an element to change.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} module:engine/model/operation/renameoperation~RenameOperation#position\n\t\t */\n\t\tthis.position = position;\n\n\t\t/**\n\t\t * Current name of the element.\n\t\t *\n\t\t * @member {String} module:engine/model/operation/renameoperation~RenameOperation#oldName\n\t\t */\n\t\tthis.oldName = oldName;\n\n\t\t/**\n\t\t * New name for the element.\n\t\t *\n\t\t * @member {String} module:engine/model/operation/renameoperation~RenameOperation#newName\n\t\t */\n\t\tthis.newName = newName;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'rename';\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/renameoperation~RenameOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new RenameOperation( Position.createFromPosition( this.position ), this.oldName, this.newName, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/renameoperation~RenameOperation}\n\t */\n\tgetReversed() {\n\t\treturn new RenameOperation( Position.createFromPosition( this.position ), this.newName, this.oldName, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tconst element = this.position.nodeAfter;\n\n\t\tif ( !( element instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Given position is invalid or node after it is not instance of Element.\n\t\t\t *\n\t\t\t * @error rename-operation-wrong-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.'\n\t\t\t);\n\t\t} else if ( element.name !== this.oldName ) {\n\t\t\t/**\n\t\t\t * Element to change has different name than operation's old name.\n\t\t\t *\n\t\t\t * @error rename-operation-wrong-name\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rename-operation-wrong-name: Element to change has different name than operation\\'s old name.'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\tconst element = this.position.nodeAfter;\n\n\t\telement.name = this.newName;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.RenameOperation';\n\t}\n\n\t/**\n\t * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\treturn new RenameOperation( Position.fromJSON( json.position, document ), json.oldName, json.newName, json.baseVersion );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/rootattributeoperation\n */\n\nimport Operation from './operation';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to change root element's attribute. Using this class you can add, remove or change value of the attribute.\n *\n * This operation is needed, because root elements can't be changed through\n * @link module:engine/model/operation/attributeoperation~AttributeOperation}.\n * It is because {@link module:engine/model/operation/attributeoperation~AttributeOperation}\n * requires a range to change and root element can't\n * be a part of range because every {@link module:engine/model/position~Position} has to be inside a root.\n * {@link module:engine/model/position~Position} can't be created before a root element.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class RootAttributeOperation extends Operation {\n\t/**\n\t * Creates an operation that changes, removes or adds attributes on root element.\n\t *\n\t * @see module:engine/model/operation/attributeoperation~AttributeOperation\n\t * @param {module:engine/model/rootelement~RootElement} root Root element to change.\n\t * @param {String} key Key of an attribute to change or remove.\n\t * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.\n\t * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.\n\t * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n\t * can be applied or `null` if the operation operates on detached (non-document) tree.\n\t */\n\tconstructor( root, key, oldValue, newValue, baseVersion ) {\n\t\tsuper( baseVersion );\n\n\t\t/**\n\t\t * Root element to change.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/rootelement~RootElement}\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Key of an attribute to change or remove.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.key = key;\n\n\t\t/**\n\t\t * Old value of the attribute with given key or `null` if adding a new attribute.\n\t\t *\n\t\t * @readonly\n\t\t * @member {*}\n\t\t */\n\t\tthis.oldValue = oldValue;\n\n\t\t/**\n\t\t * New value to set for the attribute. If `null`, then the operation just removes the attribute.\n\t\t *\n\t\t * @readonly\n\t\t * @member {*}\n\t\t */\n\t\tthis.newValue = newValue;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\tif ( this.oldValue === null ) {\n\t\t\treturn 'addRootAttribute';\n\t\t} else if ( this.newValue === null ) {\n\t\t\treturn 'removeRootAttribute';\n\t\t} else {\n\t\t\treturn 'changeRootAttribute';\n\t\t}\n\t}\n\n\t/**\n\t * Creates and returns an operation that has the same parameters as this operation.\n\t *\n\t * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation} Clone of this operation.\n\t */\n\tclone() {\n\t\treturn new RootAttributeOperation( this.root, this.key, this.oldValue, this.newValue, this.baseVersion );\n\t}\n\n\t/**\n\t * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n\t *\n\t * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}\n\t */\n\tgetReversed() {\n\t\treturn new RootAttributeOperation( this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tif ( this.root != this.root.root || this.root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * The element to change is not a root element.\n\t\t\t *\n\t\t\t * @error rootattribute-operation-not-a-root\n\t\t\t * @param {module:engine/model/rootelement~RootElement} root\n\t\t\t * @param {String} key\n\t\t\t * @param {*} value\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rootattribute-operation-not-a-root: The element to change is not a root element.',\n\t\t\t\t{ root: this.root, key: this.key }\n\t\t\t);\n\t\t}\n\n\t\tif ( this.oldValue !== null && this.root.getAttribute( this.key ) !== this.oldValue ) {\n\t\t\t/**\n\t\t\t * The attribute which should be removed does not exists for the given node.\n\t\t\t *\n\t\t\t * @error rootattribute-operation-wrong-old-value\n\t\t\t * @param {module:engine/model/rootelement~RootElement} root\n\t\t\t * @param {String} key\n\t\t\t * @param {*} value\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation\\'s ' +\n\t\t\t\t'old attribute value.',\n\t\t\t\t{ root: this.root, key: this.key }\n\t\t\t);\n\t\t}\n\n\t\tif ( this.oldValue === null && this.newValue !== null && this.root.hasAttribute( this.key ) ) {\n\t\t\t/**\n\t\t\t * The attribute with given key already exists for the given node.\n\t\t\t *\n\t\t\t * @error rootattribute-operation-attribute-exists\n\t\t\t * @param {module:engine/model/rootelement~RootElement} root\n\t\t\t * @param {String} key\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rootattribute-operation-attribute-exists: The attribute with given key already exists.',\n\t\t\t\t{ root: this.root, key: this.key }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\tif ( this.newValue !== null ) {\n\t\t\tthis.root._setAttribute( this.key, this.newValue );\n\t\t} else {\n\t\t\tthis.root._removeAttribute( this.key );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.RootAttributeOperation';\n\t}\n\n\t/**\n\t * Creates RootAttributeOperation object from deserilized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\tif ( !document.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create RootAttributeOperation for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error rootattributeoperation-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.',\n\t\t\t\t{ rootName: json }\n\t\t\t);\n\t\t}\n\n\t\treturn new RootAttributeOperation( document.getRoot( json.root ), json.key, json.oldValue, json.newValue, json.baseVersion );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/operationfactory\n */\n\nimport AttributeOperation from '../operation/attributeoperation';\nimport InsertOperation from '../operation/insertoperation';\nimport MarkerOperation from '../operation/markeroperation';\nimport MoveOperation from '../operation/moveoperation';\nimport NoOperation from '../operation/nooperation';\nimport Operation from '../operation/operation';\nimport ReinsertOperation from '../operation/reinsertoperation';\nimport RemoveOperation from '../operation/removeoperation';\nimport RenameOperation from '../operation/renameoperation';\nimport RootAttributeOperation from '../operation/rootattributeoperation';\n\nconst operations = {};\noperations[ AttributeOperation.className ] = AttributeOperation;\noperations[ InsertOperation.className ] = InsertOperation;\noperations[ MarkerOperation.className ] = MarkerOperation;\noperations[ MoveOperation.className ] = MoveOperation;\noperations[ NoOperation.className ] = NoOperation;\noperations[ Operation.className ] = Operation;\noperations[ ReinsertOperation.className ] = ReinsertOperation;\noperations[ RemoveOperation.className ] = RemoveOperation;\noperations[ RenameOperation.className ] = RenameOperation;\noperations[ RootAttributeOperation.className ] = RootAttributeOperation;\n\n/**\n * A factory class for creating operations.\n *\n * @abstract\n */\nexport default class OperationFactory {\n\t/**\n\t * Creates concrete `Operation` object from deserialized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n\t * @returns {module:engine/model/operation/operation~Operation}\n\t */\n\tstatic fromJSON( json, document ) {\n\t\treturn operations[ json.__className ].fromJSON( json, document );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/deltafactory\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport OperationFactory from '../operation/operationfactory';\n\nconst deserializers = new Map();\n\n/**\n * A factory class for creating operations.\n *\n * Delta is a single, from the user action point of view, change in the editable document, like insert, split or\n * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.\n *\n * Multiple deltas are grouped into a single {@link module:engine/model/batch~Batch}.\n */\nexport default class DeltaFactory {\n\t/**\n\t * Creates InsertDelta from deserialized object, i.e. from parsed JSON string.\n\t *\n\t * @param {Object} json\n\t * @param {module:engine/model/document~Document} doc Document on which this delta will be applied.\n\t * @returns {module:engine/model/delta/insertdelta~InsertDelta}\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( !deserializers.has( json.__className ) ) {\n\t\t\t/**\n\t\t\t * This delta has no defined deserializer.\n\t\t\t *\n\t\t\t * @error delta-fromjson-no-deserializer\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'delta-fromjson-no-deserializer: This delta has no defined deserializer',\n\t\t\t\t{ name: json.__className }\n\t\t\t);\n\t\t}\n\n\t\tconst Delta = deserializers.get( json.__className );\n\n\t\tconst delta = new Delta();\n\n\t\tfor ( const operation of json.operations ) {\n\t\t\tdelta.addOperation( OperationFactory.fromJSON( operation, doc ) );\n\t\t}\n\n\t\t// Rewrite all other properties.\n\t\tfor ( const prop in json ) {\n\t\t\tif ( prop != '__className' && delta[ prop ] === undefined ) {\n\t\t\t\tdelta[ prop ] = json[ prop ];\n\t\t\t}\n\t\t}\n\n\t\treturn delta;\n\t}\n\n\t/**\n\t * Registers a class for delta factory.\n\t *\n\t * @param {Function} Delta A delta class to register.\n\t */\n\tstatic register( Delta ) {\n\t\tdeserializers.set( Delta.className, Delta );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/delta\n */\n\nimport clone from '@ckeditor/ckeditor5-utils/src/lib/lodash/clone';\nimport DeltaFactory from './deltafactory';\n\n/**\n * Base class for all deltas.\n *\n * Delta is a single, from the user action point of view, change in the editable document, like insert, split or\n * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.\n *\n * Multiple deltas are grouped into a single {@link module:engine/model/batch~Batch}.\n */\nexport default class Delta {\n\t/**\n\t * Creates a delta instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * {@link module:engine/model/batch~Batch} which delta is a part of. This property is null by default and set by the\n\t\t * {@link module:engine/model/batch~Batch#addDelta} method.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/batch~Batch} module:engine/model/delta/delta~Delta#batch\n\t\t */\n\t\tthis.batch = null;\n\n\t\t/**\n\t\t * Array of operations which compose delta.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/operation/operation~Operation[]} module:engine/model/delta/delta~Delta#operations\n\t\t */\n\t\tthis.operations = [];\n\t}\n\n\t/**\n\t * Returns delta base version which is equal to the base version of the first operation in delta. If there\n\t * are no operations in delta, returns `null`.\n\t *\n\t * @see module:engine/model/document~Document\n\t * @type {Number|null}\n\t */\n\tget baseVersion() {\n\t\tif ( this.operations.length > 0 ) {\n\t\t\treturn this.operations[ 0 ].baseVersion;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {Number} baseVersion\n\t */\n\tset baseVersion( baseVersion ) {\n\t\tfor ( const operation of this.operations ) {\n\t\t\toperation.baseVersion = baseVersion++;\n\t\t}\n\t}\n\n\t/**\n\t * A class that will be used when creating reversed delta.\n\t *\n\t * @private\n\t * @type {Function}\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn Delta;\n\t}\n\n\t/**\n\t * Delta type.\n\t *\n\t * @readonly\n\t * @member {String} #type\n\t */\n\n\t/**\n\t * Add operation to the delta.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation instance.\n\t */\n\taddOperation( operation ) {\n\t\toperation.delta = this;\n\t\tthis.operations.push( operation );\n\n\t\treturn operation;\n\t}\n\n\t/**\n\t * Creates and returns a delta that has the same parameters as this delta.\n\t *\n\t * @returns {module:engine/model/delta/delta~Delta} Clone of this delta.\n\t */\n\tclone() {\n\t\tconst delta = new this.constructor();\n\n\t\tfor ( const op of this.operations ) {\n\t\t\tdelta.addOperation( op.clone() );\n\t\t}\n\n\t\treturn delta;\n\t}\n\n\t/**\n\t * Creates and returns a reverse delta. Reverse delta when executed right after the original delta will bring back\n\t * tree model state to the point before the original delta execution. In other words, it reverses changes done\n\t * by the original delta.\n\t *\n\t * Keep in mind that tree model state may change since executing the original delta, so reverse delta may be \"outdated\".\n\t * In that case you will need to {@link module:engine/model/delta/transform~transform} it by all deltas that were executed after\n\t * the original delta.\n\t *\n\t * @returns {module:engine/model/delta/delta~Delta} Reversed delta.\n\t */\n\tgetReversed() {\n\t\tconst delta = new this._reverseDeltaClass();\n\n\t\tfor ( const op of this.operations ) {\n\t\t\tdelta.addOperation( op.getReversed() );\n\t\t}\n\n\t\tdelta.operations.reverse();\n\n\t\tfor ( let i = 0; i < delta.operations.length; i++ ) {\n\t\t\tdelta.operations[ i ].baseVersion = this.operations[ this.operations.length - 1 ].baseVersion + i + 1;\n\t\t}\n\n\t\treturn delta;\n\t}\n\n\t/**\n\t * Custom toJSON method to make deltas serializable.\n\t *\n\t * @returns {Object} Clone of this delta with added class name.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\tjson.__className = this.constructor.className;\n\n\t\t// Remove parent batch to avoid circular dependencies.\n\t\tdelete json.batch;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Delta class name. Used by {@link #toJSON} method for serialization and\n\t * {@link module:engine/model/delta/deltafactory~DeltaFactory.fromJSON} during deserialization.\n\t *\n\t * @type {String}\n\t * @readonly\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.Delta';\n\t}\n}\n\nDeltaFactory.register( Delta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/attributedelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\nimport NoOperation from '../operation/nooperation';\nimport Range from '../range';\n\n/**\n * To provide specific OT behavior and better collisions solving, methods to change attributes\n * ({@link module:engine/model/writer~Writer#setAttribute} and {@link module:engine/model/writer~Writer#removeAttribute})\n * use `AttributeDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class AttributeDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'attribute';\n\t}\n\n\t/**\n\t * The attribute key that is changed by the delta or `null` if the delta has no operations.\n\t *\n\t * @readonly\n\t * @type {String|null}\n\t */\n\tget key() {\n\t\treturn this.operations[ 0 ] ? this.operations[ 0 ].key : null;\n\t}\n\n\t/**\n\t * The attribute value that is set by the delta or `null` if the delta has no operations.\n\t *\n\t * @readonly\n\t * @type {*|null}\n\t */\n\tget value() {\n\t\treturn this.operations[ 0 ] ? this.operations[ 0 ].newValue : null;\n\t}\n\n\t/**\n\t * The range on which delta operates or `null` if the delta has no operations.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/range~Range|null}\n\t */\n\tget range() {\n\t\t// Check if it is cached.\n\t\tif ( this._range ) {\n\t\t\treturn this._range;\n\t\t}\n\n\t\tlet start = null;\n\t\tlet end = null;\n\n\t\tfor ( const operation of this.operations ) {\n\t\t\tif ( operation instanceof NoOperation ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( start === null || start.isAfter( operation.range.start ) ) {\n\t\t\t\tstart = operation.range.start;\n\t\t\t}\n\n\t\t\tif ( end === null || end.isBefore( operation.range.end ) ) {\n\t\t\t\tend = operation.range.end;\n\t\t\t}\n\t\t}\n\n\t\tif ( start && end ) {\n\t\t\tthis._range = new Range( start, end );\n\n\t\t\treturn this._range;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget _reverseDeltaClass() {\n\t\treturn AttributeDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tdelete json._range;\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.AttributeDelta';\n\t}\n}\n\nDeltaFactory.register( AttributeDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/splitdelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\nimport MoveOperation from '../operation/moveoperation';\nimport MergeDelta from '../delta/mergedelta';\n\n/**\n * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/writer~Writer#split} method\n * uses `SplitDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class SplitDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'split';\n\t}\n\n\t/**\n\t * Position of split or `null` if there are no operations in the delta.\n\t *\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget position() {\n\t\treturn this._moveOperation ? this._moveOperation.sourcePosition : null;\n\t}\n\n\t/**\n\t * Operation in the delta that adds to model an element into which split nodes will be moved, or `null` if\n\t * there are no operations in the delta.\n\t *\n\t * Most commonly this will be {@link module:engine/model/operation/insertoperation~InsertOperation an insert operation},\n\t * as `SplitDelta` has to create a new node. If `SplitDelta` was created through\n\t * {@link module:engine/model/delta/delta~Delta#getReversed reversing}\n\t * a {@link module:engine/model/delta/mergedelta~MergeDelta merge delta},\n\t * this will be a {@link module:engine/model/operation/reinsertoperation~ReinsertOperation reinsert operation},\n\t * as we will want to re-insert the exact element that was removed by that merge delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/insertoperation~InsertOperation|\n\t * module:engine/model/operation/reinsertoperation~ReinsertOperation|null}\n\t */\n\tget _cloneOperation() {\n\t\treturn this.operations[ 0 ] || null;\n\t}\n\n\t/**\n\t * Operation in the delta that moves model items, that are after split position, to their new parent or `null`\n\t * if there are no operations in the delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/moveoperation~MoveOperation|null}\n\t */\n\tget _moveOperation() {\n\t\treturn this.operations[ 1 ] && this.operations[ 1 ] instanceof MoveOperation ? this.operations[ 1 ] : null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn MergeDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.SplitDelta';\n\t}\n}\n\nDeltaFactory.register( SplitDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/mergedelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\nimport SplitDelta from './splitdelta';\n\n/**\n * To provide specific OT behavior and better collisions solving, {@link module:engine/model/writer~Writer#merge} method\n * uses the `MergeDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class MergeDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'merge';\n\t}\n\n\t/**\n\t * Position between to merged nodes or `null` if the delta has no operations.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget position() {\n\t\treturn this._removeOperation ? this._removeOperation.sourcePosition : null;\n\t}\n\n\t/**\n\t * Operation in this delta that removes the node after merge position (which will be empty at that point) or\n\t * `null` if the delta has no operations. Note, that after {@link module:engine/model/delta/transform~transform transformation}\n\t * this might be an instance of {@link module:engine/model/operation/moveoperation~MoveOperation} instead of\n\t * {@link module:engine/model/operation/removeoperation~RemoveOperation}.\n\t *\n\t * @readonly\n\t * @protected\n\t * @type {module:engine/model/operation/moveoperation~MoveOperation|null}\n\t */\n\tget _removeOperation() {\n\t\treturn this.operations[ 1 ] || null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn SplitDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.MergeDelta';\n\t}\n}\n\nDeltaFactory.register( MergeDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/movedelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, {@link module:engine/model/writer~Writer#move} method\n * uses the `MoveDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class MoveDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'move';\n\t}\n\n\t/**\n\t * Offset size of moved range or `null` if there are no operations in the delta.\n\t *\n\t * @type {Number|null}\n\t */\n\tget howMany() {\n\t\treturn this._moveOperation ? this._moveOperation.howMany : null;\n\t}\n\n\t/**\n\t * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation}\n\t * {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition source position} or `null` if there are\n\t * no operations in the delta.\n\t *\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget sourcePosition() {\n\t\treturn this._moveOperation ? this._moveOperation.sourcePosition : null;\n\t}\n\n\t/**\n\t * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation}\n\t * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition target position} or `null` if there are\n\t * no operations in the delta.\n\t *\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget targetPosition() {\n\t\treturn this._moveOperation ? this._moveOperation.targetPosition : null;\n\t}\n\n\t/**\n\t * {@link module:engine/model/delta/movedelta~MoveDelta#_moveOperation Move operation} that is saved in this delta or `null`\n\t * if there are no operations in the delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/moveoperation~MoveOperation|null}\n\t */\n\tget _moveOperation() {\n\t\treturn this.operations[ 0 ] || null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn MoveDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.MoveDelta';\n\t}\n}\n\nDeltaFactory.register( MoveDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/removedelta\n */\n\nimport MoveDelta from './movedelta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, {@link module:engine/model/writer~Writer#remove} method\n * uses the `RemoveDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class RemoveDelta extends MoveDelta {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.RemoveDelta';\n\t}\n}\n\nDeltaFactory.register( RemoveDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/renamedelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/writer~Writer#rename Batch#rename} method\n * uses the `RenameDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class RenameDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'rename';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn RenameDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.RenameDelta';\n\t}\n}\n\nDeltaFactory.register( RenameDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/wrapdelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\nimport UnwrapDelta from './unwrapdelta';\nimport Range from '../range';\n\n/**\n * To provide specific OT behavior and better collisions solving, {@link module:engine/model/writer~Writer#merge} method\n * uses the `WrapDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class WrapDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'wrap';\n\t}\n\n\t/**\n\t * Range to wrap or `null` if there are no operations in the delta.\n\t *\n\t * @type {module:engine/model/range~Range|null}\n\t */\n\tget range() {\n\t\tconst moveOp = this._moveOperation;\n\n\t\treturn moveOp ? Range.createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany ) : null;\n\t}\n\n\t/**\n\t * Offset size of range to wrap by the delta or `null` if there are no operations in delta.\n\t *\n\t * @type {Number}\n\t */\n\tget howMany() {\n\t\tconst range = this.range;\n\n\t\treturn range ? range.end.offset - range.start.offset : 0;\n\t}\n\n\t/* eslint-disable max-len */\n\t/**\n\t * Operation that inserts wrapping element or `null` if there are no operations in the delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/insertoperation~InsertOperation|module:engine/model/operation/reinsertoperation~ReinsertOperation}\n\t */\n\t/* eslint-enable max-len */\n\tget _insertOperation() {\n\t\treturn this.operations[ 0 ] || null;\n\t}\n\n\t/**\n\t * Operation that moves wrapped nodes to their new parent or `null` if there are no operations in the delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/moveoperation~MoveOperation|null}\n\t */\n\tget _moveOperation() {\n\t\treturn this.operations[ 1 ] || null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn UnwrapDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.WrapDelta';\n\t}\n}\n\nDeltaFactory.register( WrapDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/unwrapdelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\nimport WrapDelta from './wrapdelta';\n\n/**\n * To provide specific OT behavior and better collisions solving, {@link module:engine/model/writer~Writer#merge} method\n * uses the `UnwrapDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class UnwrapDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'unwrap';\n\t}\n\n\t/**\n\t * Position before unwrapped element or `null` if there are no operations in the delta.\n\t *\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget position() {\n\t\treturn this._moveOperation ? this._moveOperation.targetPosition : null;\n\t}\n\n\t/**\n\t * Operation in the delta that moves unwrapped nodes to their new parent or `null` if there are no operations in the delta.\n\t *\n\t * @protected\n\t * @type {module:engine/model/operation/moveoperation~MoveOperation|null}\n\t */\n\tget _moveOperation() {\n\t\treturn this.operations[ 0 ] || null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn WrapDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.UnwrapDelta';\n\t}\n}\n\nDeltaFactory.register( UnwrapDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/insertdelta\n */\n\nimport Delta from './delta';\nimport RemoveDelta from './removedelta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/writer~Writer#insert Batch#insert} method\n * uses the `InsertDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class InsertDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'insert';\n\t}\n\n\t/**\n\t * Position where the delta inserts nodes or `null` if there are no operations in the delta.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget position() {\n\t\treturn this._insertOperation ? this._insertOperation.position : null;\n\t}\n\n\t/**\n\t * Node list containing all the nodes inserted by the delta or `null` if there are no operations in the delta.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/nodelist~NodeList|null}\n\t */\n\tget nodes() {\n\t\treturn this._insertOperation ? this._insertOperation.nodes : null;\n\t}\n\n\t/**\n\t * Insert operation that is saved in this delta or `null` if there are no operations in the delta.\n\t *\n\t * @readonly\n\t * @protected\n\t * @type {module:engine/model/operation/insertoperation~InsertOperation|null}\n\t */\n\tget _insertOperation() {\n\t\treturn this.operations[ 0 ] || null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn RemoveDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.InsertDelta';\n\t}\n}\n\nDeltaFactory.register( InsertDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/weakinsertdelta\n */\n\nimport InsertDelta from './insertdelta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/writer~Writer#insert} method\n * uses the `WeakInsertDelta` class which inherits from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class WeakInsertDelta extends InsertDelta {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.WeakInsertDelta';\n\t}\n}\n\nDeltaFactory.register( WeakInsertDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/transform\n */\n\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RemoveOperation from './removeoperation';\nimport ReinsertOperation from './reinsertoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Transforms given {@link module:engine/model/operation/operation~Operation operation}\n * by another {@link module:engine/model/operation/operation~Operation operation}\n * and returns the result of that transformation as an array containing\n * one or more {@link module:engine/model/operation/operation~Operation operations}.\n *\n * Operations work on specified positions, passed to them when they are created.\n * Whenever {@link module:engine/model/document~Document document}\n * changes, we have to reflect those modifications by updating or \"transforming\" operations which are not yet applied.\n * When an operation is transformed, its parameters may change based on the operation by which it is transformed.\n * If the transform-by operation applied any modifications to the Tree Data Model which affect positions or nodes\n * connected with transformed operation, those changes will be reflected in the parameters of the returned operation(s).\n *\n * Whenever the {@link module:engine/model/document~Document document}\n * has different {@link module:engine/model/document~Document#version}\n * than the operation you want to {@link module:engine/model/model~Model#applyOperation apply}, you need to transform that\n * operation by all operations which were already applied to the {@link module:engine/model/document~Document document} and have greater\n * {@link module:engine/model/document~Document#version} than the operation being applied. Transform them in the same order as those\n * operations which were applied. This way all modifications done to the Tree Data Model will be reflected\n * in the operation parameters and the operation will \"operate\" on \"up-to-date\" version of the Tree Data Model.\n * This is mostly the case with Operational Transformations but it might be needed in particular features as well.\n *\n * In some cases, when given operation apply changes to the same nodes as this operation, two or more operations need\n * to be created as one would not be able to reflect the combination of these operations.\n * This is why an array is returned instead of a single object. All returned operations have to be applied\n * (or further transformed) to get an effect which was intended in pre-transformed operation.\n *\n * Sometimes two operations are in conflict. This happens when they modify the same node in a different way, i.e.\n * set different value for the same attribute or move the node into different positions. When this happens,\n * we need to decide which operation is more important. We can't assume that operation `a` or operation `b` is always\n * more important. In Operational Transformations algorithms we often need to get a result of transforming\n * `a` by `b` and also `b` by `a`. In both transformations the same operation has to be the important one. If we assume\n * that first or the second passed operation is always more important we won't be able to solve this case.\n *\n * @function module:engine/model/operation/transform~transform\n * @param {module:engine/model/operation/operation~Operation} a Operation that will be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/delta/transform~transformationContext} [context] Transformation context.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Result of the transformation.\n */\n\nexport default transform;\n\nconst ot = {\n\tInsertOperation: {\n\t\t// Transforms InsertOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tInsertOperation( a, b, context ) {\n\t\t\t// Transformed operations are always new instances, not references to the original operations.\n\t\t\tconst transformed = a.clone();\n\n\t\t\t// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.\n\t\t\tconst insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;\n\n\t\t\t// Transform insert position by the other operation position.\n\t\t\ttransformed.position = transformed.position._getTransformedByInsertion( b.position, b.nodes.maxOffset, insertBefore );\n\n\t\t\treturn [ transformed ];\n\t\t},\n\n\t\tAttributeOperation: doNotUpdate,\n\n\t\tRootAttributeOperation: doNotUpdate,\n\n\t\tRenameOperation: doNotUpdate,\n\n\t\tMarkerOperation: doNotUpdate,\n\n\t\t// Transforms InsertOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tMoveOperation( a, b, context ) {\n\t\t\tconst transformed = a.clone();\n\n\t\t\t// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.\n\t\t\tconst insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;\n\n\t\t\t// Transform insert position by the other operation parameters.\n\t\t\ttransformed.position = a.position._getTransformedByMove(\n\t\t\t\tb.sourcePosition,\n\t\t\t\tb.targetPosition,\n\t\t\t\tb.howMany,\n\t\t\t\tinsertBefore,\n\t\t\t\tb.isSticky && !context.forceNotSticky\n\t\t\t);\n\n\t\t\treturn [ transformed ];\n\t\t}\n\t},\n\n\tAttributeOperation: {\n\t\t// Transforms AttributeOperation `a` by InsertOperation `b`. Returns results as an array of operations.\n\t\tInsertOperation( a, b ) {\n\t\t\t// Transform this operation's range.\n\t\t\tconst ranges = a.range._getTransformedByInsertion( b.position, b.nodes.maxOffset, true, false );\n\n\t\t\t// Map transformed range(s) to operations and return them.\n\t\t\treturn ranges.reverse().map( range => {\n\t\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t\t} );\n\t\t},\n\n\t\t// Transforms AttributeOperation `a` by AttributeOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tAttributeOperation( a, b, context ) {\n\t\t\tif ( a.key === b.key ) {\n\t\t\t\t// If operations attributes are in conflict, check if their ranges intersect and manage them properly.\n\n\t\t\t\t// First, we want to apply change to the part of a range that has not been changed by the other operation.\n\t\t\t\tconst operations = a.range.getDifference( b.range ).map( range => {\n\t\t\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t\t\t} );\n\n\t\t\t\t// Then we take care of the common part of ranges.\n\t\t\t\tconst common = a.range.getIntersection( b.range );\n\n\t\t\t\tif ( common ) {\n\t\t\t\t\t// If this operation is more important, we also want to apply change to the part of the\n\t\t\t\t\t// original range that has already been changed by the other operation. Since that range\n\t\t\t\t\t// got changed we also have to update `oldValue`.\n\t\t\t\t\tif ( context.isStrong ) {\n\t\t\t\t\t\toperations.push( new AttributeOperation( common, b.key, b.newValue, a.newValue, a.baseVersion ) );\n\t\t\t\t\t} else if ( operations.length === 0 ) {\n\t\t\t\t\t\toperations.push( new NoOperation( 0 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn operations;\n\t\t\t} else {\n\t\t\t\t// If operations don't conflict, simply return an array containing just a clone of this operation.\n\t\t\t\treturn [ a.clone() ];\n\t\t\t}\n\t\t},\n\n\t\tRootAttributeOperation: doNotUpdate,\n\n\t\tRenameOperation: doNotUpdate,\n\n\t\tMarkerOperation: doNotUpdate,\n\n\t\t// Transforms AttributeOperation `a` by MoveOperation `b`. Returns results as an array of operations.\n\t\tMoveOperation( a, b ) {\n\t\t\t// Convert MoveOperation properties into a range.\n\t\t\tconst rangeB = Range.createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t\t\t// This will aggregate transformed ranges.\n\t\t\tlet ranges = [];\n\n\t\t\t// Difference is a part of changed range that is modified by AttributeOperation but is not affected\n\t\t\t// by MoveOperation. This can be zero, one or two ranges (if moved range is inside changed range).\n\t\t\t// Right now we will make a simplification and join difference ranges and transform them as one. We will cover rangeB later.\n\t\t\tconst difference = joinRanges( a.range.getDifference( rangeB ) );\n\n\t\t\t// Common is a range of nodes that is affected by MoveOperation. So it got moved to other place.\n\t\t\tconst common = a.range.getIntersection( rangeB );\n\n\t\t\tif ( difference !== null ) {\n\t\t\t\t// MoveOperation removes nodes from their original position. We acknowledge this by proper transformation.\n\t\t\t\t// Take the start and the end of the range and transform them by deletion of moved nodes.\n\t\t\t\t// Note that if rangeB was inside AttributeOperation range, only difference.end will be transformed.\n\t\t\t\t// This nicely covers the joining simplification we did in the previous step.\n\t\t\t\tdifference.start = difference.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\t\t\tdifference.end = difference.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t\t\t// MoveOperation pastes nodes into target position. We acknowledge this by proper transformation.\n\t\t\t\t// Note that since we operate on transformed difference range, we should transform by\n\t\t\t\t// previously transformed target position.\n\t\t\t\t// Note that we do not use Position._getTransformedByMove on range boundaries because we need to\n\t\t\t\t// transform by insertion a range as a whole, since newTargetPosition might be inside that range.\n\t\t\t\tranges = difference._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, true, false ).reverse();\n\t\t\t}\n\n\t\t\tif ( common !== null ) {\n\t\t\t\t// Here we do not need to worry that newTargetPosition is inside moved range, because that\n\t\t\t\t// would mean that the MoveOperation targets into itself, and that is incorrect operation.\n\t\t\t\t// Instead, we calculate the new position of that part of original range.\n\t\t\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\t\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t\t\tranges.push( common );\n\t\t\t}\n\n\t\t\t// Map transformed range(s) to operations and return them.\n\t\t\treturn ranges.map( range => {\n\t\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t\t} );\n\t\t}\n\t},\n\n\tRootAttributeOperation: {\n\t\tInsertOperation: doNotUpdate,\n\n\t\tAttributeOperation: doNotUpdate,\n\n\t\t// Transforms RootAttributeOperation `a` by RootAttributeOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tRootAttributeOperation( a, b, context ) {\n\t\t\tif ( a.root === b.root && a.key === b.key ) {\n\t\t\t\tif ( ( a.newValue !== b.newValue && !context.isStrong ) || a.newValue === b.newValue ) {\n\t\t\t\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [ a.clone() ];\n\t\t},\n\n\t\tRenameOperation: doNotUpdate,\n\n\t\tMarkerOperation: doNotUpdate,\n\n\t\tMoveOperation: doNotUpdate\n\t},\n\n\tRenameOperation: {\n\t\t// Transforms RenameOperation `a` by InsertOperation `b`. Returns results as an array of operations.\n\t\tInsertOperation( a, b ) {\n\t\t\t// Clone the operation, we don't want to alter the original operation.\n\t\t\tconst clone = a.clone();\n\n\t\t\t// Transform this operation's position.\n\t\t\tclone.position = clone.position._getTransformedByInsertion( b.position, b.nodes.maxOffset, true );\n\n\t\t\treturn [ clone ];\n\t\t},\n\n\t\tAttributeOperation: doNotUpdate,\n\n\t\tRootAttributeOperation: doNotUpdate,\n\n\t\t// Transforms RenameOperation `a` by RenameOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tRenameOperation( a, b, context ) {\n\t\t\t// Clone the operation, we don't want to alter the original operation.\n\t\t\tconst clone = a.clone();\n\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\tif ( context.isStrong ) {\n\t\t\t\t\tclone.oldName = b.newName;\n\t\t\t\t} else {\n\t\t\t\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [ clone ];\n\t\t},\n\n\t\tMarkerOperation: doNotUpdate,\n\n\t\t// Transforms RenameOperation `a` by MoveOperation `b`. Returns results as an array of operations.\n\t\tMoveOperation( a, b ) {\n\t\t\tconst clone = a.clone();\n\t\t\tconst isSticky = clone.position.isEqual( b.sourcePosition );\n\n\t\t\tclone.position = clone.position._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, true, isSticky );\n\n\t\t\treturn [ clone ];\n\t\t}\n\t},\n\n\tMarkerOperation: {\n\t\t// Transforms MarkerOperation `a` by InsertOperation `b`. Returns results as an array of operations.\n\t\tInsertOperation( a, b ) {\n\t\t\t// Clone the operation, we don't want to alter the original operation.\n\t\t\tconst clone = a.clone();\n\n\t\t\tif ( clone.oldRange ) {\n\t\t\t\tclone.oldRange = clone.oldRange._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, false )[ 0 ];\n\t\t\t}\n\n\t\t\tif ( clone.newRange ) {\n\t\t\t\tclone.newRange = clone.newRange._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, false )[ 0 ];\n\t\t\t}\n\n\t\t\treturn [ clone ];\n\t\t},\n\n\t\tAttributeOperation: doNotUpdate,\n\n\t\tRootAttributeOperation: doNotUpdate,\n\n\t\tRenameOperation: doNotUpdate,\n\n\t\t// Transforms MarkerOperation `a` by MarkerOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tMarkerOperation( a, b, context ) {\n\t\t\t// Clone the operation, we don't want to alter the original operation.\n\t\t\tconst clone = a.clone();\n\n\t\t\tif ( a.name == b.name ) {\n\t\t\t\tif ( context.isStrong ) {\n\t\t\t\t\tclone.oldRange = b.newRange;\n\t\t\t\t} else {\n\t\t\t\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [ clone ];\n\t\t},\n\n\t\t// Transforms MarkerOperation `a` by MoveOperation `b`. Returns results as an array of operations.\n\t\tMoveOperation( a, b ) {\n\t\t\t// Clone the operation, we don't want to alter the original operation.\n\t\t\tconst clone = a.clone();\n\n\t\t\tif ( clone.oldRange ) {\n\t\t\t\tconst oldRanges = clone.oldRange._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\t\t\tclone.oldRange = Range.createFromRanges( oldRanges );\n\t\t\t}\n\n\t\t\tif ( clone.newRange ) {\n\t\t\t\tconst newRanges = clone.newRange._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\t\t\tclone.newRange = Range.createFromRanges( newRanges );\n\t\t\t}\n\n\t\t\treturn [ clone ];\n\t\t}\n\t},\n\n\tMoveOperation: {\n\t\t// Transforms MoveOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tInsertOperation( a, b, context ) {\n\t\t\t// Create range from MoveOperation properties and transform it by insertion.\n\t\t\tlet range = Range.createFromPositionAndShift( a.sourcePosition, a.howMany );\n\t\t\tconst includeB = a.isSticky && !context.forceNotSticky;\n\n\t\t\trange = range._getTransformedByInsertion( b.position, b.nodes.maxOffset, false, includeB )[ 0 ];\n\n\t\t\t// Check whether there is a forced order of nodes or use `context.isStrong` flag for conflict resolving.\n\t\t\tconst insertBefore = context.insertBefore === undefined ? !context.isStrong : context.insertBefore;\n\n\t\t\tconst result = new a.constructor(\n\t\t\t\trange.start,\n\t\t\t\trange.end.offset - range.start.offset,\n\t\t\t\ta.targetPosition._getTransformedByInsertion( b.position, b.nodes.maxOffset, insertBefore ),\n\t\t\t\ta.baseVersion\n\t\t\t);\n\n\t\t\tresult.isSticky = a.isSticky;\n\n\t\t\treturn [ result ];\n\t\t},\n\n\t\tAttributeOperation: doNotUpdate,\n\n\t\tRootAttributeOperation: doNotUpdate,\n\n\t\tRenameOperation: doNotUpdate,\n\n\t\tMarkerOperation: doNotUpdate,\n\n\t\t// Transforms MoveOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important\n\t\t// than `b` when it comes to resolving conflicts. Returns results as an array of operations.\n\t\tMoveOperation( a, b, context ) {\n\t\t\t//\n\t\t\t// Setting and evaluating some variables that will be used in special cases and default algorithm.\n\t\t\t//\n\t\t\t// Create ranges from `MoveOperations` properties.\n\t\t\tconst rangeA = Range.createFromPositionAndShift( a.sourcePosition, a.howMany );\n\t\t\tconst rangeB = Range.createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t\t\t// Assign `context.isStrong` to a different variable, because the value may change during execution of\n\t\t\t// this algorithm and we do not want to override original `context.isStrong` that will be used in later transformations.\n\t\t\tlet isStrong = context.isStrong;\n\n\t\t\t// Whether range moved by operation `b` is includable in operation `a` move range.\n\t\t\t// For this, `a` operation has to be sticky (so `b` sticks to the range) and context has to allow stickiness.\n\t\t\tconst includeB = a.isSticky && !context.forceNotSticky;\n\n\t\t\t// Evaluate new target position for transformed operation.\n\t\t\t// Check whether there is a forced order of nodes or use `isStrong` flag for conflict resolving.\n\t\t\tconst insertBefore = context.insertBefore === undefined ? !isStrong : context.insertBefore;\n\n\t\t\t// `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\t\t\tconst newTargetPosition = a.targetPosition._getTransformedByMove(\n\t\t\t\tb.sourcePosition,\n\t\t\t\tb.targetPosition,\n\t\t\t\tb.howMany,\n\t\t\t\tinsertBefore,\n\t\t\t\tb.isSticky && !context.forceNotSticky\n\t\t\t);\n\n\t\t\t//\n\t\t\t// Special case #1 + mirror.\n\t\t\t//\n\t\t\t// Special case when both move operations' target positions are inside nodes that are\n\t\t\t// being moved by the other move operation. So in other words, we move ranges into inside of each other.\n\t\t\t// This case can't be solved reasonably (on the other hand, it should not happen often).\n\t\t\tif ( moveTargetIntoMovedRange( a, b ) && moveTargetIntoMovedRange( b, a ) ) {\n\t\t\t\t// Instead of transforming operation, we return a reverse of the operation that we transform by.\n\t\t\t\t// So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n\t\t\t\treturn [ b.getReversed() ];\n\t\t\t}\n\t\t\t//\n\t\t\t// End of special case #1.\n\t\t\t//\n\n\t\t\t//\n\t\t\t// Special case #2.\n\t\t\t//\n\t\t\t// Check if `b` operation targets inside `rangeA`. Use stickiness if possible.\n\t\t\tconst bTargetsToA = rangeA.containsPosition( b.targetPosition ) ||\n\t\t\t\t( rangeA.start.isEqual( b.targetPosition ) && includeB ) ||\n\t\t\t\t( rangeA.end.isEqual( b.targetPosition ) && includeB );\n\n\t\t\t// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n\t\t\t// You might say that operation `b` is captured inside operation `a`.\n\t\t\tif ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {\n\t\t\t\t// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n\t\t\t\t// we need to transform `a` operation anyway.\n\t\t\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, !includeB );\n\t\t\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, includeB );\n\n\t\t\t\treturn makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Special case #2 mirror.\n\t\t\t//\n\t\t\tconst aTargetsToB = rangeB.containsPosition( a.targetPosition ) ||\n\t\t\t\t( rangeB.start.isEqual( a.targetPosition ) && b.isSticky && !context.forceNotSticky ) ||\n\t\t\t\t( rangeB.end.isEqual( a.targetPosition ) && b.isSticky && !context.forceNotSticky );\n\n\t\t\tif ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {\n\t\t\t\t// `a` operation is \"moved together\" with `b` operation.\n\t\t\t\t// Here, just move `rangeA` \"inside\" `rangeB`.\n\t\t\t\trangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\t\t\trangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t\t\treturn makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );\n\t\t\t}\n\t\t\t//\n\t\t\t// End of special case #2.\n\t\t\t//\n\n\t\t\t//\n\t\t\t// Special case #3 + mirror.\n\t\t\t//\n\t\t\t// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n\t\t\t// but not on the same tree level. In such case ranges have common part but we have to treat it\n\t\t\t// differently, because in such case those ranges are not really conflicting and should be treated like\n\t\t\t// two separate ranges. Also we have to discard two difference parts.\n\t\t\tconst aCompB = compareArrays( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );\n\n\t\t\tif ( aCompB == 'prefix' || aCompB == 'extension' ) {\n\t\t\t\t// Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n\t\t\t\t// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n\t\t\t\t// like a one difference part.\n\t\t\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, !includeB );\n\t\t\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany, includeB );\n\n\t\t\t\treturn makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition, a );\n\t\t\t}\n\t\t\t//\n\t\t\t// End of special case #3.\n\t\t\t//\n\n\t\t\t//\n\t\t\t// Default case - ranges are on the same level or are not connected with each other.\n\t\t\t//\n\t\t\t// Modifier for default case.\n\t\t\t// Modifies `isStrong` flag in certain conditions.\n\t\t\t//\n\t\t\t// If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n\t\t\t// to provide more expected results. This is done only if `context.forceWeakRemove` is set to `false`.\n\t\t\t// `context.forceWeakRemove` is set to `true` in certain conditions when transformation takes place during undo.\n\t\t\tif ( !context.forceWeakRemove ) {\n\t\t\t\tif ( a instanceof RemoveOperation && !( b instanceof RemoveOperation ) ) {\n\t\t\t\t\tisStrong = true;\n\t\t\t\t} else if ( !( a instanceof RemoveOperation ) && b instanceof RemoveOperation ) {\n\t\t\t\t\tisStrong = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n\t\t\t// This will aggregate transformed ranges.\n\t\t\tconst ranges = [];\n\n\t\t\t// Get the \"difference part\" of `a` operation source range.\n\t\t\t// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\t\t\tconst difference = rangeA.getDifference( rangeB );\n\n\t\t\tfor ( const range of difference ) {\n\t\t\t\t// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n\t\t\t\trange.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\t\t\trange.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t\t\t// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\t\t\t\tconst shouldSpread = compareArrays( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';\n\t\t\t\tconst newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread, includeB );\n\n\t\t\t\tranges.push( ...newRanges );\n\t\t\t}\n\n\t\t\t// Then, we have to manage the \"common part\" of both move ranges.\n\t\t\tconst common = rangeA.getIntersection( rangeB );\n\n\t\t\tif ( common !== null && isStrong && !bTargetsToA ) {\n\t\t\t\t// Calculate the new position of that part of original range.\n\t\t\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\t\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t\t\t// Take care of proper range order.\n\t\t\t\t//\n\t\t\t\t// Put `common` at appropriate place. Keep in mind that we are interested in original order.\n\t\t\t\t// Basically there are only three cases: there is zero, one or two difference ranges.\n\t\t\t\t//\n\t\t\t\t// If there is zero difference ranges, just push `common` in the array.\n\t\t\t\tif ( ranges.length === 0 ) {\n\t\t\t\t\tranges.push( common );\n\t\t\t\t}\n\t\t\t\t// If there is one difference range, we need to check whether common part was before it or after it.\n\t\t\t\telse if ( ranges.length == 1 ) {\n\t\t\t\t\tif ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {\n\t\t\t\t\t\tranges.unshift( common );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tranges.push( common );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If there are more ranges (which means two), put common part between them. This is the only scenario\n\t\t\t\t// where there could be two difference ranges so we don't have to make any comparisons.\n\t\t\t\telse {\n\t\t\t\t\tranges.splice( 1, 0, common );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ranges.length === 0 ) {\n\t\t\t\t// If there are no \"source ranges\", nothing should be changed.\n\t\t\t\t// Note that this can happen only if `isStrong == false` and `rangeA.isEqual( rangeB )`.\n\t\t\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t\t\t}\n\n\t\t\treturn makeMoveOperationsFromRanges( ranges, newTargetPosition, a );\n\t\t}\n\t}\n};\n\nfunction transform( a, b, context = { isStrong: false } ) {\n\tlet group, algorithm;\n\n\tif ( a instanceof InsertOperation ) {\n\t\tgroup = ot.InsertOperation;\n\t} else if ( a instanceof AttributeOperation ) {\n\t\tgroup = ot.AttributeOperation;\n\t} else if ( a instanceof RootAttributeOperation ) {\n\t\tgroup = ot.RootAttributeOperation;\n\t} else if ( a instanceof RenameOperation ) {\n\t\tgroup = ot.RenameOperation;\n\t} else if ( a instanceof MarkerOperation ) {\n\t\tgroup = ot.MarkerOperation;\n\t} else if ( a instanceof MoveOperation ) {\n\t\tgroup = ot.MoveOperation;\n\t} else {\n\t\talgorithm = doNotUpdate;\n\t}\n\n\tif ( group ) {\n\t\tif ( b instanceof InsertOperation ) {\n\t\t\talgorithm = group.InsertOperation;\n\t\t} else if ( b instanceof AttributeOperation ) {\n\t\t\talgorithm = group.AttributeOperation;\n\t\t} else if ( b instanceof RootAttributeOperation ) {\n\t\t\talgorithm = group.RootAttributeOperation;\n\t\t} else if ( b instanceof RenameOperation ) {\n\t\t\talgorithm = group.RenameOperation;\n\t\t} else if ( b instanceof MarkerOperation ) {\n\t\t\talgorithm = group.MarkerOperation;\n\t\t} else if ( b instanceof MoveOperation ) {\n\t\t\talgorithm = group.MoveOperation;\n\t\t} else {\n\t\t\talgorithm = doNotUpdate;\n\t\t}\n\t}\n\n\tconst transformed = algorithm( a, b, context );\n\n\treturn updateBaseVersions( a.baseVersion, transformed );\n}\n\n// When we don't want to update an operation, we create and return a clone of it.\n// Returns the operation in \"unified format\" - wrapped in an Array.\nfunction doNotUpdate( operation ) {\n\treturn [ operation.clone() ];\n}\n\n// Takes an Array of operations and sets consecutive base versions for them, starting from given base version.\n// Returns the passed array.\nfunction updateBaseVersions( baseVersion, operations ) {\n\tfor ( let i = 0; i < operations.length; i++ ) {\n\t\toperations[ i ].baseVersion = baseVersion + i + 1;\n\t}\n\n\treturn operations;\n}\n\n// Checks whether MoveOperation targetPosition is inside a node from the moved range of the other MoveOperation.\nfunction moveTargetIntoMovedRange( a, b ) {\n\treturn a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;\n}\n\n// Gets an array of Ranges and produces one Range out of it. The root of a new range will be same as\n// the root of the first range in the array. If any of given ranges has different root than the first range,\n// it will be discarded.\nfunction joinRanges( ranges ) {\n\tif ( ranges.length === 0 ) {\n\t\treturn null;\n\t} else if ( ranges.length == 1 ) {\n\t\treturn ranges[ 0 ];\n\t} else {\n\t\tranges[ 0 ].end = ranges[ ranges.length - 1 ].end;\n\n\t\treturn ranges[ 0 ];\n\t}\n}\n\n// Helper function for `MoveOperation` x `MoveOperation` transformation.\n// Convert given ranges and target position to move operations and return them.\n// Ranges and target position will be transformed on-the-fly when generating operations.\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n// Given `targetPosition` is the target position of the first range from `ranges`.\nfunction makeMoveOperationsFromRanges( ranges, targetPosition, a ) {\n\t// At this moment we have some ranges and a target position, to which those ranges should be moved.\n\t// Order in `ranges` array is the go-to order of after transformation.\n\t//\n\t// We are almost done. We have `ranges` and `targetPosition` to make operations from.\n\t// Unfortunately, those operations may affect each other. Precisely, first operation after move\n\t// may affect source range and target position of second and third operation. Same with second\n\t// operation affecting third.\n\t//\n\t// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n\tconst operations = [];\n\n\t// Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t// Create new operation out of a range and target position.\n\t\tconst op = makeMoveOperation( ranges[ i ], targetPosition, a.isSticky );\n\n\t\toperations.push( op );\n\n\t\t// Transform other ranges by the generated operation.\n\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t// All ranges in `ranges` array should be:\n\t\t\t// * non-intersecting (these are part of original operation source range), and\n\t\t\t// * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n\t\t\t//\n\t\t\t// This means that the transformation will be \"clean\" and always return one result.\n\t\t\tranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];\n\t\t}\n\n\t\ttargetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany, true, false );\n\t}\n\n\treturn operations;\n}\n\nfunction makeMoveOperation( range, targetPosition, isSticky ) {\n\t// We want to keep correct operation class.\n\tlet OperationClass;\n\n\tif ( targetPosition.root.rootName == '$graveyard' ) {\n\t\tOperationClass = RemoveOperation;\n\t} else if ( range.start.root.rootName == '$graveyard' ) {\n\t\tOperationClass = ReinsertOperation;\n\t} else {\n\t\tOperationClass = MoveOperation;\n\t}\n\n\tconst result = new OperationClass(\n\t\trange.start,\n\t\trange.end.offset - range.start.offset,\n\t\ttargetPosition,\n\t\t0 // Is corrected anyway later.\n\t);\n\n\tresult.isSticky = isSticky;\n\n\treturn result;\n}\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice';\nimport isIterateeCall from './_isIterateeCall';\nimport toInteger from './toInteger';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * Creates an array of elements split into groups the length of `size`.\n * If `array` can't be split evenly, the final chunk will be the remaining\n * elements.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to process.\n * @param {number} [size=1] The length of each chunk\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the new array of chunks.\n * @example\n *\n * _.chunk(['a', 'b', 'c', 'd'], 2);\n * // => [['a', 'b'], ['c', 'd']]\n *\n * _.chunk(['a', 'b', 'c', 'd'], 3);\n * // => [['a', 'b', 'c'], ['d']]\n */\nfunction chunk(array, size, guard) {\n  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n    size = 1;\n  } else {\n    size = nativeMax(toInteger(size), 0);\n  }\n  var length = array ? array.length : 0;\n  if (!length || size < 1) {\n    return [];\n  }\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length / size));\n\n  while (index < length) {\n    result[resIndex++] = baseSlice(array, index, (index += size));\n  }\n  return result;\n}\n\nexport default chunk;\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array ? array.length : 0,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default compact;\n","import isArguments from './isArguments';\nimport isArray from './isArray';\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value);\n}\n\nexport default isFlattenable;\n","import arrayPush from './_arrayPush';\nimport isFlattenable from './_isFlattenable';\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n","import arrayPush from './_arrayPush';\nimport baseFlatten from './_baseFlatten';\nimport copyArray from './_copyArray';\nimport isArray from './isArray';\n\n/**\n * Creates a new array concatenating `array` with any additional arrays\n * and/or values.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to concatenate.\n * @param {...*} [values] The values to concatenate.\n * @returns {Array} Returns the new concatenated array.\n * @example\n *\n * var array = [1];\n * var other = _.concat(array, 2, [3], [[4]]);\n *\n * console.log(other);\n * // => [1, 2, 3, [4]]\n *\n * console.log(array);\n * // => [1]\n */\nfunction concat() {\n  var length = arguments.length,\n      args = Array(length ? length - 1 : 0),\n      array = arguments[0],\n      index = length;\n\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n  return length\n    ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))\n    : [];\n}\n\nexport default concat;\n","/**\n * Gets the index at which the first occurrence of `NaN` is found in `array`.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n */\nfunction indexOfNaN(array, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 0 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    var other = array[index];\n    if (other !== other) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default indexOfNaN;\n","import indexOfNaN from './_indexOfNaN';\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return indexOfNaN(array, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default baseIndexOf;\n","import baseIndexOf from './_baseIndexOf';\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  return !!array.length && baseIndexOf(array, value, 0) > -1;\n}\n\nexport default arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default arrayIncludesWith;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","/**\n * The base implementation of `_.unary` without support for storing wrapper metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nexport default baseUnary;\n","/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nexport default cacheHas;\n","import SetCache from './_SetCache';\nimport arrayIncludes from './_arrayIncludes';\nimport arrayIncludesWith from './_arrayIncludesWith';\nimport arrayMap from './_arrayMap';\nimport baseUnary from './_baseUnary';\nimport cacheHas from './_cacheHas';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseDifference;\n","import baseDifference from './_baseDifference';\nimport baseFlatten from './_baseFlatten';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport rest from './rest';\n\n/**\n * Creates an array of unique `array` values not included in the other given\n * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons. The order of result values is determined by the\n * order they occur in the first array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([3, 2, 1], [4, 2]);\n * // => [3, 1]\n */\nvar difference = rest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nexport default difference;\n","import Stack from './_Stack';\nimport baseIsEqual from './_baseIsEqual';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport default baseIsMatch;\n","import isObject from './isObject';\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nexport default isStrictComparable;\n","import arrayMap from './_arrayMap';\n\n/**\n * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n * of key-value pairs for `object` corresponding to the property names of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the key-value pairs.\n */\nfunction baseToPairs(object, props) {\n  return arrayMap(props, function(key) {\n    return [key, object[key]];\n  });\n}\n\nexport default baseToPairs;\n","/**\n * Converts `set` to its value-value pairs.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the value-value pairs.\n */\nfunction setToPairs(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = [value, value];\n  });\n  return result;\n}\n\nexport default setToPairs;\n","import baseToPairs from './_baseToPairs';\nimport getTag from './_getTag';\nimport mapToArray from './_mapToArray';\nimport setToPairs from './_setToPairs';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Creates a `_.toPairs` or `_.toPairsIn` function.\n *\n * @private\n * @param {Function} keysFunc The function to get the keys of a given object.\n * @returns {Function} Returns the new pairs function.\n */\nfunction createToPairs(keysFunc) {\n  return function(object) {\n    var tag = getTag(object);\n    if (tag == mapTag) {\n      return mapToArray(object);\n    }\n    if (tag == setTag) {\n      return setToPairs(object);\n    }\n    return baseToPairs(object, keysFunc(object));\n  };\n}\n\nexport default createToPairs;\n","import createToPairs from './_createToPairs';\nimport keys from './keys';\n\n/**\n * Creates an array of own enumerable string keyed-value pairs for `object`\n * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n * entries are returned.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias entries\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the key-value pairs.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.toPairs(new Foo);\n * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n */\nvar toPairs = createToPairs(keys);\n\nexport default toPairs;\n","import isStrictComparable from './_isStrictComparable';\nimport toPairs from './toPairs';\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = toPairs(object),\n      length = result.length;\n\n  while (length--) {\n    result[length][2] = isStrictComparable(result[length][1]);\n  }\n  return result;\n}\n\nexport default getMatchData;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nexport default matchesStrictComparable;\n","import baseIsMatch from './_baseIsMatch';\nimport getMatchData from './_getMatchData';\nimport matchesStrictComparable from './_matchesStrictComparable';\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nexport default baseMatches;\n","import MapCache from './_MapCache';\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import Symbol from './_Symbol';\nimport isSymbol from './isSymbol';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import memoize from './memoize';\nimport toString from './toString';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  var result = [];\n  toString(string).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n","import isArray from './isArray';\nimport stringToPath from './_stringToPath';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\nexport default castPath;\n","import isArray from './isArray';\nimport isSymbol from './isSymbol';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n","import isSymbol from './isSymbol';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n","import castPath from './_castPath';\nimport isKey from './_isKey';\nimport toKey from './_toKey';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n","import baseGet from './_baseGet';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is used in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return key in Object(object);\n}\n\nexport default baseHasIn;\n","import castPath from './_castPath';\nimport isArguments from './isArguments';\nimport isArray from './isArray';\nimport isIndex from './_isIndex';\nimport isKey from './_isKey';\nimport isLength from './isLength';\nimport isString from './isString';\nimport toKey from './_toKey';\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isString(object) || isArguments(object));\n}\n\nexport default hasPath;\n","import baseHasIn from './_baseHasIn';\nimport hasPath from './_hasPath';\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nexport default hasIn;\n","import baseIsEqual from './_baseIsEqual';\nimport get from './get';\nimport hasIn from './hasIn';\nimport isKey from './_isKey';\nimport isStrictComparable from './_isStrictComparable';\nimport matchesStrictComparable from './_matchesStrictComparable';\nimport toKey from './_toKey';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\nexport default baseMatchesProperty;\n","/**\n * This method returns the first argument given to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nexport default identity;\n","import baseGet from './_baseGet';\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nexport default basePropertyDeep;\n","import baseProperty from './_baseProperty';\nimport basePropertyDeep from './_basePropertyDeep';\nimport isKey from './_isKey';\nimport toKey from './_toKey';\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nexport default property;\n","import baseMatches from './_baseMatches';\nimport baseMatchesProperty from './_baseMatchesProperty';\nimport identity from './identity';\nimport isArray from './isArray';\nimport property from './property';\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nexport default baseIteratee;\n","import baseDifference from './_baseDifference';\nimport baseFlatten from './_baseFlatten';\nimport baseIteratee from './_baseIteratee';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.difference` except that it accepts `iteratee` which\n * is invoked for each element of `array` and `values` to generate the criterion\n * by which they're compared. Result values are chosen from the first array.\n * The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);\n * // => [3.1, 1.3]\n *\n * // The `_.property` iteratee shorthand.\n * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n * // => [{ 'x': 2 }]\n */\nvar differenceBy = rest(function(array, values) {\n  var iteratee = last(values);\n  if (isArrayLikeObject(iteratee)) {\n    iteratee = undefined;\n  }\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))\n    : [];\n});\n\nexport default differenceBy;\n","import baseDifference from './_baseDifference';\nimport baseFlatten from './_baseFlatten';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.difference` except that it accepts `comparator`\n * which is invoked to compare elements of `array` to `values`. Result values\n * are chosen from the first array. The comparator is invoked with two arguments:\n * (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n *\n * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n * // => [{ 'x': 2, 'y': 1 }]\n */\nvar differenceWith = rest(function(array, values) {\n  var comparator = last(values);\n  if (isArrayLikeObject(comparator)) {\n    comparator = undefined;\n  }\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n    : [];\n});\n\nexport default differenceWith;\n","import baseSlice from './_baseSlice';\nimport toInteger from './toInteger';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default drop;\n","import baseSlice from './_baseSlice';\nimport toInteger from './toInteger';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default dropRight;\n","import baseSlice from './_baseSlice';\n\n/**\n * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n * without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to query.\n * @param {Function} predicate The function invoked per iteration.\n * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseWhile(array, predicate, isDrop, fromRight) {\n  var length = array.length,\n      index = fromRight ? length : -1;\n\n  while ((fromRight ? index-- : ++index < length) &&\n    predicate(array[index], index, array)) {}\n\n  return isDrop\n    ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n    : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n}\n\nexport default baseWhile;\n","import baseIteratee from './_baseIteratee';\nimport baseWhile from './_baseWhile';\n\n/**\n * Creates a slice of `array` excluding elements dropped from the end.\n * Elements are dropped until `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index, array).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.dropRightWhile(users, function(o) { return !o.active; });\n * // => objects for ['barney']\n *\n * // The `_.matches` iteratee shorthand.\n * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n * // => objects for ['barney', 'fred']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.dropRightWhile(users, ['active', false]);\n * // => objects for ['barney']\n *\n * // The `_.property` iteratee shorthand.\n * _.dropRightWhile(users, 'active');\n * // => objects for ['barney', 'fred', 'pebbles']\n */\nfunction dropRightWhile(array, predicate) {\n  return (array && array.length)\n    ? baseWhile(array, baseIteratee(predicate, 3), true, true)\n    : [];\n}\n\nexport default dropRightWhile;\n","import baseIteratee from './_baseIteratee';\nimport baseWhile from './_baseWhile';\n\n/**\n * Creates a slice of `array` excluding elements dropped from the beginning.\n * Elements are dropped until `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index, array).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.dropWhile(users, function(o) { return !o.active; });\n * // => objects for ['pebbles']\n *\n * // The `_.matches` iteratee shorthand.\n * _.dropWhile(users, { 'user': 'barney', 'active': false });\n * // => objects for ['fred', 'pebbles']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.dropWhile(users, ['active', false]);\n * // => objects for ['pebbles']\n *\n * // The `_.property` iteratee shorthand.\n * _.dropWhile(users, 'active');\n * // => objects for ['barney', 'fred', 'pebbles']\n */\nfunction dropWhile(array, predicate) {\n  return (array && array.length)\n    ? baseWhile(array, baseIteratee(predicate, 3), true)\n    : [];\n}\n\nexport default dropWhile;\n","/**\n * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nexport default baseClamp;\n","import baseClamp from './_baseClamp';\nimport toInteger from './toInteger';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295;\n\n/**\n * Converts `value` to an integer suitable for use as the length of an\n * array-like object.\n *\n * **Note:** This method is based on\n * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toLength(3.2);\n * // => 3\n *\n * _.toLength(Number.MIN_VALUE);\n * // => 0\n *\n * _.toLength(Infinity);\n * // => 4294967295\n *\n * _.toLength('3.2');\n * // => 3\n */\nfunction toLength(value) {\n  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n}\n\nexport default toLength;\n","import toInteger from './toInteger';\nimport toLength from './toLength';\n\n/**\n * The base implementation of `_.fill` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n */\nfunction baseFill(array, value, start, end) {\n  var length = array.length;\n\n  start = toInteger(start);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : toInteger(end);\n  if (end < 0) {\n    end += length;\n  }\n  end = start > end ? 0 : toLength(end);\n  while (start < end) {\n    array[start++] = value;\n  }\n  return array;\n}\n\nexport default baseFill;\n","import baseFill from './_baseFill';\nimport isIterateeCall from './_isIterateeCall';\n\n/**\n * Fills elements of `array` with `value` from `start` up to, but not\n * including, `end`.\n *\n * **Note:** This method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 3.2.0\n * @category Array\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3];\n *\n * _.fill(array, 'a');\n * console.log(array);\n * // => ['a', 'a', 'a']\n *\n * _.fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * _.fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n */\nfunction fill(array, value, start, end) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n    start = 0;\n    end = length;\n  }\n  return baseFill(array, value, start, end);\n}\n\nexport default fill;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromRight) {\n  var length = array.length,\n      index = fromRight ? length : -1;\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default baseFindIndex;\n","import baseFindIndex from './_baseFindIndex';\nimport baseIteratee from './_baseIteratee';\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate) {\n  return (array && array.length)\n    ? baseFindIndex(array, baseIteratee(predicate, 3))\n    : -1;\n}\n\nexport default findIndex;\n","import baseFindIndex from './_baseFindIndex';\nimport baseIteratee from './_baseIteratee';\n\n/**\n * This method is like `_.findIndex` except that it iterates over elements\n * of `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n * // => 2\n *\n * // The `_.matches` iteratee shorthand.\n * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n * // => 0\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findLastIndex(users, ['active', false]);\n * // => 2\n *\n * // The `_.property` iteratee shorthand.\n * _.findLastIndex(users, 'active');\n * // => 0\n */\nfunction findLastIndex(array, predicate) {\n  return (array && array.length)\n    ? baseFindIndex(array, baseIteratee(predicate, 3), true)\n    : -1;\n}\n\nexport default findLastIndex;\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nexport default head;\n","import baseFlatten from './_baseFlatten';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array ? array.length : 0;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","import baseFlatten from './_baseFlatten';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Recursively flattens `array`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flattenDeep([1, [2, [3, [4]], 5]]);\n * // => [1, 2, 3, 4, 5]\n */\nfunction flattenDeep(array) {\n  var length = array ? array.length : 0;\n  return length ? baseFlatten(array, INFINITY) : [];\n}\n\nexport default flattenDeep;\n","import baseFlatten from './_baseFlatten';\nimport toInteger from './toInteger';\n\n/**\n * Recursively flatten `array` up to `depth` times.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @param {number} [depth=1] The maximum recursion depth.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * var array = [1, [2, [3, [4]], 5]];\n *\n * _.flattenDepth(array, 1);\n * // => [1, 2, [3, [4]], 5]\n *\n * _.flattenDepth(array, 2);\n * // => [1, 2, 3, [4], 5]\n */\nfunction flattenDepth(array, depth) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : toInteger(depth);\n  return baseFlatten(array, depth);\n}\n\nexport default flattenDepth;\n","/**\n * The inverse of `_.toPairs`; this method returns an object composed\n * from key-value `pairs`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} pairs The key-value pairs.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.fromPairs([['fred', 30], ['barney', 40]]);\n * // => { 'fred': 30, 'barney': 40 }\n */\nfunction fromPairs(pairs) {\n  var index = -1,\n      length = pairs ? pairs.length : 0,\n      result = {};\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\nexport default fromPairs;\n","import baseIndexOf from './_baseIndexOf';\nimport toInteger from './toInteger';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return -1;\n  }\n  fromIndex = toInteger(fromIndex);\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return baseIndexOf(array, value, fromIndex);\n}\n\nexport default indexOf;\n","import dropRight from './dropRight';\n\n/**\n * Gets all but the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.initial([1, 2, 3]);\n * // => [1, 2]\n */\nfunction initial(array) {\n  return dropRight(array, 1);\n}\n\nexport default initial;\n","import SetCache from './_SetCache';\nimport arrayIncludes from './_arrayIncludes';\nimport arrayIncludesWith from './_arrayIncludesWith';\nimport arrayMap from './_arrayMap';\nimport baseUnary from './_baseUnary';\nimport cacheHas from './_cacheHas';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * The base implementation of methods like `_.intersection`, without support\n * for iteratee shorthands, that accepts an array of arrays to inspect.\n *\n * @private\n * @param {Array} arrays The arrays to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of shared values.\n */\nfunction baseIntersection(arrays, iteratee, comparator) {\n  var includes = comparator ? arrayIncludesWith : arrayIncludes,\n      length = arrays[0].length,\n      othLength = arrays.length,\n      othIndex = othLength,\n      caches = Array(othLength),\n      maxLength = Infinity,\n      result = [];\n\n  while (othIndex--) {\n    var array = arrays[othIndex];\n    if (othIndex && iteratee) {\n      array = arrayMap(array, baseUnary(iteratee));\n    }\n    maxLength = nativeMin(array.length, maxLength);\n    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n      ? new SetCache(othIndex && array)\n      : undefined;\n  }\n  array = arrays[0];\n\n  var index = -1,\n      seen = caches[0];\n\n  outer:\n  while (++index < length && result.length < maxLength) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (!(seen\n          ? cacheHas(seen, computed)\n          : includes(result, computed, comparator)\n        )) {\n      othIndex = othLength;\n      while (--othIndex) {\n        var cache = caches[othIndex];\n        if (!(cache\n              ? cacheHas(cache, computed)\n              : includes(arrays[othIndex], computed, comparator))\n            ) {\n          continue outer;\n        }\n      }\n      if (seen) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseIntersection;\n","import isArrayLikeObject from './isArrayLikeObject';\n\n/**\n * Casts `value` to an empty array if it's not an array like object.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array|Object} Returns the cast array-like object.\n */\nfunction castArrayLikeObject(value) {\n  return isArrayLikeObject(value) ? value : [];\n}\n\nexport default castArrayLikeObject;\n","import arrayMap from './_arrayMap';\nimport baseIntersection from './_baseIntersection';\nimport castArrayLikeObject from './_castArrayLikeObject';\nimport rest from './rest';\n\n/**\n * Creates an array of unique values that are included in all given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons. The order of result values is determined by the\n * order they occur in the first array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersection([2, 1], [4, 2], [1, 2]);\n * // => [2]\n */\nvar intersection = rest(function(arrays) {\n  var mapped = arrayMap(arrays, castArrayLikeObject);\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped)\n    : [];\n});\n\nexport default intersection;\n","import arrayMap from './_arrayMap';\nimport baseIntersection from './_baseIntersection';\nimport baseIteratee from './_baseIteratee';\nimport castArrayLikeObject from './_castArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.intersection` except that it accepts `iteratee`\n * which is invoked for each element of each `arrays` to generate the criterion\n * by which they're compared. Result values are chosen from the first array.\n * The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n * // => [2.1]\n *\n * // The `_.property` iteratee shorthand.\n * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }]\n */\nvar intersectionBy = rest(function(arrays) {\n  var iteratee = last(arrays),\n      mapped = arrayMap(arrays, castArrayLikeObject);\n\n  if (iteratee === last(mapped)) {\n    iteratee = undefined;\n  } else {\n    mapped.pop();\n  }\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped, baseIteratee(iteratee))\n    : [];\n});\n\nexport default intersectionBy;\n","import arrayMap from './_arrayMap';\nimport baseIntersection from './_baseIntersection';\nimport castArrayLikeObject from './_castArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.intersection` except that it accepts `comparator`\n * which is invoked to compare elements of `arrays`. Result values are chosen\n * from the first array. The comparator is invoked with two arguments:\n * (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n *\n * _.intersectionWith(objects, others, _.isEqual);\n * // => [{ 'x': 1, 'y': 2 }]\n */\nvar intersectionWith = rest(function(arrays) {\n  var comparator = last(arrays),\n      mapped = arrayMap(arrays, castArrayLikeObject);\n\n  if (comparator === last(mapped)) {\n    comparator = undefined;\n  } else {\n    mapped.pop();\n  }\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped, undefined, comparator)\n    : [];\n});\n\nexport default intersectionWith;\n","/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeJoin = arrayProto.join;\n\n/**\n * Converts all elements in `array` into a string separated by `separator`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to convert.\n * @param {string} [separator=','] The element separator.\n * @returns {string} Returns the joined string.\n * @example\n *\n * _.join(['a', 'b', 'c'], '~');\n * // => 'a~b~c'\n */\nfunction join(array, separator) {\n  return array ? nativeJoin.call(array, separator) : '';\n}\n\nexport default join;\n","import indexOfNaN from './_indexOfNaN';\nimport toInteger from './toInteger';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * This method is like `_.indexOf` except that it iterates over elements of\n * `array` from right to left.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=array.length-1] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.lastIndexOf([1, 2, 1, 2], 2);\n * // => 3\n *\n * // Search from the `fromIndex`.\n * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n * // => 1\n */\nfunction lastIndexOf(array, value, fromIndex) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return -1;\n  }\n  var index = length;\n  if (fromIndex !== undefined) {\n    index = toInteger(fromIndex);\n    index = (\n      index < 0\n        ? nativeMax(length + index, 0)\n        : nativeMin(index, length - 1)\n    ) + 1;\n  }\n  if (value !== value) {\n    return indexOfNaN(array, index, true);\n  }\n  while (index--) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default lastIndexOf;\n","import isIndex from './_isIndex';\n\n/**\n * The base implementation of `_.nth` which doesn't coerce `n` to an integer.\n *\n * @private\n * @param {Array} array The array to query.\n * @param {number} n The index of the element to return.\n * @returns {*} Returns the nth element of `array`.\n */\nfunction baseNth(array, n) {\n  var length = array.length;\n  if (!length) {\n    return;\n  }\n  n += n < 0 ? length : 0;\n  return isIndex(n, length) ? array[n] : undefined;\n}\n\nexport default baseNth;\n","import baseNth from './_baseNth';\nimport toInteger from './toInteger';\n\n/**\n * Gets the element at `n` index of `array`. If `n` is negative, the nth\n * element from the end is returned.\n *\n * @static\n * @memberOf _\n * @since 4.11.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=0] The index of the element to return.\n * @returns {*} Returns the nth element of `array`.\n * @example\n *\n * var array = ['a', 'b', 'c', 'd'];\n *\n * _.nth(array, 1);\n * // => 'b'\n *\n * _.nth(array, -2);\n * // => 'c';\n */\nfunction nth(array, n) {\n  return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n}\n\nexport default nth;\n","/**\n * This function is like `baseIndexOf` except that it accepts a comparator.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOfWith(array, value, fromIndex, comparator) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (comparator(array[index], value)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default baseIndexOfWith;\n","import arrayMap from './_arrayMap';\nimport baseIndexOf from './_baseIndexOf';\nimport baseIndexOfWith from './_baseIndexOfWith';\nimport baseUnary from './_baseUnary';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * The base implementation of `_.pullAllBy` without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns `array`.\n */\nfunction basePullAll(array, values, iteratee, comparator) {\n  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n      index = -1,\n      length = values.length,\n      seen = array;\n\n  if (iteratee) {\n    seen = arrayMap(array, baseUnary(iteratee));\n  }\n  while (++index < length) {\n    var fromIndex = 0,\n        value = values[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n      if (seen !== array) {\n        splice.call(seen, fromIndex, 1);\n      }\n      splice.call(array, fromIndex, 1);\n    }\n  }\n  return array;\n}\n\nexport default basePullAll;\n","import basePullAll from './_basePullAll';\n\n/**\n * This method is like `_.pull` except that it accepts an array of values to remove.\n *\n * **Note:** Unlike `_.difference`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * _.pullAll(array, [2, 3]);\n * console.log(array);\n * // => [1, 1]\n */\nfunction pullAll(array, values) {\n  return (array && array.length && values && values.length)\n    ? basePullAll(array, values)\n    : array;\n}\n\nexport default pullAll;\n","import pullAll from './pullAll';\nimport rest from './rest';\n\n/**\n * Removes all given values from `array` using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n * to remove elements from an array by predicate.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {...*} [values] The values to remove.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * _.pull(array, 2, 3);\n * console.log(array);\n * // => [1, 1]\n */\nvar pull = rest(pullAll);\n\nexport default pull;\n","import baseIteratee from './_baseIteratee';\nimport basePullAll from './_basePullAll';\n\n/**\n * This method is like `_.pullAll` except that it accepts `iteratee` which is\n * invoked for each element of `array` and `values` to generate the criterion\n * by which they're compared. The iteratee is invoked with one argument: (value).\n *\n * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n *\n * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n * console.log(array);\n * // => [{ 'x': 2 }]\n */\nfunction pullAllBy(array, values, iteratee) {\n  return (array && array.length && values && values.length)\n    ? basePullAll(array, values, baseIteratee(iteratee))\n    : array;\n}\n\nexport default pullAllBy;\n","import basePullAll from './_basePullAll';\n\n/**\n * This method is like `_.pullAll` except that it accepts `comparator` which\n * is invoked to compare elements of `array` to `values`. The comparator is\n * invoked with two arguments: (arrVal, othVal).\n *\n * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 4.6.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Array} values The values to remove.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n *\n * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n * console.log(array);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n */\nfunction pullAllWith(array, values, comparator) {\n  return (array && array.length && values && values.length)\n    ? basePullAll(array, values, undefined, comparator)\n    : array;\n}\n\nexport default pullAllWith;\n","import get from './get';\n\n/**\n * The base implementation of `_.at` without support for individual paths.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {string[]} paths The property paths of elements to pick.\n * @returns {Array} Returns the picked elements.\n */\nfunction baseAt(object, paths) {\n  var index = -1,\n      isNil = object == null,\n      length = paths.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = isNil ? undefined : get(object, paths[index]);\n  }\n  return result;\n}\n\nexport default baseAt;\n","import baseGet from './_baseGet';\nimport baseSlice from './_baseSlice';\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nexport default parent;\n","import castPath from './_castPath';\nimport isIndex from './_isIndex';\nimport isKey from './_isKey';\nimport last from './last';\nimport parent from './_parent';\nimport toKey from './_toKey';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * The base implementation of `_.pullAt` without support for individual\n * indexes or capturing the removed elements.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {number[]} indexes The indexes of elements to remove.\n * @returns {Array} Returns `array`.\n */\nfunction basePullAt(array, indexes) {\n  var length = array ? indexes.length : 0,\n      lastIndex = length - 1;\n\n  while (length--) {\n    var index = indexes[length];\n    if (length == lastIndex || index !== previous) {\n      var previous = index;\n      if (isIndex(index)) {\n        splice.call(array, index, 1);\n      }\n      else if (!isKey(index, array)) {\n        var path = castPath(index),\n            object = parent(array, path);\n\n        if (object != null) {\n          delete object[toKey(last(path))];\n        }\n      }\n      else {\n        delete array[toKey(index)];\n      }\n    }\n  }\n  return array;\n}\n\nexport default basePullAt;\n","import isSymbol from './isSymbol';\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nexport default compareAscending;\n","import arrayMap from './_arrayMap';\nimport baseAt from './_baseAt';\nimport baseFlatten from './_baseFlatten';\nimport basePullAt from './_basePullAt';\nimport compareAscending from './_compareAscending';\nimport isIndex from './_isIndex';\nimport rest from './rest';\n\n/**\n * Removes elements from `array` corresponding to `indexes` and returns an\n * array of removed elements.\n *\n * **Note:** Unlike `_.at`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n * @returns {Array} Returns the new array of removed elements.\n * @example\n *\n * var array = [5, 10, 15, 20];\n * var evens = _.pullAt(array, 1, 3);\n *\n * console.log(array);\n * // => [5, 15]\n *\n * console.log(evens);\n * // => [10, 20]\n */\nvar pullAt = rest(function(array, indexes) {\n  indexes = baseFlatten(indexes, 1);\n\n  var length = array ? array.length : 0,\n      result = baseAt(array, indexes);\n\n  basePullAt(array, arrayMap(indexes, function(index) {\n    return isIndex(index, length) ? +index : index;\n  }).sort(compareAscending));\n\n  return result;\n});\n\nexport default pullAt;\n","import baseIteratee from './_baseIteratee';\nimport basePullAt from './_basePullAt';\n\n/**\n * Removes all elements from `array` that `predicate` returns truthy for\n * and returns an array of the removed elements. The predicate is invoked\n * with three arguments: (value, index, array).\n *\n * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n * to pull elements from an array by value.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {Array} Returns the new array of removed elements.\n * @example\n *\n * var array = [1, 2, 3, 4];\n * var evens = _.remove(array, function(n) {\n *   return n % 2 == 0;\n * });\n *\n * console.log(array);\n * // => [1, 3]\n *\n * console.log(evens);\n * // => [2, 4]\n */\nfunction remove(array, predicate) {\n  var result = [];\n  if (!(array && array.length)) {\n    return result;\n  }\n  var index = -1,\n      indexes = [],\n      length = array.length;\n\n  predicate = baseIteratee(predicate, 3);\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result.push(value);\n      indexes.push(index);\n    }\n  }\n  basePullAt(array, indexes);\n  return result;\n}\n\nexport default remove;\n","/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeReverse = arrayProto.reverse;\n\n/**\n * Reverses `array` so that the first element becomes the last, the second\n * element becomes the second to last, and so on.\n *\n * **Note:** This method mutates `array` and is based on\n * [`Array#reverse`](https://mdn.io/Array/reverse).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3];\n *\n * _.reverse(array);\n * // => [3, 2, 1]\n *\n * console.log(array);\n * // => [3, 2, 1]\n */\nfunction reverse(array) {\n  return array ? nativeReverse.call(array) : array;\n}\n\nexport default reverse;\n","import baseSlice from './_baseSlice';\nimport isIterateeCall from './_isIterateeCall';\nimport toInteger from './toInteger';\n\n/**\n * Creates a slice of `array` from `start` up to, but not including, `end`.\n *\n * **Note:** This method is used instead of\n * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n * returned.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction slice(array, start, end) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n    start = 0;\n    end = length;\n  }\n  else {\n    start = start == null ? 0 : toInteger(start);\n    end = end === undefined ? length : toInteger(end);\n  }\n  return baseSlice(array, start, end);\n}\n\nexport default slice;\n","import isSymbol from './isSymbol';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsSymbol = isSymbol(value),\n      valIsUndefined = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        othIsDefined = computed !== undefined,\n        othIsNull = computed === null,\n        othIsReflexive = computed === computed,\n        othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nexport default baseSortedIndexBy;\n","import baseSortedIndexBy from './_baseSortedIndexBy';\nimport identity from './identity';\nimport isSymbol from './isSymbol';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n * performs a binary search of `array` to determine the index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndex(array, value, retHighest) {\n  var low = 0,\n      high = array ? array.length : low;\n\n  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n    while (low < high) {\n      var mid = (low + high) >>> 1,\n          computed = array[mid];\n\n      if (computed !== null && !isSymbol(computed) &&\n          (retHighest ? (computed <= value) : (computed < value))) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n  return baseSortedIndexBy(array, value, identity, retHighest);\n}\n\nexport default baseSortedIndex;\n","import baseSortedIndex from './_baseSortedIndex';\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * _.sortedIndex([30, 50], 40);\n * // => 1\n *\n * _.sortedIndex([4, 5], 4);\n * // => 0\n */\nfunction sortedIndex(array, value) {\n  return baseSortedIndex(array, value);\n}\n\nexport default sortedIndex;\n","import baseIteratee from './_baseIteratee';\nimport baseSortedIndexBy from './_baseSortedIndexBy';\n\n/**\n * This method is like `_.sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n *\n * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n * // => 1\n *\n * // The `_.property` iteratee shorthand.\n * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n * // => 0\n */\nfunction sortedIndexBy(array, value, iteratee) {\n  return baseSortedIndexBy(array, value, baseIteratee(iteratee));\n}\n\nexport default sortedIndexBy;\n","import baseSortedIndex from './_baseSortedIndex';\nimport eq from './eq';\n\n/**\n * This method is like `_.indexOf` except that it performs a binary\n * search on a sorted `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.sortedIndexOf([1, 1, 2, 2], 2);\n * // => 2\n */\nfunction sortedIndexOf(array, value) {\n  var length = array ? array.length : 0;\n  if (length) {\n    var index = baseSortedIndex(array, value);\n    if (index < length && eq(array[index], value)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default sortedIndexOf;\n","import baseSortedIndex from './_baseSortedIndex';\n\n/**\n * This method is like `_.sortedIndex` except that it returns the highest\n * index at which `value` should be inserted into `array` in order to\n * maintain its sort order.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * _.sortedLastIndex([4, 5], 4);\n * // => 1\n */\nfunction sortedLastIndex(array, value) {\n  return baseSortedIndex(array, value, true);\n}\n\nexport default sortedLastIndex;\n","import baseIteratee from './_baseIteratee';\nimport baseSortedIndexBy from './_baseSortedIndexBy';\n\n/**\n * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * // The `_.property` iteratee shorthand.\n * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n * // => 1\n */\nfunction sortedLastIndexBy(array, value, iteratee) {\n  return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);\n}\n\nexport default sortedLastIndexBy;\n","import baseSortedIndex from './_baseSortedIndex';\nimport eq from './eq';\n\n/**\n * This method is like `_.lastIndexOf` except that it performs a binary\n * search on a sorted `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.sortedLastIndexOf([1, 1, 2, 2], 2);\n * // => 3\n */\nfunction sortedLastIndexOf(array, value) {\n  var length = array ? array.length : 0;\n  if (length) {\n    var index = baseSortedIndex(array, value, true) - 1;\n    if (eq(array[index], value)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default sortedLastIndexOf;\n","import eq from './eq';\n\n/**\n * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseSortedUniq(array, iteratee) {\n  var index = -1,\n      length = array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    if (!index || !eq(computed, seen)) {\n      var seen = computed;\n      result[resIndex++] = value === 0 ? 0 : value;\n    }\n  }\n  return result;\n}\n\nexport default baseSortedUniq;\n","import baseSortedUniq from './_baseSortedUniq';\n\n/**\n * This method is like `_.uniq` except that it's designed and optimized\n * for sorted arrays.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.sortedUniq([1, 1, 2]);\n * // => [1, 2]\n */\nfunction sortedUniq(array) {\n  return (array && array.length)\n    ? baseSortedUniq(array)\n    : [];\n}\n\nexport default sortedUniq;\n","import baseIteratee from './_baseIteratee';\nimport baseSortedUniq from './_baseSortedUniq';\n\n/**\n * This method is like `_.uniqBy` except that it's designed and optimized\n * for sorted arrays.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n * // => [1.1, 2.3]\n */\nfunction sortedUniqBy(array, iteratee) {\n  return (array && array.length)\n    ? baseSortedUniq(array, baseIteratee(iteratee))\n    : [];\n}\n\nexport default sortedUniqBy;\n","import drop from './drop';\n\n/**\n * Gets all but the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.tail([1, 2, 3]);\n * // => [2, 3]\n */\nfunction tail(array) {\n  return drop(array, 1);\n}\n\nexport default tail;\n","import baseSlice from './_baseSlice';\nimport toInteger from './toInteger';\n\n/**\n * Creates a slice of `array` with `n` elements taken from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to take.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.take([1, 2, 3]);\n * // => [1]\n *\n * _.take([1, 2, 3], 2);\n * // => [1, 2]\n *\n * _.take([1, 2, 3], 5);\n * // => [1, 2, 3]\n *\n * _.take([1, 2, 3], 0);\n * // => []\n */\nfunction take(array, n, guard) {\n  if (!(array && array.length)) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default take;\n","import baseSlice from './_baseSlice';\nimport toInteger from './toInteger';\n\n/**\n * Creates a slice of `array` with `n` elements taken from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to take.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.takeRight([1, 2, 3]);\n * // => [3]\n *\n * _.takeRight([1, 2, 3], 2);\n * // => [2, 3]\n *\n * _.takeRight([1, 2, 3], 5);\n * // => [1, 2, 3]\n *\n * _.takeRight([1, 2, 3], 0);\n * // => []\n */\nfunction takeRight(array, n, guard) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default takeRight;\n","import baseIteratee from './_baseIteratee';\nimport baseWhile from './_baseWhile';\n\n/**\n * Creates a slice of `array` with elements taken from the end. Elements are\n * taken until `predicate` returns falsey. The predicate is invoked with\n * three arguments: (value, index, array).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.takeRightWhile(users, function(o) { return !o.active; });\n * // => objects for ['fred', 'pebbles']\n *\n * // The `_.matches` iteratee shorthand.\n * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n * // => objects for ['pebbles']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.takeRightWhile(users, ['active', false]);\n * // => objects for ['fred', 'pebbles']\n *\n * // The `_.property` iteratee shorthand.\n * _.takeRightWhile(users, 'active');\n * // => []\n */\nfunction takeRightWhile(array, predicate) {\n  return (array && array.length)\n    ? baseWhile(array, baseIteratee(predicate, 3), false, true)\n    : [];\n}\n\nexport default takeRightWhile;\n","import baseIteratee from './_baseIteratee';\nimport baseWhile from './_baseWhile';\n\n/**\n * Creates a slice of `array` with elements taken from the beginning. Elements\n * are taken until `predicate` returns falsey. The predicate is invoked with\n * three arguments: (value, index, array).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {Array|Function|Object|string} [predicate=_.identity]\n *  The function invoked per iteration.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false},\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.takeWhile(users, function(o) { return !o.active; });\n * // => objects for ['barney', 'fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.takeWhile(users, { 'user': 'barney', 'active': false });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.takeWhile(users, ['active', false]);\n * // => objects for ['barney', 'fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.takeWhile(users, 'active');\n * // => []\n */\nfunction takeWhile(array, predicate) {\n  return (array && array.length)\n    ? baseWhile(array, baseIteratee(predicate, 3))\n    : [];\n}\n\nexport default takeWhile;\n","/**\n * A no-operation function that returns `undefined` regardless of the\n * arguments it receives.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.noop(object) === undefined;\n * // => true\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n","import Set from './_Set';\nimport noop from './noop';\nimport setToArray from './_setToArray';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nexport default createSet;\n","import SetCache from './_SetCache';\nimport arrayIncludes from './_arrayIncludes';\nimport arrayIncludesWith from './_arrayIncludesWith';\nimport cacheHas from './_cacheHas';\nimport createSet from './_createSet';\nimport setToArray from './_setToArray';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseUniq;\n","import baseFlatten from './_baseFlatten';\nimport baseUniq from './_baseUniq';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport rest from './rest';\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2, 1], [4, 2], [1, 2]);\n * // => [2, 1, 4]\n */\nvar union = rest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nexport default union;\n","import baseFlatten from './_baseFlatten';\nimport baseIteratee from './_baseIteratee';\nimport baseUniq from './_baseUniq';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by\n * which uniqueness is computed. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n * // => [2.1, 1.2, 4.3]\n *\n * // The `_.property` iteratee shorthand.\n * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nvar unionBy = rest(function(arrays) {\n  var iteratee = last(arrays);\n  if (isArrayLikeObject(iteratee)) {\n    iteratee = undefined;\n  }\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));\n});\n\nexport default unionBy;\n","import baseFlatten from './_baseFlatten';\nimport baseUniq from './_baseUniq';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.union` except that it accepts `comparator` which\n * is invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n *\n * _.unionWith(objects, others, _.isEqual);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n */\nvar unionWith = rest(function(arrays) {\n  var comparator = last(arrays);\n  if (isArrayLikeObject(comparator)) {\n    comparator = undefined;\n  }\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n});\n\nexport default unionWith;\n","import baseUniq from './_baseUniq';\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each\n * element is kept.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length)\n    ? baseUniq(array)\n    : [];\n}\n\nexport default uniq;\n","import baseIteratee from './_baseIteratee';\nimport baseUniq from './_baseUniq';\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length)\n    ? baseUniq(array, baseIteratee(iteratee))\n    : [];\n}\n\nexport default uniqBy;\n","import baseUniq from './_baseUniq';\n\n/**\n * This method is like `_.uniq` except that it accepts `comparator` which\n * is invoked to compare elements of `array`. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\n *\n * _.uniqWith(objects, _.isEqual);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n */\nfunction uniqWith(array, comparator) {\n  return (array && array.length)\n    ? baseUniq(array, undefined, comparator)\n    : [];\n}\n\nexport default uniqWith;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default arrayFilter;\n","import arrayFilter from './_arrayFilter';\nimport arrayMap from './_arrayMap';\nimport baseProperty from './_baseProperty';\nimport baseTimes from './_baseTimes';\nimport isArrayLikeObject from './isArrayLikeObject';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.zip` except that it accepts an array of grouped\n * elements and creates an array regrouping the elements to their pre-zip\n * configuration.\n *\n * @static\n * @memberOf _\n * @since 1.2.0\n * @category Array\n * @param {Array} array The array of grouped elements to process.\n * @returns {Array} Returns the new array of regrouped elements.\n * @example\n *\n * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n * // => [['fred', 30, true], ['barney', 40, false]]\n *\n * _.unzip(zipped);\n * // => [['fred', 'barney'], [30, 40], [true, false]]\n */\nfunction unzip(array) {\n  if (!(array && array.length)) {\n    return [];\n  }\n  var length = 0;\n  array = arrayFilter(array, function(group) {\n    if (isArrayLikeObject(group)) {\n      length = nativeMax(group.length, length);\n      return true;\n    }\n  });\n  return baseTimes(length, function(index) {\n    return arrayMap(array, baseProperty(index));\n  });\n}\n\nexport default unzip;\n","import apply from './_apply';\nimport arrayMap from './_arrayMap';\nimport unzip from './unzip';\n\n/**\n * This method is like `_.unzip` except that it accepts `iteratee` to specify\n * how regrouped values should be combined. The iteratee is invoked with the\n * elements of each group: (...group).\n *\n * @static\n * @memberOf _\n * @since 3.8.0\n * @category Array\n * @param {Array} array The array of grouped elements to process.\n * @param {Function} [iteratee=_.identity] The function to combine\n *  regrouped values.\n * @returns {Array} Returns the new array of regrouped elements.\n * @example\n *\n * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n * // => [[1, 10, 100], [2, 20, 200]]\n *\n * _.unzipWith(zipped, _.add);\n * // => [3, 30, 300]\n */\nfunction unzipWith(array, iteratee) {\n  if (!(array && array.length)) {\n    return [];\n  }\n  var result = unzip(array);\n  if (iteratee == null) {\n    return result;\n  }\n  return arrayMap(result, function(group) {\n    return apply(iteratee, undefined, group);\n  });\n}\n\nexport default unzipWith;\n","import baseDifference from './_baseDifference';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport rest from './rest';\n\n/**\n * Creates an array excluding all given values using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...*} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.difference, _.xor\n * @example\n *\n * _.without([1, 2, 1, 3], 1, 2);\n * // => [3]\n */\nvar without = rest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, values)\n    : [];\n});\n\nexport default without;\n","import arrayPush from './_arrayPush';\nimport baseDifference from './_baseDifference';\nimport baseUniq from './_baseUniq';\n\n/**\n * The base implementation of methods like `_.xor`, without support for\n * iteratee shorthands, that accepts an array of arrays to inspect.\n *\n * @private\n * @param {Array} arrays The arrays to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of values.\n */\nfunction baseXor(arrays, iteratee, comparator) {\n  var index = -1,\n      length = arrays.length;\n\n  while (++index < length) {\n    var result = result\n      ? arrayPush(\n          baseDifference(result, arrays[index], iteratee, comparator),\n          baseDifference(arrays[index], result, iteratee, comparator)\n        )\n      : arrays[index];\n  }\n  return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];\n}\n\nexport default baseXor;\n","import arrayFilter from './_arrayFilter';\nimport baseXor from './_baseXor';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport rest from './rest';\n\n/**\n * Creates an array of unique values that is the\n * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n * of the given arrays. The order of result values is determined by the order\n * they occur in the arrays.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.difference, _.without\n * @example\n *\n * _.xor([2, 1], [4, 2]);\n * // => [1, 4]\n */\nvar xor = rest(function(arrays) {\n  return baseXor(arrayFilter(arrays, isArrayLikeObject));\n});\n\nexport default xor;\n","import arrayFilter from './_arrayFilter';\nimport baseIteratee from './_baseIteratee';\nimport baseXor from './_baseXor';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.xor` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by\n * which by which they're compared. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Array|Function|Object|string} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n * // => [1.2, 4.3]\n *\n * // The `_.property` iteratee shorthand.\n * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 2 }]\n */\nvar xorBy = rest(function(arrays) {\n  var iteratee = last(arrays);\n  if (isArrayLikeObject(iteratee)) {\n    iteratee = undefined;\n  }\n  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));\n});\n\nexport default xorBy;\n","import arrayFilter from './_arrayFilter';\nimport baseXor from './_baseXor';\nimport isArrayLikeObject from './isArrayLikeObject';\nimport last from './last';\nimport rest from './rest';\n\n/**\n * This method is like `_.xor` except that it accepts `comparator` which is\n * invoked to compare elements of `arrays`. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n *\n * _.xorWith(objects, others, _.isEqual);\n * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n */\nvar xorWith = rest(function(arrays) {\n  var comparator = last(arrays);\n  if (isArrayLikeObject(comparator)) {\n    comparator = undefined;\n  }\n  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n});\n\nexport default xorWith;\n","import rest from './rest';\nimport unzip from './unzip';\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to process.\n * @returns {Array} Returns the new array of grouped elements.\n * @example\n *\n * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n * // => [['fred', 30, true], ['barney', 40, false]]\n */\nvar zip = rest(unzip);\n\nexport default zip;\n","/**\n * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n *\n * @private\n * @param {Array} props The property identifiers.\n * @param {Array} values The property values.\n * @param {Function} assignFunc The function to assign values.\n * @returns {Object} Returns the new object.\n */\nfunction baseZipObject(props, values, assignFunc) {\n  var index = -1,\n      length = props.length,\n      valsLength = values.length,\n      result = {};\n\n  while (++index < length) {\n    var value = index < valsLength ? values[index] : undefined;\n    assignFunc(result, props[index], value);\n  }\n  return result;\n}\n\nexport default baseZipObject;\n","import assignValue from './_assignValue';\nimport baseZipObject from './_baseZipObject';\n\n/**\n * This method is like `_.fromPairs` except that it accepts two arrays,\n * one of property identifiers and one of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 0.4.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction zipObject(props, values) {\n  return baseZipObject(props || [], values || [], assignValue);\n}\n\nexport default zipObject;\n","import assignValue from './_assignValue';\nimport castPath from './_castPath';\nimport isIndex from './_isIndex';\nimport isKey from './_isKey';\nimport isObject from './isObject';\nimport toKey from './_toKey';\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]);\n    if (isObject(nested)) {\n      var newValue = value;\n      if (index != lastIndex) {\n        var objValue = nested[key];\n        newValue = customizer ? customizer(objValue, key, nested) : undefined;\n        if (newValue === undefined) {\n          newValue = objValue == null\n            ? (isIndex(path[index + 1]) ? [] : {})\n            : objValue;\n        }\n      }\n      assignValue(nested, key, newValue);\n    }\n    nested = nested[key];\n  }\n  return object;\n}\n\nexport default baseSet;\n","import baseSet from './_baseSet';\nimport baseZipObject from './_baseZipObject';\n\n/**\n * This method is like `_.zipObject` except that it supports property paths.\n *\n * @static\n * @memberOf _\n * @since 4.1.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n */\nfunction zipObjectDeep(props, values) {\n  return baseZipObject(props || [], values || [], baseSet);\n}\n\nexport default zipObjectDeep;\n","import rest from './rest';\nimport unzipWith from './unzipWith';\n\n/**\n * This method is like `_.zip` except that it accepts `iteratee` to specify\n * how grouped values should be combined. The iteratee is invoked with the\n * elements of each group: (...group).\n *\n * @static\n * @memberOf _\n * @since 3.8.0\n * @category Array\n * @param {...Array} [arrays] The arrays to process.\n * @param {Function} [iteratee=_.identity] The function to combine grouped values.\n * @returns {Array} Returns the new array of grouped elements.\n * @example\n *\n * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n *   return a + b + c;\n * });\n * // => [111, 222]\n */\nvar zipWith = rest(function(arrays) {\n  var length = arrays.length,\n      iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n  return unzipWith(arrays, iteratee);\n});\n\nexport default zipWith;\n","import chunk from './chunk';\nimport compact from './compact';\nimport concat from './concat';\nimport difference from './difference';\nimport differenceBy from './differenceBy';\nimport differenceWith from './differenceWith';\nimport drop from './drop';\nimport dropRight from './dropRight';\nimport dropRightWhile from './dropRightWhile';\nimport dropWhile from './dropWhile';\nimport fill from './fill';\nimport findIndex from './findIndex';\nimport findLastIndex from './findLastIndex';\nimport first from './first';\nimport flatten from './flatten';\nimport flattenDeep from './flattenDeep';\nimport flattenDepth from './flattenDepth';\nimport fromPairs from './fromPairs';\nimport head from './head';\nimport indexOf from './indexOf';\nimport initial from './initial';\nimport intersection from './intersection';\nimport intersectionBy from './intersectionBy';\nimport intersectionWith from './intersectionWith';\nimport join from './join';\nimport last from './last';\nimport lastIndexOf from './lastIndexOf';\nimport nth from './nth';\nimport pull from './pull';\nimport pullAll from './pullAll';\nimport pullAllBy from './pullAllBy';\nimport pullAllWith from './pullAllWith';\nimport pullAt from './pullAt';\nimport remove from './remove';\nimport reverse from './reverse';\nimport slice from './slice';\nimport sortedIndex from './sortedIndex';\nimport sortedIndexBy from './sortedIndexBy';\nimport sortedIndexOf from './sortedIndexOf';\nimport sortedLastIndex from './sortedLastIndex';\nimport sortedLastIndexBy from './sortedLastIndexBy';\nimport sortedLastIndexOf from './sortedLastIndexOf';\nimport sortedUniq from './sortedUniq';\nimport sortedUniqBy from './sortedUniqBy';\nimport tail from './tail';\nimport take from './take';\nimport takeRight from './takeRight';\nimport takeRightWhile from './takeRightWhile';\nimport takeWhile from './takeWhile';\nimport union from './union';\nimport unionBy from './unionBy';\nimport unionWith from './unionWith';\nimport uniq from './uniq';\nimport uniqBy from './uniqBy';\nimport uniqWith from './uniqWith';\nimport unzip from './unzip';\nimport unzipWith from './unzipWith';\nimport without from './without';\nimport xor from './xor';\nimport xorBy from './xorBy';\nimport xorWith from './xorWith';\nimport zip from './zip';\nimport zipObject from './zipObject';\nimport zipObjectDeep from './zipObjectDeep';\nimport zipWith from './zipWith';\n\nexport default {\n  chunk, compact, concat, difference, differenceBy,\n  differenceWith, drop, dropRight, dropRightWhile, dropWhile,\n  fill, findIndex, findLastIndex, first, flatten,\n  flattenDeep, flattenDepth, fromPairs, head, indexOf,\n  initial, intersection, intersectionBy, intersectionWith, join,\n  last, lastIndexOf, nth, pull, pullAll,\n  pullAllBy, pullAllWith, pullAt, remove, reverse,\n  slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex,\n  sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail,\n  take, takeRight, takeRightWhile, takeWhile, union,\n  unionBy, unionWith, uniq, uniqBy, uniqWith,\n  unzip, unzipWith, without, xor, xorBy,\n  xorWith, zip, zipObject, zipObjectDeep, zipWith\n};\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @protected\n * @module engine/model/delta/transform\n */\n\nimport Delta from './delta';\nimport MoveDelta from './movedelta';\nimport RemoveDelta from './removedelta';\nimport MergeDelta from './mergedelta';\nimport SplitDelta from './splitdelta';\nimport WrapDelta from './wrapdelta';\nimport UnwrapDelta from './unwrapdelta';\nimport RenameDelta from './renamedelta';\nimport AttributeDelta from './attributedelta';\nimport operationTransform from '../operation/transform';\nimport NoOperation from '../operation/nooperation';\nimport MoveOperation from '../operation/moveoperation';\nimport RemoveOperation from '../operation/removeoperation';\nimport arrayUtils from '@ckeditor/ckeditor5-utils/src/lib/lodash/array';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\nconst specialCases = new Map();\n\n/**\n * @namespace\n */\nconst transform = {\n\t/**\n\t * Transforms given {@link module:engine/model/delta/delta~Delta delta} by another {@link module:engine/model/delta/delta~Delta delta}\n\t * and returns the result of that transformation as an array containing one or more {@link module:engine/model/delta/delta~Delta delta}\n\t * instances.\n\t *\n\t * Delta transformations heavily base on {@link module:engine/model/operation/transform~transform operational transformations}. Since\n\t * delta is a list of operations most situations can be handled thanks to operational transformation. Unfortunately,\n\t * deltas are more complicated than operations and have they semantic meaning, as they represent user's editing intentions.\n\t *\n\t * Sometimes, simple operational transformation on deltas' operations might result in some unexpected results. Those\n\t * results would be fine from OT point of view, but would not reflect user's intentions. Because of such conflicts\n\t * we need to handle transformations in special cases in a custom way.\n\t *\n\t * The function itself looks whether two given delta types have a special case function registered. If so, the deltas are\n\t * transformed using that function. If not,\n\t * {@link module:engine/model/delta/transform~transform.defaultTransform default transformation algorithm} is used.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} a Delta that will be transformed.\n\t * @param {module:engine/model/delta/delta~Delta} b Delta to transform by.\n\t * @param {module:engine/model/delta/transform~transformationContext} context Transformation context object.\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} Result of the transformation.\n\t */\n\ttransform( a, b, context ) {\n\t\tconst transformAlgorithm = transform.getTransformationCase( a, b ) || transform.defaultTransform;\n\n\t\t// Make new instance of context object, so all changes done during transformation are not saved in original object.\n\t\tconst transformed = transformAlgorithm( a, b, Object.assign( {}, context ) );\n\t\tconst baseVersion = arrayUtils.last( b.operations ).baseVersion;\n\n\t\treturn updateBaseVersion( baseVersion, transformed );\n\t},\n\n\t/**\n\t * The default delta transformation function. It is used for those deltas that are not in special case conflict.\n\t *\n\t * This algorithm is similar to a popular `dOPT` algorithm used in operational transformation, as we are in fact\n\t * transforming two sets of operations by each other.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} a Delta that will be transformed.\n\t * @param {module:engine/model/delta/delta~Delta} b Delta to transform by.\n\t * @param {module:engine/model/delta/transform~transformationContext} context Transformation context object.\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} Result of the transformation.\n\t */\n\tdefaultTransform( a, b, context ) {\n\t\t// This will hold operations from delta `a` that will be transformed by operations from delta `b`.\n\t\t// Eventually, those operations will be used to create result delta(s).\n\t\tconst transformed = [];\n\n\t\t// Array containing operations that we will transform by. At the beginning these are just operations from\n\t\tlet byOps = b.operations;\n\n\t\t// This array is storing operations from `byOps` which got transformed by operation from delta `a`.\n\t\tlet newByOps = [];\n\n\t\t// We take each operation from original set of operations to transform.\n\t\tfor ( const opA of a.operations ) {\n\t\t\t// We wrap the operation in the array. This is important, because operation transformation algorithm returns\n\t\t\t// an array of operations so we need to make sure that our algorithm is ready to handle arrays.\n\t\t\tconst ops = [ opA ];\n\n\t\t\t// Now the real algorithm takes place.\n\t\t\tfor ( const opB of byOps ) {\n\t\t\t\t// For each operation that we need transform by...\n\t\t\t\tfor ( let i = 0; i < ops.length; i++ ) {\n\t\t\t\t\t// We take each operation to transform...\n\t\t\t\t\tconst op = ops[ i ];\n\n\t\t\t\t\t// And transform both of them by themselves.\n\n\t\t\t\t\t// The result of transforming operation from delta B by operation from delta A is saved in\n\t\t\t\t\t// `newByOps` array. We will use that array for transformations in next loops. We need delta B\n\t\t\t\t\t// operations after transformed by delta A operations to get correct results of transformations\n\t\t\t\t\t// of next operations from delta A.\n\t\t\t\t\t//\n\t\t\t\t\t// It's like this because 2nd operation from delta A assumes that 1st operation from delta A\n\t\t\t\t\t// is \"already applied\". When we transform 2nd operation from delta A by operations from delta B\n\t\t\t\t\t// we have to be sure that operations from delta B are in a state that acknowledges 1st operation\n\t\t\t\t\t// from delta A.\n\t\t\t\t\t//\n\t\t\t\t\t// This can be easier understood when operations sets to transform are represented by diamond diagrams:\n\t\t\t\t\t// http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation\n\n\t\t\t\t\t// Transform operation from delta A by operation from delta B.\n\t\t\t\t\tconst results = operationTransform( op, opB, context );\n\n\t\t\t\t\t// We replace currently processed operation from `ops` array by the results of transformation.\n\t\t\t\t\t// Note, that we process single operation but `operationTransform` result is an array, so we\n\t\t\t\t\t// might have to splice-in more than one operation. Save them in `ops` array and move `i` pointer by a proper offset.\n\t\t\t\t\tArray.prototype.splice.apply( ops, [ i, 1 ].concat( results ) );\n\n\t\t\t\t\ti += results.length - 1;\n\n\t\t\t\t\t// Then, transform operation from delta B by operation from delta A.\n\t\t\t\t\t// Since this is a \"mirror\" transformation, first, we \"mirror\" some of context values.\n\t\t\t\t\tconst reverseContext = Object.assign( {}, context );\n\t\t\t\t\treverseContext.isStrong = !context.isStrong;\n\t\t\t\t\treverseContext.insertBefore = context.insertBefore !== undefined ? !context.insertBefore : undefined;\n\n\t\t\t\t\t// Transform operations.\n\t\t\t\t\tconst updatedOpB = operationTransform( opB, op, reverseContext );\n\n\t\t\t\t\t// Update `newByOps` by transformed, updated `opB`.\n\t\t\t\t\t// Using push.apply because `operationTransform` returns an array with one or multiple results.\n\t\t\t\t\tArray.prototype.push.apply( newByOps, updatedOpB );\n\t\t\t\t}\n\n\t\t\t\t// At this point a single operation from delta A got transformed by a single operation from delta B.\n\t\t\t\t// The transformation result is in `ops` array and it may be one or more operations. This was just the first step.\n\t\t\t\t// Operation from delta A has to be further transformed by the other operations from delta B.\n\t\t\t\t// So in next iterator loop we will take another operation from delta B and use transformed delta A (`ops`)\n\t\t\t\t// to transform it further.\n\t\t\t}\n\n\t\t\t// We got through all delta B operations and have a final transformed state of an operation from delta A.\n\n\t\t\t// As previously mentioned, we substitute operations from delta B by their transformed equivalents.\n\t\t\tbyOps = newByOps;\n\t\t\tnewByOps = [];\n\n\t\t\t// We add transformed operation from delta A to newly created delta.\n\t\t\t// Remember that transformed operation from delta A may consist of multiple operations.\n\t\t\tfor ( const op of ops ) {\n\t\t\t\ttransformed.push( op );\n\t\t\t}\n\n\t\t\t// In next loop, we will take another operation from delta A and transform it through (transformed) operations\n\t\t\t// from delta B...\n\t\t}\n\n\t\treturn getNormalizedDeltas( a.constructor, transformed );\n\t},\n\n\t/**\n\t * Adds a special case callback for given delta classes.\n\t *\n\t * @param {Function} A Delta constructor which instance will get transformed.\n\t * @param {Function} B Delta constructor which instance will be transformed by.\n\t * @param {Function} resolver A callback that will handle custom special case transformation for instances of given delta classes.\n\t */\n\taddTransformationCase( A, B, resolver ) {\n\t\tlet casesA = specialCases.get( A );\n\n\t\tif ( !casesA ) {\n\t\t\tcasesA = new Map();\n\t\t\tspecialCases.set( A, casesA );\n\t\t}\n\n\t\tcasesA.set( B, resolver );\n\t},\n\n\t/**\n\t * Gets a special case callback which was previously {@link module:engine/model/delta/transform~transform.addTransformationCase added}.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} a Delta to transform.\n\t * @param {module:engine/model/delta/delta~Delta} b Delta to be transformed by.\n\t */\n\tgetTransformationCase( a, b ) {\n\t\tlet casesA = specialCases.get( a.constructor );\n\n\t\t// If there are no special cases registered for class which `a` is instance of, we will\n\t\t// check if there are special cases registered for any parent class.\n\t\tif ( !casesA || !casesA.get( b.constructor ) ) {\n\t\t\tconst cases = specialCases.keys();\n\n\t\t\tfor ( const caseClass of cases ) {\n\t\t\t\tif ( a instanceof caseClass && specialCases.get( caseClass ).get( b.constructor ) ) {\n\t\t\t\t\tcasesA = specialCases.get( caseClass );\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( casesA ) {\n\t\t\treturn casesA.get( b.constructor );\n\t\t}\n\n\t\treturn undefined;\n\t},\n\n\t/**\n\t * Transforms two sets of deltas by themselves. Returns both transformed sets.\n\t *\n\t * @param {Array.<module:engine/model/delta/delta~Delta>} deltasA Array with the first set of deltas to transform. These\n\t * deltas are considered more important (than `deltasB`) when resolving conflicts.\n\t * @param {Array.<module:engine/model/delta/delta~Delta>} deltasB Array with the second set of deltas to transform. These\n\t * deltas are considered less important (than `deltasA`) when resolving conflicts.\n\t * @param {module:engine/model/document~Document} [document=null] If set, deltas will be transformed in \"undo mode\"\n\t * and given `document` will be used to determine relations between deltas. If not set (default), deltas will be\n\t * transforming without additional context information.\n\t * @returns {Object}\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasA The first set of deltas transformed\n\t * by the second set of deltas.\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasB The second set of deltas transformed\n\t * by the first set of deltas.\n\t */\n\ttransformDeltaSets( deltasA, deltasB, document = null ) {\n\t\tconst transformedDeltasA = Array.from( deltasA );\n\t\tconst transformedDeltasB = Array.from( deltasB );\n\n\t\tconst useAdditionalContext = document !== null;\n\n\t\tconst contextAB = {\n\t\t\tisStrong: true\n\t\t};\n\n\t\tif ( useAdditionalContext ) {\n\t\t\tcontextAB.wasAffected = new Map();\n\t\t\tcontextAB.originalDelta = new Map();\n\t\t\tcontextAB.document = document;\n\t\t\tcontextAB.undoMode = true;\n\n\t\t\tfor ( const delta of transformedDeltasB ) {\n\t\t\t\tcontextAB.originalDelta.set( delta, delta );\n\t\t\t}\n\t\t}\n\n\t\tfor ( let i = 0; i < transformedDeltasA.length; i++ ) {\n\t\t\tconst deltaA = [ transformedDeltasA[ i ] ];\n\n\t\t\tfor ( let j = 0; j < transformedDeltasB.length; j++ ) {\n\t\t\t\tconst deltaB = [ transformedDeltasB[ j ] ];\n\n\t\t\t\tfor ( let k = 0; k < deltaA.length; k++ ) {\n\t\t\t\t\tfor ( let l = 0; l < deltaB.length; l++ ) {\n\t\t\t\t\t\tif ( useAdditionalContext ) {\n\t\t\t\t\t\t\t_setContext( deltaA[ k ], deltaB[ l ], contextAB );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst resultAB = transform.transform( deltaA[ k ], deltaB[ l ], {\n\t\t\t\t\t\t\tinsertBefore: contextAB.insertBefore,\n\t\t\t\t\t\t\tforceNotSticky: contextAB.forceNotSticky,\n\t\t\t\t\t\t\tisStrong: contextAB.isStrong,\n\t\t\t\t\t\t\tforceWeakRemove: contextAB.forceWeakRemove,\n\t\t\t\t\t\t\tundoMode: contextAB.undoMode\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst resultBA = transform.transform( deltaB[ l ], deltaA[ k ], {\n\t\t\t\t\t\t\tinsertBefore: !contextAB.insertBefore,\n\t\t\t\t\t\t\tforceNotSticky: contextAB.forceNotSticky,\n\t\t\t\t\t\t\tisStrong: !contextAB.isStrong,\n\t\t\t\t\t\t\tforceWeakRemove: contextAB.forceWeakRemove,\n\t\t\t\t\t\t\tundoMode: contextAB.undoMode\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( useAdditionalContext ) {\n\t\t\t\t\t\t\t_updateContext( deltaA[ k ], resultAB, contextAB );\n\n\t\t\t\t\t\t\tconst originalDelta = contextAB.originalDelta.get( deltaB[ l ] );\n\n\t\t\t\t\t\t\tfor ( const deltaBA of resultBA ) {\n\t\t\t\t\t\t\t\tcontextAB.originalDelta.set( deltaBA, originalDelta );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdeltaA.splice( k, 1, ...resultAB );\n\t\t\t\t\t\tk += resultAB.length - 1;\n\n\t\t\t\t\t\tdeltaB.splice( l, 1, ...resultBA );\n\t\t\t\t\t\tl += resultBA.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttransformedDeltasB.splice( j, 1, ...deltaB );\n\t\t\t\tj += deltaB.length - 1;\n\t\t\t}\n\n\t\t\ttransformedDeltasA.splice( i, 1, ...deltaA );\n\t\t\ti += deltaA.length - 1;\n\t\t}\n\n\t\tconst opsDiffA = getOpsCount( transformedDeltasA ) - getOpsCount( deltasA );\n\t\tconst opsDiffB = getOpsCount( transformedDeltasB ) - getOpsCount( deltasB );\n\n\t\tif ( opsDiffB < opsDiffA ) {\n\t\t\tpadWithNoOps( transformedDeltasB, opsDiffA - opsDiffB );\n\t\t} else if ( opsDiffA < opsDiffB ) {\n\t\t\tpadWithNoOps( transformedDeltasA, opsDiffB - opsDiffA );\n\t\t}\n\n\t\treturn { deltasA: transformedDeltasA, deltasB: transformedDeltasB };\n\t}\n};\n\nexport default transform;\n\n// Updates base versions of operations inside deltas (which are the results of delta transformation).\nfunction updateBaseVersion( baseVersion, deltas ) {\n\tfor ( const delta of deltas ) {\n\t\tfor ( const op of delta.operations ) {\n\t\t\top.baseVersion = ++baseVersion;\n\t\t}\n\t}\n\n\treturn deltas;\n}\n\n// Returns number of operations in given array of deltas.\nfunction getOpsCount( deltas ) {\n\treturn deltas.reduce( ( current, delta ) => {\n\t\treturn current + delta.operations.length;\n\t}, 0 );\n}\n\n// Adds a delta containing `howMany` `NoOperation` instances to given array with deltas.\n// Used to \"synchronize\" the number of operations in two delta sets.\nfunction padWithNoOps( deltas, howMany ) {\n\tconst lastDelta = deltas[ deltas.length - 1 ];\n\tlet baseVersion = lastDelta.operations.length + lastDelta.baseVersion;\n\n\tconst noDelta = new Delta();\n\n\tfor ( let i = 0; i < howMany; i++ ) {\n\t\tnoDelta.addOperation( new NoOperation( baseVersion++ ) );\n\t}\n\n\tdeltas.push( noDelta );\n}\n\n// Sets context data before delta `a` by delta `b` transformation.\n// Using data given in `context` object, sets `context.insertBefore` and `context.forceNotSticky` flags.\n// Also updates `context.wasAffected`.\nfunction _setContext( a, b, context ) {\n\t_setWasAffected( a, b, context );\n\t_setInsertBeforeContext( a, b, context );\n\t_setForceWeakRemove( b, context );\n\t_setForceNotSticky( b, context );\n}\n\n// Sets `context.insertBefore` basing on `context.document` history for `a` by `b` transformation.\n//\n// Simply saying, if `b` is \"undoing delta\" it means that `a` might already be transformed by the delta\n// which was undone by `b` (let's call it `oldB`). If this is true, `a` by `b` transformation has to consider\n// how `a` was transformed by `oldB` to get an expected result.\n//\n// This is used to resolve conflict when two operations want to insert nodes at the same position. If the operations\n// are not related, it doesn't matter in what order operations insert those nodes. However if the operations are\n// related (for example, in undo) we need to keep the same order.\n//\n// For example, assume that editor has two letters: 'ab'. Then, both letters are removed, creating two operations:\n// (op. 1) REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ]\n// (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ]\n// Then, we undo operation 2:\n// REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ] is reversed to REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ] and is applied.\n// History stack is:\n// (op. 1) REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ]\n// (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ]\n// (op. 3) REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ]\n// Then, we undo operation 1:\n// REM [ 1 ] - [ 2 ] => (graveyard) [ 0 ] is reversed to REI (graveyard) [ 0 ] => [ 1 ] - [ 2 ] then,\n// is transformed by (op. 2) REM [ 0 ] - [ 1 ] => (graveyard) [ 1 ] and becomes REI (graveyard) [ 0 ] => [ 0 ] - [ 1 ] then,\n// is transformed by (op. 3) REI (graveyard) [ 1 ] => [ 0 ] - [ 1 ] and we have a conflict because both operations\n// insert at the same position, but thanks to keeping the context, we know that in this case, the transformed operation should\n// insert the node after operation 3.\n//\n// Keep in mind, that `context.insertBefore` may be either `Boolean` or `undefined`. If it is `Boolean` then the order is\n// known (deltas are related and `a` should insert nodes before or after `b`). However, if deltas were not related,\n// `context.isBefore` is `undefined` and other factors will be taken into consideration when resolving the order\n// (this, however, happens in operational transformation algorithms).\n//\n// This affects both `MoveOperation` (and its derivatives) and `InsertOperation`.\nfunction _setInsertBeforeContext( a, b, context ) {\n\t// If `b` is a delta that undoes other delta...\n\tconst originalDelta = context.originalDelta.get( b );\n\n\tif ( context.document.history.isUndoingDelta( originalDelta ) ) {\n\t\t// Get the undone delta...\n\t\tconst undoneDelta = context.document.history.getUndoneDelta( originalDelta );\n\t\t// Get a map with deltas related to `a` delta...\n\t\tconst aWasAffectedBy = context.wasAffected.get( a );\n\t\t// And check if the undone delta is related with delta `a`.\n\t\tconst affected = aWasAffectedBy.get( undoneDelta );\n\n\t\tif ( affected !== undefined ) {\n\t\t\t// If deltas are related, set `context.insertBefore` basing on whether `a` was affected by the undone delta.\n\t\t\tcontext.insertBefore = affected;\n\t\t}\n\t}\n}\n\n// Sets `context.forceNotSticky` basing on `context.document` history for transformation by `b` delta.\n//\n// `MoveOperation` may be \"sticky\" which means, that anything that was inserted at the boundary of moved range, should\n// also be moved. This is particularly helpful for actions like splitting or merging a node. However, this behavior\n// sometimes leads to an error, for example in undo.\n//\n// Simply saying, if delta is going to be transformed by delta `b`, stickiness should not be taken into consideration\n// if delta `b` was already undone or if delta `b` is an undoing delta.\n//\n// This affects `MoveOperation` (and its derivatives).\nfunction _setForceNotSticky( b, context ) {\n\tconst originalDelta = context.originalDelta.get( b );\n\tconst history = context.document.history;\n\n\tcontext.forceNotSticky = history.isUndoneDelta( originalDelta ) || history.isUndoingDelta( originalDelta );\n}\n\n// Sets `context.forceWeakRemove` basing on `context.document` history for transformation by `b` delta.\n//\n// When additional context is not used, default `MoveOperation` x `RemoveOperation` transformation\n// always treats `RemoveOperation` as a stronger one, no matter how `context.isStrong` is set. It is like this\n// to provide better results when transformations happen.\n//\n// This, however, works fine only when additional context is not used.\n//\n// When additional context is used, we need a better way to decide whether `RemoveOperation` is \"dominating\" (or in other\n// words, whether nodes removed by given operation should stay in graveyard if other operation wants to move them).\n//\n// The answer to this is easy: if `RemoveOperation` has been already undone, we are not forcing given nodes to stay\n// in graveyard. In such scenario, we set `context.forceWeakRemove` to `true`. However, if the `RemoveOperation` has\n// not been undone, we set `context.forceWeakRemove` to `false` because we want the operation to be \"dominating\".\nfunction _setForceWeakRemove( b, context ) {\n\tconst history = context.document.history;\n\tconst originalB = context.originalDelta.get( b );\n\n\t// If `b` delta has not been undone yet, forceWeakRemove should be `false`.\n\t// It should be `true`, in any other case, if additional context is used.\n\tcontext.forceWeakRemove = history.isUndoneDelta( originalB );\n}\n\n// Sets `context.wasAffected` which holds context information about how transformed deltas are related. `context.wasAffected`\n// is used by `_setInsertBeforeContext` helper function.\nfunction _setWasAffected( a, b, context ) {\n\tif ( !context.wasAffected.get( a ) ) {\n\t\t// Create a new map with relations for `a` delta.\n\t\tcontext.wasAffected.set( a, new Map() );\n\t}\n\n\tconst originalDelta = context.originalDelta.get( b );\n\tlet wasAffected = !!context.wasAffected.get( a ).get( originalDelta );\n\n\t// Cross-check all operations from both deltas...\n\tfor ( const opA of a.operations ) {\n\t\tfor ( const opB of b.operations ) {\n\t\t\tif ( opA instanceof MoveOperation && opB instanceof MoveOperation ) {\n\t\t\t\tif ( _isOperationAffected( opA, opB ) ) {\n\t\t\t\t\t// If any of them are move operations that affect each other, set the relation accordingly.\n\t\t\t\t\twasAffected = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Break both loops if affecting pair has been found.\n\t\tif ( wasAffected ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcontext.wasAffected.get( a ).set( originalDelta, wasAffected );\n}\n\n// Checks whether `opA` is affected by `opB`. It is assumed that both operations are `MoveOperation`.\n// Operation is affected only if the other operation's source range is before that operation's source range.\nfunction _isOperationAffected( opA, opB ) {\n\tconst target = opA.targetPosition;\n\tconst source = opB.sourcePosition;\n\n\tconst cmpResult = compareArrays( source.getParentPath(), target.getParentPath() );\n\n\tif ( target.root != source.root ) {\n\t\treturn false;\n\t}\n\n\treturn cmpResult == 'same' && source.offset < target.offset;\n}\n\n// Updates `context` object after delta by delta transformation is done.\n//\n// This means two things:\n// 1. Some information are removed from context (those that apply only to the transformation that just happened).\n// 2. `context.wasAffected` is updated because `oldDelta` has been transformed to one or many `newDeltas` and we\n// need to update entries in `context.wasAffected`. Basically, anything that was in `context.wasAffected` under\n// `oldDelta` key should be rewritten to `newDeltas`. This way in next transformation steps, `newDeltas` \"remember\"\n// the context of `oldDelta`.\nfunction _updateContext( oldDelta, newDeltas, context ) {\n\tdelete context.insertBefore;\n\tdelete context.forceNotSticky;\n\tdelete context.forceWeakRemove;\n\n\tconst wasAffected = context.wasAffected.get( oldDelta );\n\n\tcontext.wasAffected.delete( oldDelta );\n\n\tfor ( const delta of newDeltas ) {\n\t\tcontext.wasAffected.set( delta, new Map( wasAffected ) );\n\t}\n}\n\n// Takes base delta class (`DeltaClass`) and a set of `operations` that are transformation results and creates\n// one or more deltas, acknowledging that the result is a transformation of a delta that is of `DeltaClass`.\n//\n// The normalization ensures that each delta has it's \"normal\" state, that is, for example, `MoveDelta` has\n// just one `MoveOperation`, `SplitDelta` has just two operations of which first is `InsertOperation` and second\n// is `MoveOperation` or `NoOperation`, etc.\nfunction getNormalizedDeltas( DeltaClass, operations ) {\n\tlet deltas = [];\n\tlet delta = null;\n\tlet attributeOperationIndex;\n\n\tswitch ( DeltaClass ) {\n\t\tcase MoveDelta:\n\t\tcase RemoveDelta:\n\t\t\t// Normal MoveDelta has just one MoveOperation.\n\t\t\t// Take all operations and create MoveDelta for each of them.\n\t\t\tfor ( const o of operations ) {\n\t\t\t\tif ( o instanceof NoOperation ) {\n\t\t\t\t\t// An operation may be instance of NoOperation and this may be correct.\n\t\t\t\t\t// If that's the case, do not create a MoveDelta with singular NoOperation.\n\t\t\t\t\t// Create \"no delta\" instead, that is Delta instance with NoOperation.\n\t\t\t\t\tdelta = new Delta();\n\t\t\t\t} else {\n\t\t\t\t\tif ( o instanceof RemoveOperation ) {\n\t\t\t\t\t\tdelta = new RemoveDelta();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelta = new MoveDelta();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelta.addOperation( o );\n\t\t\t\tdeltas.push( delta );\n\t\t\t}\n\n\t\t\t// Return all created MoveDeltas.\n\t\t\treturn deltas;\n\t\tcase SplitDelta:\n\t\tcase WrapDelta:\n\t\t\t// Normal SplitDelta and WrapDelta have two operations: first is InsertOperation and second is MoveOperation.\n\t\t\t// The MoveOperation may be split into multiple MoveOperations.\n\t\t\t// If that's the case, convert additional MoveOperations into MoveDeltas.\n\t\t\t// First, create normal SplitDelta or WrapDelta, using first two operations.\n\t\t\tdelta = new DeltaClass();\n\t\t\tdelta.addOperation( operations[ 0 ] );\n\t\t\tdelta.addOperation( operations[ 1 ] );\n\t\t\t// Then, take all but last two operations and use them to create normalized MoveDeltas.\n\t\t\tdeltas = getNormalizedDeltas( MoveDelta, operations.slice( 2 ) );\n\n\t\t\t// Return all deltas as one array, in proper order.\n\t\t\treturn [ delta ].concat( deltas );\n\t\tcase MergeDelta:\n\t\tcase UnwrapDelta:\n\t\t\t// Normal MergeDelta and UnwrapDelta have two operations: first is MoveOperation and second is RemoveOperation.\n\t\t\t// The MoveOperation may be split into multiple MoveOperations.\n\t\t\t// If that's the case, convert additional MoveOperations into MoveDeltas.\n\t\t\t// Take all but last two operations and use them to create normalized MoveDeltas.\n\t\t\tdeltas = getNormalizedDeltas( MoveDelta, operations.slice( 0, -2 ) );\n\t\t\t// Then, create normal MergeDelta or UnwrapDelta, using last two operations.\n\t\t\tdelta = new DeltaClass();\n\t\t\tdelta.addOperation( operations[ operations.length - 2 ] );\n\t\t\tdelta.addOperation( operations[ operations.length - 1 ] );\n\n\t\t\t// Return all deltas as one array, in proper order.\n\t\t\treturn deltas.concat( delta );\n\t\tcase RenameDelta:\n\t\t\t// RenameDelta may become a \"no delta\" if it's only operation is transformed to NoOperation.\n\t\t\t// This may happen when RenameOperation is transformed by RenameOperation.\n\t\t\t// Keep in mind that RenameDelta always have just one operation.\n\t\t\tif ( operations[ 0 ] instanceof NoOperation ) {\n\t\t\t\tdelta = new Delta();\n\t\t\t} else {\n\t\t\t\tdelta = new RenameDelta();\n\t\t\t}\n\n\t\t\tdelta.addOperation( operations[ 0 ] );\n\n\t\t\treturn [ delta ];\n\t\tcase AttributeDelta:\n\t\t\t// AttributeDelta is allowed to have multiple AttributeOperations and also NoOperations but\n\t\t\t// the first operation has to be an AttributeOperation as it is used as a reference for deltas properties.\n\t\t\t// Keep in mind that we cannot simply remove NoOperations cause that would mess up base versions.\n\t\t\t// Find an index of first operation that is not a NoOperation.\n\t\t\tfor ( attributeOperationIndex = 0; attributeOperationIndex < operations.length; attributeOperationIndex++ ) {\n\t\t\t\tif ( !( operations[ attributeOperationIndex ] instanceof NoOperation ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No AttributeOperations has been found. Convert AttributeDelta to \"no delta\".\n\t\t\tif ( attributeOperationIndex == operations.length ) {\n\t\t\t\tdelta = new Delta();\n\t\t\t}\n\t\t\t// AttributeOperation found.\n\t\t\telse {\n\t\t\t\tdelta = new AttributeDelta();\n\n\t\t\t\t// AttributeOperation wasn't the first operation.\n\t\t\t\tif ( attributeOperationIndex != 0 ) {\n\t\t\t\t\t// Move AttributeOperation to the beginning.\n\t\t\t\t\toperations.unshift( operations.splice( attributeOperationIndex, 1 )[ 0 ] );\n\t\t\t\t\t// No need to update base versions - they are updated at the end of transformation algorithm anyway.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add all operations to the delta (even if it is just a couple of NoOperations we have to keep them all).\n\t\t\tfor ( const o of operations ) {\n\t\t\t\tdelta.addOperation( o );\n\t\t\t}\n\n\t\t\treturn [ delta ];\n\t\tdefault:\n\t\t\t// For all other deltas no normalization is needed.\n\t\t\tdelta = new DeltaClass();\n\n\t\t\tfor ( const o of operations ) {\n\t\t\t\tdelta.addOperation( o );\n\t\t\t}\n\n\t\t\treturn [ delta ];\n\t}\n}\n\n/**\n * Object containing values and flags describing context of a transformation.\n *\n * @typedef {Object} module:engine/model/delta/transform~transformationContext\n * @property {Boolean} useAdditionalContext Whether additional context should be evaluated and used during transformations.\n * @property {Boolean} isStrong Whether transformed deltas are more (`true`) or less (`false`) important than deltas to transform by.\n * @property {module:engine/model/document~Document} [document] Model document which is a context for transformations.\n * Available only if `useAdditionalContext` is `true`.\n * @property {Boolean|undefined} forceWeakRemove Whether {@link module:engine/model/operation/removeoperation~RemoveOperation}\n * should be always more important than other operations. Available only if `useAdditionalContext` is `true`.\n * @property {Boolean|undefined} insertBefore Used when transforming {@link module:engine/model/operation/moveoperation~MoveOperation}s\n * If two `MoveOperation`s target to the same position, `insertBefore` is used to resolve such conflict. This flag\n * is set and used internally by transformation algorithms. Available only if `useAdditionalContext` is `true`.\n * @property {Boolean|undefined} forceNotSticky Used when transforming\n * {@link module:engine/model/operation/moveoperation~MoveOperation#isSticky sticky MoveOperation}. If set to `true`,\n * `isSticky` flag is discarded during transformations. This flag is set and used internally by transformation algorithms.\n * Available only if `useAdditionalContext` is `true`.\n * @property {Map|undefined} wasAffected Used to evaluate `insertBefore` flag. This map is set and used internally by\n * transformation algorithms. Available only if `useAdditionalContext` is `true`.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/markerdelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, the {@link module:engine/model/writer~Writer#addMarker Writer#addMarker}\n * and {@link module:engine/model/writer~Writer#removeMarker Writer#removeMarker} methods use the `MarkerDelta` class which inherits\n * from the `Delta` class and may overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class MarkerDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'marker';\n\t}\n\n\t/**\n\t * A class that will be used when creating reversed delta.\n\t *\n\t * @private\n\t * @type {Function}\n\t */\n\tget _reverseDeltaClass() {\n\t\treturn MarkerDelta;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.MarkerDelta';\n\t}\n}\n\nDeltaFactory.register( MarkerDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/basic-transformations\n */\n\nimport deltaTransform from './transform';\nconst addTransformationCase = deltaTransform.addTransformationCase;\nconst defaultTransform = deltaTransform.defaultTransform;\n\nimport Range from '../range';\nimport Position from '../position';\n\nimport NoOperation from '../operation/nooperation';\nimport AttributeOperation from '../operation/attributeoperation';\nimport InsertOperation from '../operation/insertoperation';\nimport ReinsertOperation from '../operation/reinsertoperation';\n\nimport Delta from './delta';\nimport AttributeDelta from './attributedelta';\nimport InsertDelta from './insertdelta';\nimport MarkerDelta from './markerdelta';\nimport MergeDelta from './mergedelta';\nimport MoveDelta from './movedelta';\nimport SplitDelta from './splitdelta';\nimport WeakInsertDelta from './weakinsertdelta';\nimport WrapDelta from './wrapdelta';\nimport UnwrapDelta from './unwrapdelta';\nimport RenameDelta from './renamedelta';\nimport RemoveDelta from './removedelta';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n// Provide transformations for default deltas.\n\n// Add special case for AttributeDelta x WeakInsertDelta transformation.\naddTransformationCase( AttributeDelta, WeakInsertDelta, ( a, b, context ) => {\n\t// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.\n\t// So first we do the normal transformation and if this special cases happens, we will add an extra delta.\n\tconst deltas = defaultTransform( a, b, context );\n\n\tif ( a.range.containsPosition( b.position ) ) {\n\t\tdeltas.push( _getComplementaryAttrDelta( b, a ) );\n\t}\n\n\treturn deltas;\n} );\n\n// Add special case for AttributeDelta x SplitDelta transformation.\naddTransformationCase( AttributeDelta, SplitDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tconst undoMode = context.undoMode;\n\tconst splitPosition = new Position( b.position.root, b.position.path.slice( 0, -1 ) );\n\n\tconst deltas = defaultTransform( a, b, context );\n\n\t// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).\n\tif ( undoMode || !( b._cloneOperation instanceof InsertOperation ) ) {\n\t\treturn deltas;\n\t}\n\n\tfor ( const operation of a.operations ) {\n\t\t// If a node that has been split has it's attribute updated, we should also update attribute of\n\t\t// the node created during splitting.\n\t\tif ( operation.range.containsPosition( splitPosition ) || operation.range.start.isEqual( splitPosition ) ) {\n\t\t\tconst additionalAttributeDelta = new AttributeDelta();\n\n\t\t\tconst rangeStart = splitPosition.getShiftedBy( 1 );\n\t\t\tconst rangeEnd = Position.createFromPosition( rangeStart );\n\t\t\trangeEnd.path.push( 0 );\n\n\t\t\tconst oldValue = b._cloneOperation.nodes.getNode( 0 ).getAttribute( operation.key );\n\n\t\t\tadditionalAttributeDelta.addOperation( new AttributeOperation(\n\t\t\t\tnew Range( rangeStart, rangeEnd ),\n\t\t\t\toperation.key,\n\t\t\t\toldValue === undefined ? null : oldValue,\n\t\t\t\toperation.newValue,\n\t\t\t\t0\n\t\t\t) );\n\n\t\t\tdeltas.push( additionalAttributeDelta );\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn deltas;\n} );\n\n// Add special case for InsertDelta x MergeDelta transformation.\naddTransformationCase( InsertDelta, MergeDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `MergeDelta` has `NoOperation` as the second operation.\n\tif ( !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tconst undoMode = context.undoMode;\n\n\t// If insert is applied at the same position where merge happened, we reverse the merge (we treat it like it\n\t// didn't happen) and then apply the original insert operation. This is \"mirrored\" in MergeDelta x InsertDelta\n\t// transformation below, where we simply do not apply MergeDelta.\n\tif ( !undoMode && a.position.isEqual( b.position ) ) {\n\t\treturn [\n\t\t\tb.getReversed(),\n\t\t\ta.clone()\n\t\t];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\nfunction transformMarkerDelta( a, b ) {\n\tconst transformedDelta = a.clone();\n\tconst transformedOp = transformedDelta.operations[ 0 ];\n\n\tif ( transformedOp.oldRange ) {\n\t\ttransformedOp.oldRange = transformedOp.oldRange.getTransformedByDelta( b )[ 0 ];\n\t}\n\n\tif ( transformedOp.newRange ) {\n\t\ttransformedOp.newRange = transformedOp.newRange.getTransformedByDelta( b )[ 0 ];\n\t}\n\n\treturn [ transformedDelta ];\n}\n\naddTransformationCase( MarkerDelta, SplitDelta, transformMarkerDelta );\naddTransformationCase( MarkerDelta, MergeDelta, transformMarkerDelta );\naddTransformationCase( MarkerDelta, WrapDelta, transformMarkerDelta );\naddTransformationCase( MarkerDelta, UnwrapDelta, transformMarkerDelta );\naddTransformationCase( MarkerDelta, MoveDelta, transformMarkerDelta );\naddTransformationCase( MarkerDelta, RenameDelta, transformMarkerDelta );\n\n// Add special case for MoveDelta x MergeDelta transformation.\naddTransformationCase( MoveDelta, MergeDelta, ( a, b, context ) => {\n\tconst undoMode = context.undoMode;\n\n\t// Do not apply special transformation case in undo mode or if `MergeDelta` has `NoOperation` as the second operation.\n\tif ( undoMode || !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If move delta is supposed to move a node that has been merged, we reverse the merge (we treat it like it\n\t// didn't happen) and then apply the original move operation. This is \"mirrored\" in MergeDelta x MoveDelta\n\t// transformation below, where we simply do not apply MergeDelta.\n\tconst operateInSameParent =\n\t\ta.sourcePosition.root == b.position.root &&\n\t\tcompareArrays( a.sourcePosition.getParentPath(), b.position.getParentPath() ) === 'same';\n\n\tconst mergeInsideMoveRange = a.sourcePosition.offset <= b.position.offset && a.sourcePosition.offset + a.howMany > b.position.offset;\n\n\tif ( operateInSameParent && mergeInsideMoveRange ) {\n\t\treturn [\n\t\t\tb.getReversed(),\n\t\t\ta.clone()\n\t\t];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for MergeDelta x InsertDelta transformation.\naddTransformationCase( MergeDelta, InsertDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `MergeDelta` has `NoOperation` as the second operation.\n\tif ( !a.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tconst undoMode = context.undoMode;\n\n\t// If merge is applied at the same position where we inserted a range of nodes we cancel the merge as it's results\n\t// may be unexpected and very weird. Even if we do some \"magic\" we don't know what really are users' expectations.\n\tif ( !undoMode && a.position.isEqual( b.position ) ) {\n\t\treturn [ noDelta() ];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for MergeDelta x MoveDelta transformation.\naddTransformationCase( MergeDelta, MoveDelta, ( a, b, context ) => {\n\tconst undoMode = context.undoMode;\n\n\t// Do not apply special transformation case in undo mode or if `MergeDelta` has `NoOperation` as the second operation.\n\tif ( undoMode || !a.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If merge is applied at the position between moved nodes we cancel the merge as it's results may be unexpected and\n\t// very weird. Even if we do some \"magic\" we don't know what really are users' expectations.\n\tconst operateInSameParent =\n\t\ta.position.root == b.sourcePosition.root &&\n\t\tcompareArrays( a.position.getParentPath(), b.sourcePosition.getParentPath() ) === 'same';\n\n\tconst mergeInsideMoveRange = b.sourcePosition.offset <= a.position.offset && b.sourcePosition.offset + b.howMany > a.position.offset;\n\n\tif ( operateInSameParent && mergeInsideMoveRange ) {\n\t\treturn [ noDelta() ];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\naddTransformationCase( SplitDelta, SplitDelta, ( a, b, context ) => {\n\tconst undoMode = context.undoMode;\n\n\t// Do not apply special transformation case if transformation is in undo mode.\n\tif ( undoMode ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !a.position || !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tconst pathA = a.position.getParentPath();\n\tconst pathB = b.position.getParentPath();\n\n\t// The special case is for splits inside the same parent.\n\tif ( a.position.root == b.position.root && compareArrays( pathA, pathB ) == 'same' ) {\n\t\ta = a.clone();\n\n\t\tif ( a.position.offset < b.position.offset || ( a.position.offset == b.position.offset && context.isStrong ) ) {\n\t\t\t// If both first operations are `ReinsertOperation`s, we might need to transform `a._cloneOperation`,\n\t\t\t// so it will take correct node from graveyard.\n\t\t\tif (\n\t\t\t\ta._cloneOperation instanceof ReinsertOperation && b._cloneOperation instanceof ReinsertOperation &&\n\t\t\t\ta._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset\n\t\t\t) {\n\t\t\t\ta._cloneOperation.sourcePosition.offset--;\n\t\t\t}\n\n\t\t\t// `a` splits closer or at same offset.\n\t\t\t// Change how many nodes are moved. Do not move nodes that were moved by delta `b`.\n\t\t\tconst aRange = Range.createFromPositionAndShift( a.position, a._moveOperation.howMany );\n\t\t\tconst bRange = Range.createFromPositionAndShift( b.position, b._moveOperation.howMany );\n\n\t\t\tconst diff = aRange.getDifference( bRange );\n\n\t\t\tlet newHowMany = 0;\n\n\t\t\tfor ( const range of diff ) {\n\t\t\t\tnewHowMany += range.end.offset - range.start.offset;\n\t\t\t}\n\n\t\t\tif ( newHowMany === 0 ) {\n\t\t\t\ta.operations.pop(); // Remove last operation (`MoveOperation`).\n\t\t\t\ta.addOperation( new NoOperation( a.operations[ 0 ].baseVersion + 1 ) ); // Add `NoOperation` instead.\n\t\t\t} else {\n\t\t\t\ta.operations[ 1 ].howMany = newHowMany;\n\t\t\t}\n\n\t\t\treturn [ a ];\n\t\t} else {\n\t\t\t// `a` splits further.\n\t\t\t// This is more complicated case, thankfully we can solve it using default transformation and setting proper context.\n\t\t\tconst newContext = Object.assign( {}, context );\n\t\t\tnewContext.isStrong = true;\n\t\t\tnewContext.insertBefore = true;\n\n\t\t\treturn defaultTransform( a, b, newContext );\n\t\t}\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for SplitDelta x UnwrapDelta transformation.\naddTransformationCase( SplitDelta, UnwrapDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !a.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If incoming split delta tries to split a node that just got unwrapped, there is actually nothing to split,\n\t// so we discard that delta.\n\tif ( a.position.root == b.position.root && compareArrays( b.position.path, a.position.getParentPath() ) === 'same' ) {\n\t\treturn [ noDelta() ];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for SplitDelta x WrapDelta transformation.\naddTransformationCase( SplitDelta, WrapDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !a.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If split is applied at the position between wrapped nodes, we cancel the split as it's results may be unexpected and\n\t// very weird. Even if we do some \"magic\" we don't know what really are users' expectations.\n\n\tconst sameRoot = a.position.root == b.range.start.root;\n\tconst operateInSameParent = sameRoot && compareArrays( a.position.getParentPath(), b.range.start.getParentPath() ) === 'same';\n\tconst splitInsideWrapRange = b.range.start.offset < a.position.offset && b.range.end.offset >= a.position.offset;\n\n\tif ( operateInSameParent && splitInsideWrapRange ) {\n\t\treturn [ noDelta() ];\n\t} else if ( sameRoot && compareArrays( a.position.getParentPath(), b.range.end.getShiftedBy( -1 ).path ) === 'same' ) {\n\t\t// Split position is directly inside the last node from wrap range.\n\t\t// If that's the case, we manually change split delta so it will \"target\" inside the wrapping element.\n\t\t// By doing so we will be inserting split node right to the original node which feels natural and is a good UX.\n\t\tconst delta = a.clone();\n\n\t\t// 1. Fix insert operation position.\n\t\t// Node to split is the last children of the wrapping element.\n\t\t// Wrapping element is the element inserted by WrapDelta (re)insert operation.\n\t\t// It is inserted after the wrapped range, but the wrapped range will be moved inside it.\n\t\t// Having this in mind, it is correct to use wrapped range start position as the position before wrapping element.\n\t\tconst splitNodePos = Position.createFromPosition( b.range.start );\n\t\t// Now, `splitNodePos` points before wrapping element.\n\t\t// To get a position before last children of that element, we expand position's `path` member by proper offset.\n\t\tsplitNodePos.path.push( b.howMany - 1 );\n\n\t\t// SplitDelta insert operation position should be right after the node we split.\n\t\tconst insertPos = splitNodePos.getShiftedBy( 1 );\n\t\tdelta._cloneOperation.position = insertPos;\n\n\t\t// 2. Fix move operation source position.\n\t\t// Nodes moved by SplitDelta will be moved from new position, modified by WrapDelta.\n\t\t// To obtain that new position, `splitNodePos` will be used, as this is the node we are extracting children from.\n\t\tconst sourcePos = Position.createFromPosition( splitNodePos );\n\t\t// Nothing changed inside split node so it is correct to use the original split position offset.\n\t\tsourcePos.path.push( a.position.offset );\n\t\tdelta._moveOperation.sourcePosition = sourcePos;\n\n\t\t// 3. Fix move operation target position.\n\t\t// SplitDelta move operation target position should be inside the node inserted by operation above.\n\t\t// Since the node is empty, we will insert at offset 0.\n\t\tconst targetPos = Position.createFromPosition( insertPos );\n\t\ttargetPos.path.push( 0 );\n\t\tdelta._moveOperation.targetPosition = targetPos;\n\n\t\treturn [ delta ];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for SplitDelta x WrapDelta transformation.\naddTransformationCase( SplitDelta, AttributeDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !a.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\ta = a.clone();\n\n\tconst undoMode = context.undoMode;\n\tconst splitPosition = new Position( a.position.root, a.position.path.slice( 0, -1 ) );\n\n\t// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).\n\tif ( undoMode || !( a._cloneOperation instanceof InsertOperation ) ) {\n\t\treturn [ a ];\n\t}\n\n\t// If element to split had it's attribute changed, we have to reflect this change in an element\n\t// that is in SplitDelta's InsertOperation.\n\tfor ( const operation of b.operations ) {\n\t\tif ( operation.range.containsPosition( splitPosition ) || operation.range.start.isEqual( splitPosition ) ) {\n\t\t\tif ( operation.newValue !== null ) {\n\t\t\t\ta._cloneOperation.nodes.getNode( 0 )._setAttribute( operation.key, operation.newValue );\n\t\t\t} else {\n\t\t\t\ta._cloneOperation.nodes.getNode( 0 )._removeAttribute( operation.key );\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\n// Add special case for UnwrapDelta x SplitDelta transformation.\naddTransformationCase( UnwrapDelta, SplitDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If incoming unwrap delta tries to unwrap node that got split we should unwrap the original node and the split copy.\n\t// This can be achieved either by reverting split and applying unwrap to singular node, or creating additional unwrap delta.\n\tif ( a.position.root == b.position.root && compareArrays( a.position.path, b.position.getParentPath() ) === 'same' ) {\n\t\treturn [\n\t\t\tb.getReversed(),\n\t\t\ta.clone()\n\t\t];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for WeakInsertDelta x AttributeDelta transformation.\naddTransformationCase( WeakInsertDelta, AttributeDelta, ( a, b ) => {\n\t// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.\n\tconst deltas = [ a.clone() ];\n\n\tif ( b.range.containsPosition( a.position ) ) {\n\t\tdeltas.push( _getComplementaryAttrDelta( a, b ) );\n\t}\n\n\treturn deltas;\n} );\n\n// Add special case for WrapDelta x SplitDelta transformation.\naddTransformationCase( WrapDelta, SplitDelta, ( a, b, context ) => {\n\t// Do not apply special transformation case if `SplitDelta` has `NoOperation` as the second operation.\n\tif ( !b.position ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// If incoming wrap delta tries to wrap range that contains split position, we have to cancel the split and apply\n\t// the wrap. Since split was already applied, we have to revert it.\n\tconst sameRoot = a.range.start.root == b.position.root;\n\tconst operateInSameParent = sameRoot && compareArrays( a.range.start.getParentPath(), b.position.getParentPath() ) === 'same';\n\tconst splitInsideWrapRange = a.range.start.offset < b.position.offset && a.range.end.offset >= b.position.offset;\n\n\tif ( operateInSameParent && splitInsideWrapRange ) {\n\t\treturn [\n\t\t\tb.getReversed(),\n\t\t\ta.clone()\n\t\t];\n\t} else if ( sameRoot && compareArrays( b.position.getParentPath(), a.range.end.getShiftedBy( -1 ).path ) === 'same' ) {\n\t\tconst delta = a.clone();\n\n\t\t// Move wrapping element insert position one node further so it is after the split node insertion.\n\t\tdelta._insertOperation.position.offset++;\n\n\t\t// Include the split node copy.\n\t\tdelta._moveOperation.howMany++;\n\n\t\t// Change the path to wrapping element in move operation.\n\t\tdelta._moveOperation.targetPosition.path[ delta._moveOperation.targetPosition.path.length - 2 ]++;\n\n\t\treturn [ delta ];\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Add special case for RenameDelta x SplitDelta transformation.\naddTransformationCase( RenameDelta, SplitDelta, ( a, b, context ) => {\n\tconst undoMode = context.undoMode;\n\tconst deltas = defaultTransform( a, b, context );\n\n\t// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).\n\tif ( undoMode || !( b._cloneOperation instanceof InsertOperation ) ) {\n\t\treturn deltas;\n\t}\n\n\tconst insertPosition = b._cloneOperation.position.getShiftedBy( -1 );\n\n\tif ( insertPosition && a.operations[ 0 ].position.isEqual( insertPosition ) ) {\n\t\t// If a node that has been split has it's name changed, we should also change name of\n\t\t// the node created during splitting.\n\t\tconst additionalRenameDelta = a.clone();\n\t\tadditionalRenameDelta.operations[ 0 ].position = insertPosition.getShiftedBy( 1 );\n\n\t\tdeltas.push( additionalRenameDelta );\n\t}\n\n\treturn deltas;\n} );\n\n// Add special case for SplitDelta x RenameDelta transformation.\naddTransformationCase( SplitDelta, RenameDelta, ( a, b, context ) => {\n\ta = a.clone();\n\n\tconst undoMode = context.undoMode;\n\n\t// Special case applies only if undo is not a context and only if `SplitDelta` has `InsertOperation` (not `ReinsertOperation`).\n\tif ( undoMode || !( a._cloneOperation instanceof InsertOperation ) ) {\n\t\treturn [ a ];\n\t}\n\n\tconst insertPosition = a._cloneOperation.position.getShiftedBy( -1 );\n\n\t// If element to split had it's name changed, we have to reflect this by creating additional rename operation.\n\tif ( insertPosition && !undoMode && b.operations[ 0 ].position.isEqual( insertPosition ) ) {\n\t\tconst additionalRenameDelta = b.clone();\n\t\tadditionalRenameDelta.operations[ 0 ].position = insertPosition.getShiftedBy( 1 );\n\t\tadditionalRenameDelta.operations[ 0 ].oldName = a._cloneOperation.nodes.getNode( 0 ).name;\n\n\t\treturn [ a, additionalRenameDelta ];\n\t}\n\n\treturn [ a ];\n} );\n\n// Add special case for RemoveDelta x SplitDelta transformation.\naddTransformationCase( RemoveDelta, SplitDelta, ( a, b, context ) => {\n\tconst deltas = defaultTransform( a, b, context );\n\t// The \"clone operation\" may be InsertOperation, ReinsertOperation, MoveOperation or NoOperation.\n\tconst insertPosition = b._cloneOperation.position || b._cloneOperation.targetPosition;\n\n\t// NoOperation.\n\tif ( !insertPosition ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tconst undoMode = context.undoMode;\n\n\t// Special case applies only if undo is not a context.\n\tif ( undoMode ) {\n\t\treturn deltas;\n\t}\n\n\t// In case if `defaultTransform` returned more than one delta.\n\tfor ( const delta of deltas ) {\n\t\t// \"No delta\" may be returned in some cases.\n\t\tif ( delta instanceof RemoveDelta ) {\n\t\t\tconst operation = delta._moveOperation;\n\t\t\tconst rangeEnd = operation.sourcePosition.getShiftedBy( operation.howMany );\n\n\t\t\tif ( rangeEnd.isEqual( insertPosition ) ) {\n\t\t\t\toperation.howMany += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deltas;\n} );\n\n// Add special case for SplitDelta x RemoveDelta transformation.\naddTransformationCase( SplitDelta, RemoveDelta, ( a, b, context ) => {\n\tconst undoMode = context.undoMode;\n\n\t// Special case applies only if undo is not a context.\n\tif ( undoMode ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\t// This case is very trickily solved.\n\t// Instead of fixing `a` delta, we change `b` delta for a while and fire default transformation with fixed `b` delta.\n\t// Thanks to that fixing `a` delta will be differently (correctly) transformed.\n\t//\n\t// The \"clone operation\" may be InsertOperation, ReinsertOperation, MoveOperation or NoOperation.\n\tconst insertPosition = a._cloneOperation.position || a._cloneOperation.targetPosition;\n\n\t// NoOperation.\n\tif ( !insertPosition ) {\n\t\treturn defaultTransform( a, b, context );\n\t}\n\n\tb = b.clone();\n\tconst operation = b._moveOperation;\n\tconst rangeEnd = operation.sourcePosition.getShiftedBy( operation.howMany );\n\n\tif ( rangeEnd.isEqual( insertPosition ) ) {\n\t\toperation.howMany += 1;\n\t}\n\n\treturn defaultTransform( a, b, context );\n} );\n\n// Helper function for `AttributeDelta` class transformations.\n// Creates an attribute delta that sets attribute from given `attributeDelta` on nodes from given `weakInsertDelta`.\nfunction _getComplementaryAttrDelta( weakInsertDelta, attributeDelta ) {\n\tconst complementaryAttrDelta = new AttributeDelta();\n\tconst nodes = weakInsertDelta.nodes;\n\n\t// At the beginning we store the attribute value from the first node on `weakInsertDelta` node list.\n\tlet val = nodes.getNode( 0 ).getAttribute( attributeDelta.key );\n\n\t// This stores the last index of `weakInsertDelta` node list where the attribute value was different\n\t// than in the previous node. We need it to create separate `AttributeOperation`s for nodes with different attributes.\n\tlet lastOffset = 0;\n\t// Sum of offsets of already processed nodes.\n\tlet offsetSum = nodes.getNode( 0 ).offsetSize;\n\n\tfor ( let i = 1; i < nodes.length; i++ ) {\n\t\tconst node = nodes.getNode( i );\n\t\tconst nodeAttrVal = node.getAttribute( attributeDelta.key );\n\n\t\t// If previous node has different attribute value, we will create an operation to the point before current node.\n\t\t// So all nodes with the same attributes up to this point will be included in one `AttributeOperation`.\n\t\tif ( nodeAttrVal != val ) {\n\t\t\t// New operation is created only when it is needed. If given node already has proper value for this\n\t\t\t// attribute we simply skip it without adding a new operation.\n\t\t\tif ( val != attributeDelta.value ) {\n\t\t\t\taddOperation();\n\t\t\t}\n\n\t\t\tval = nodeAttrVal;\n\t\t\tlastOffset = offsetSum;\n\t\t}\n\n\t\toffsetSum = offsetSum + node.offsetSize;\n\t}\n\n\t// At the end we have to add additional `AttributeOperation` for the last part of node list. If all nodes on the\n\t// node list had same attributes, this will be the only operation added to the delta.\n\taddOperation();\n\n\treturn complementaryAttrDelta;\n\n\tfunction addOperation() {\n\t\tconst range = new Range(\n\t\t\tweakInsertDelta.position.getShiftedBy( lastOffset ),\n\t\t\tweakInsertDelta.position.getShiftedBy( offsetSum )\n\t\t);\n\n\t\tconst attrOperation = new AttributeOperation( range, attributeDelta.key, val, attributeDelta.value, 0 );\n\t\tcomplementaryAttrDelta.addOperation( attrOperation );\n\t}\n}\n\n// This is \"no-op\" delta, it has no type and only no-operation, it basically does nothing.\n// It is used when we don't want to apply changes but still we need to return a delta.\nfunction noDelta() {\n\tconst noDelta = new Delta();\n\n\t// BaseVersion will be fixed later anyway.\n\tnoDelta.addOperation( new NoOperation( 0 ) );\n\n\treturn noDelta;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/batch\n */\n\n/**\n * A batch instance groups model changes ({@link module:engine/model/delta/delta~Delta deltas}). All deltas grouped in a single batch\n * can be reverted together, so you can think about a batch as of a single undo step. If you want to extend a given undo step, you\n * can add more changes to the batch using {@link module:engine/model/model~Model#enqueueChange}:\n *\n *\t\tmodel.enqueueChange( batch, writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * @see module:engine/model/model~Model#enqueueChange\n * @see module:engine/model/model~Model#change\n */\nexport default class Batch {\n\t/**\n\t * Creates a batch instance.\n\t *\n\t * @see module:engine/model/model~Model#enqueueChange\n\t * @see module:engine/model/model~Model#change\n\t * @param {'transparent'|'default'} [type='default'] The type of the batch.\n\t */\n\tconstructor( type = 'default' ) {\n\t\t/**\n\t\t * An array of deltas that compose this batch.\n\t\t *\n\t\t * @readonly\n\t\t * @type {Array.<module:engine/model/delta/delta~Delta>}\n\t\t */\n\t\tthis.deltas = [];\n\n\t\t/**\n\t\t * The type of the batch.\n\t\t *\n\t\t * It can be one of the following values:\n\t\t * * `'default'` &ndash; All \"normal\" batches. This is the most commonly used type.\n\t\t * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing\n\t\t * changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {'transparent'|'default'}\n\t\t */\n\t\tthis.type = type;\n\t}\n\n\t/**\n\t * Returns the base version of this batch, which is equal to the base version of the first delta (which has the base version set)\n\t * in the batch. If there are no deltas in the batch or neither delta has the base version set, it returns `null`.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget baseVersion() {\n\t\tfor ( const delta of this.deltas ) {\n\t\t\tif ( delta.baseVersion !== null ) {\n\t\t\t\treturn delta.baseVersion;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adds a delta to the batch instance. All modification methods (insert, remove, split, etc.) use this method\n\t * to add created deltas.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} delta A delta to add.\n\t * @returns {module:engine/model/delta/delta~Delta} An added delta.\n\t */\n\taddDelta( delta ) {\n\t\tdelta.batch = this;\n\t\tthis.deltas.push( delta );\n\n\t\treturn delta;\n\t}\n\n\t/**\n\t * Gets an iterable collection of operations.\n\t *\n\t * @returns {Iterable.<module:engine/model/operation/operation~Operation>}\n\t */\n\t* getOperations() {\n\t\tfor ( const delta of this.deltas ) {\n\t\t\tyield* delta.operations;\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/delta/rootattributedelta\n */\n\nimport Delta from './delta';\nimport DeltaFactory from './deltafactory';\n\n/**\n * To provide specific OT behavior and better collisions solving, methods to change attributes\n * ({@link module:engine/model/writer~Writer#setAttribute} and {@link module:engine/model/writer~Writer#removeAttribute})\n * use `RootAttributeDelta` class which inherits from the `Delta` class and may\n * overwrite some methods.\n *\n * @extends module:engine/model/delta/delta~Delta\n */\nexport default class RootAttributeDelta extends Delta {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.delta.RootAttributeDelta';\n\t}\n}\n\nDeltaFactory.register( RootAttributeDelta );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/operation/detachoperation\n */\n\nimport Operation from './operation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _remove } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Operation to permanently remove node from detached root.\n * Note this operation is only a local operation and won't be send to the other clients.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\nexport default class DetachOperation extends Operation {\n\t/**\n\t * Creates an insert operation.\n\t *\n\t * @param {module:engine/model/position~Position} sourcePosition\n\t * Position before the first {@link module:engine/model/item~Item model item} to move.\n\t * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at\n\t * `sourcePosition` with offset shifted by `howMany`.\n\t */\n\tconstructor( sourcePosition, howMany ) {\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Position before the first {@link module:engine/model/item~Item model item} to detach.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} #sourcePosition\n\t\t */\n\t\tthis.sourcePosition = Position.createFromPosition( sourcePosition );\n\n\t\t/**\n\t\t * Offset size of moved range.\n\t\t *\n\t\t * @member {Number} #howMany\n\t\t */\n\t\tthis.howMany = howMany;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tget type() {\n\t\treturn 'detach';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_validate() {\n\t\tif ( this.sourcePosition.root.document ) {\n\t\t\t/**\n\t\t\t * Cannot detach document node.\n\t\t\t * Use {@link module:engine/model/operation/removeoperation~RemoveOperation remove operation} instead.\n\t\t\t *\n\t\t\t * @error detach-operation-on-document-node\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'detach-operation-on-document-node: Cannot detach document node.' );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\t_execute() {\n\t\t_remove( Range.createFromPositionAndShift( this.sourcePosition, this.howMany ) );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get className() {\n\t\treturn 'engine.model.operation.DetachOperation';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/rootelement\n */\n\nimport Element from './element';\n\n/**\n * Type of {@link module:engine/model/element~Element} that is a root of a model tree.\n * @extends module:engine/model/element~Element\n */\nexport default class RootElement extends Element {\n\t/**\n\t * Creates root element.\n\t *\n\t * @param {module:engine/model/document~Document} doc Document that is an owner of this root.\n\t * @param {String} name Node name.\n\t * @param {String} [rootName='main'] Unique root name used to identify this root\n\t * element by {@link module:engine/model/document~Document}.\n\t */\n\tconstructor( doc, name, rootName = 'main' ) {\n\t\tsuper( name );\n\n\t\t/**\n\t\t * Document that is an owner of this root.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis._doc = doc;\n\n\t\t/**\n\t\t * Unique root name used to identify this root element by {@link module:engine/model/document~Document}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.rootName = rootName;\n\t}\n\n\t/**\n\t * {@link module:engine/model/document~Document Document} that owns this root element.\n\t *\n\t * In contrary, to {@link module:engine/model/node~Node node}, root element always have a `document`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/document~Document|null}\n\t */\n\tget document() {\n\t\treturn this._doc;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tis( type, name ) {\n\t\tif ( !name ) {\n\t\t\treturn type == 'rootElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( type == 'rootElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\t/**\n\t * Converts `RootElement` instance to `String` containing it's name.\n\t *\n\t * @returns {String} `RootElement` instance converted to `String`.\n\t */\n\ttoJSON() {\n\t\treturn this.rootName;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/writer\n */\n\nimport AttributeDelta from './delta/attributedelta';\nimport InsertDelta from './delta/insertdelta';\nimport MarkerDelta from './delta/markerdelta';\nimport MergeDelta from './delta/mergedelta';\nimport MoveDelta from './delta/movedelta';\nimport RemoveDelta from './delta/removedelta';\nimport RenameDelta from './delta/renamedelta';\nimport RootAttributeDelta from './delta/rootattributedelta';\nimport SplitDelta from './delta/splitdelta';\nimport UnwrapDelta from './delta/unwrapdelta';\nimport WeakInsertDelta from './delta/weakinsertdelta';\nimport WrapDelta from './delta/wrapdelta';\n\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RemoveOperation from './operation/removeoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\n\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n\t/**\n\t * Creates a writer instance.\n\t *\n\t * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n\t * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/model~Model} model\n\t * @param {module:engine/model/batch~Batch} batch\n\t */\n\tconstructor( model, batch ) {\n\t\t/**\n\t\t * Instance of the model on which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The batch to which this writer will add changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/batch~Batch}\n\t\t */\n\t\tthis.batch = batch;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\t\twriter.createText( 'foo', { bold: true } );\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @returns {module:engine/model/text~Text} Created text node.\n\t */\n\tcreateText( data, attributes ) {\n\t\treturn new Text( data, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/element~Element element}.\n\t *\n\t *\t\twriter.createElement( 'paragraph' );\n\t *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/model/element~Element} Created element.\n\t */\n\tcreateElement( name, attributes ) {\n\t\treturn new Element( name, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new DocumentFragment();\n\t}\n\n\t/**\n\t * Inserts item on given position.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, position );\n\t *\n\t * Instead of using position you can use parent and offset:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 5 );\n\t *\n\t * You can also use `end` instead of the offset to insert at the end:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 'end' );\n\t *\n\t * Or insert before or after another element:\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n\t *\n\t * These parameters works the same way as {@link module:engine/model/position~Position.createAt `Position.createAt()`}.\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n\t * `model-writer-insert-forbidden-move` is thrown.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n\t * fragment to insert.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsert( item, itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst position = Position.createAt( itemOrPosition, offset );\n\n\t\t// For text that has no parent we need to make a WeakInsert.\n\t\tconst delta = item instanceof Text && !item.parent ? new WeakInsertDelta() : new InsertDelta();\n\n\t\t// If item has a parent already.\n\t\tif ( item.parent ) {\n\t\t\t// We need to check if item is going to be inserted within the same document.\n\t\t\tif ( isSameTree( item.root, position.root ) ) {\n\t\t\t\t// If it's we just need to move it.\n\t\t\t\tthis.move( Range.createOn( item ), position );\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If it isn't the same root.\n\t\t\telse {\n\t\t\t\tif ( item.root.document ) {\n\t\t\t\t\t// It is forbidden to move a node that was already in a document outside of it.\n\t\t\t\t\tthrow new Error( 'model-writer-insert-forbidden-move: Cannot move a node from a document to a different tree.' );\n\t\t\t\t} else {\n\t\t\t\t\t// Move between two different document fragments or from document fragment to a document is possible.\n\t\t\t\t\t// In that case, remove the item from it's original parent.\n\t\t\t\t\tthis.remove( item );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst version = position.root.document ? position.root.document.version : null;\n\n\t\tconst insert = new InsertOperation( position, item, version );\n\n\t\tthis.batch.addDelta( delta );\n\t\tdelta.addOperation( insert );\n\t\tthis.model.applyOperation( insert );\n\n\t\t// When element is a DocumentFragment we need to move its markers to Document#markers.\n\t\tif ( item instanceof DocumentFragment ) {\n\t\t\tfor ( const [ markerName, markerRange ] of item.markers ) {\n\t\t\t\t// We need to migrate marker range from DocumentFragment to Document.\n\t\t\t\tconst rangeRootPosition = Position.createAt( markerRange.root );\n\t\t\t\tconst range = new Range(\n\t\t\t\t\tmarkerRange.start._getCombined( rangeRootPosition, position ),\n\t\t\t\t\tmarkerRange.end._getCombined( rangeRootPosition, position )\n\t\t\t\t);\n\n\t\t\t\tthis.addMarker( markerName, { range, usingOperation: true } );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts text on given position. You can optionally set text attributes:\n\t *\n\t *\t\twriter.insertText( 'foo', position );\n\t *\t\twriter.insertText( 'foo', { bold: true }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts 'foo' in paragraph, at offset 5:\n\t *\t\twriter.insertText( 'foo', paragraph, 5 );\n\t *\t\t// Inserts 'foo' at the end of a paragraph:\n\t *\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t// Inserts 'foo' after an image:\n\t *\t\twriter.insertText( 'foo', image, 'after' );\n\t *\n\t * These parameters work in the same way as {@link module:engine/model/position~Position.createAt `Position.createAt()`}.\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertText( text, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createText( text ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts element on given position. You can optionally set attributes:\n\t *\n\t *\t\twriter.insertElement( 'paragraph', position );\n\t *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts paragraph in the root at offset 5:\n\t *\t\twriter.insertElement( 'paragraph', root, 5 );\n\t *\t\t// Inserts paragraph at the end of a blockquote:\n\t *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n\t *\t\t// Inserts after an image:\n\t *\t\twriter.insertElement( 'paragraph', image, 'after' );\n\t *\n\t * These parameters works the same way as {@link module:engine/model/position~Position.createAt `Position.createAt()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertElement( name, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Inserts item at the end of the given parent.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.append( paragraph, root );\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n\t * item Item or document fragment to insert.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappend( item, parent ) {\n\t\tthis.insert( item, parent, 'end' );\n\t}\n\n\t/**\n\t * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n\t *\n\t *\t\twriter.appendText( 'foo', paragraph );\n\t *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n\t *\n\t * @param {String} text Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendText( text, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createText( text ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n\t *\n\t *\t\twriter.appendElement( 'paragraph', root );\n\t *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendElement( name, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {*} value Attribute new value.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attribute will be set.\n\t */\n\tsetAttribute( key, value, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tsetAttributeOnRange( this, key, value, itemOrRange );\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, value, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t *\t\twriter.setAttributes( {\n\t *\t\t\tbold: true,\n\t *\t\t\titalic: true\n\t *\t\t}, range );\n\t *\n\t * @param {Object} attributes Attributes keys and values.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attributes will be set.\n\t */\n\tsetAttributes( attributes, itemOrRange ) {\n\t\tfor ( const [ key, val ] of toMap( attributes ) ) {\n\t\t\tthis.setAttribute( key, val, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n\t * or from a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which the attribute will be removed.\n\t */\n\tremoveAttribute( key, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tsetAttributeOnRange( this, key, null, itemOrRange );\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, null, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from all elements in the range or from the given item.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which all attributes will be removed.\n\t */\n\tclearAttributes( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst removeAttributesFromItem = item => {\n\t\t\tfor ( const attribute of item.getAttributeKeys() ) {\n\t\t\t\tthis.removeAttribute( attribute, item );\n\t\t\t}\n\t\t};\n\n\t\tif ( !( itemOrRange instanceof Range ) ) {\n\t\t\tremoveAttributesFromItem( itemOrRange );\n\t\t} else {\n\t\t\tfor ( const item of itemOrRange.getItems() ) {\n\t\t\t\tremoveAttributesFromItem( item );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves all items in the source range to the target position.\n\t *\n\t *\t\twriter.move( sourceRange, targetPosition );\n\t *\n\t * Instead of the target position you can use parent and offset or define that range should be moved to the end\n\t * or before or after chosen item:\n\t *\n\t *\t\t// Moves all items in the range to the paragraph at offset 5:\n\t *\t\twriter.move( sourceRange, paragraph, 5 );\n\t *\t\t// Moves all items in the range to the end of a blockquote:\n\t *\t\twriter.move( sourceRange, blockquote, 'end' );\n\t *\t\t// Moves all items in the range to a position after an image:\n\t *\t\twriter.move( sourceRange, image, 'after' );\n\t *\n\t * These parameters works the same way as {@link module:engine/model/position~Position.createAt `Position.createAt()`}.\n\t *\n\t * Note that items can be moved only within the same tree. It means that you can move items within the same root\n\t * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n\t * but you can not move items from document fragment to the document or from one detached element to another. Use\n\t * {@link module:engine/model/writer~Writer#insert} in such cases.\n\t *\n\t * @param {module:engine/model/range~Range} range Source range.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tmove( range, itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\t/**\n\t\t\t * Invalid range to move.\n\t\t\t *\n\t\t\t * @error writer-move-invalid-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-invalid-range: Invalid range to move.' );\n\t\t}\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to move is not flat.\n\t\t\t *\n\t\t\t * @error writer-move-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-range-not-flat: Range to move is not flat.' );\n\t\t}\n\n\t\tconst position = Position.createAt( itemOrPosition, offset );\n\n\t\tif ( !isSameTree( range.root, position.root ) ) {\n\t\t\t/**\n\t\t\t * Range is going to be moved within not the same document. Please use\n\t\t\t * {@link module:engine/model/writer~Writer#insert insert} instead.\n\t\t\t *\n\t\t\t * @error writer-move-different-document\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-different-document: Range is going to be moved between different documents.' );\n\t\t}\n\n\t\tconst delta = new MoveDelta();\n\t\tthis.batch.addDelta( delta );\n\n\t\tconst version = range.root.document ? range.root.document.version : null;\n\n\t\tconst operation = new MoveOperation( range.start, range.end.offset - range.start.offset, position, version );\n\t\tdelta.addOperation( operation );\n\t\tthis.model.applyOperation( operation );\n\t}\n\n\t/**\n\t * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n\t */\n\tremove( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst addRemoveDelta = ( position, howMany ) => {\n\t\t\tconst delta = new RemoveDelta();\n\t\t\tthis.batch.addDelta( delta );\n\n\t\t\tapplyRemoveOperation( position, howMany, delta, this.model );\n\t\t};\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\t// The array is reversed, so the ranges to remove are in correct order and do not have to be updated.\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges().reverse();\n\n\t\t\tfor ( const flat of ranges ) {\n\t\t\t\taddRemoveDelta( flat.start, flat.end.offset - flat.start.offset );\n\t\t\t}\n\t\t} else {\n\t\t\tconst howMany = itemOrRange.is( 'text' ) ? itemOrRange.offsetSize : 1;\n\n\t\t\taddRemoveDelta( Position.createBefore( itemOrRange ), howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Merges two siblings at the given position.\n\t *\n\t * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n\t * `writer-merge-no-element-after` error will be thrown.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of merge.\n\t */\n\tmerge( position ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst delta = new MergeDelta();\n\t\tthis.batch.addDelta( delta );\n\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node before merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-before\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-before: Node before merge position must be an element.' );\n\t\t}\n\n\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node after merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-after\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-after: Node after merge position must be an element.' );\n\t\t}\n\n\t\tconst positionAfter = Position.createFromParentAndOffset( nodeAfter, 0 );\n\t\tconst positionBefore = Position.createFromParentAndOffset( nodeBefore, nodeBefore.maxOffset );\n\n\t\tconst moveVersion = position.root.document ? position.root.document.version : null;\n\n\t\tconst move = new MoveOperation(\n\t\t\tpositionAfter,\n\t\t\tnodeAfter.maxOffset,\n\t\t\tpositionBefore,\n\t\t\tmoveVersion\n\t\t);\n\n\t\tmove.isSticky = true;\n\t\tdelta.addOperation( move );\n\t\tthis.model.applyOperation( move );\n\n\t\tapplyRemoveOperation( position, 1, delta, this.model );\n\t}\n\n\t/**\n\t * Renames the given element.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to rename.\n\t * @param {String} newName New element name.\n\t */\n\trename( element, newName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( element instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Trying to rename an object which is not an instance of Element.\n\t\t\t *\n\t\t\t * @error writer-rename-not-element-instance\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.'\n\t\t\t);\n\t\t}\n\n\t\tconst delta = new RenameDelta();\n\t\tthis.batch.addDelta( delta );\n\n\t\tconst version = element.root.document ? element.root.document.version : null;\n\n\t\tconst renameOperation = new RenameOperation( Position.createBefore( element ), element.name, newName, version );\n\t\tdelta.addOperation( renameOperation );\n\t\tthis.model.applyOperation( renameOperation );\n\t}\n\n\t/**\n\t * Splits elements starting from the given position and going to the top of the model tree as long as given\n\t * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n\t *\n\t * The element needs to have a parent. It cannot be a root element nor a document fragment.\n\t * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of split.\n\t * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n\t * @returns {Object} result Split result.\n\t * @returns {module:engine/model/position~Position} result.position between split elements.\n\t * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ands\n\t * at the beginning of the first copy element.\n\t */\n\tsplit( position, limitElement ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tlet splitElement = position.parent;\n\n\t\tif ( !splitElement.parent ) {\n\t\t\t/**\n\t\t\t * Element with no parent can not be split.\n\t\t\t *\n\t\t\t * @error writer-split-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-element-no-parent: Element with no parent can not be split.' );\n\t\t}\n\n\t\t// When limit element is not defined lets set splitElement parent as limit.\n\t\tif ( !limitElement ) {\n\t\t\tlimitElement = splitElement.parent;\n\t\t}\n\n\t\tif ( !position.parent.getAncestors( { includeSelf: true } ).includes( limitElement ) ) {\n\t\t\tthrow new CKEditorError( 'writer-split-invalid-limit-element: Limit element is not a position ancestor.' );\n\t\t}\n\n\t\t// We need to cache elements that will be created as a result of the first split because\n\t\t// we need to create a range from the end of the first split element to the beginning of the\n\t\t// first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\t\tlet firstSplitElement, firstCopyElement;\n\n\t\tdo {\n\t\t\tconst delta = new SplitDelta();\n\t\t\tthis.batch.addDelta( delta );\n\n\t\t\tconst copy = new Element( splitElement.name, splitElement.getAttributes() );\n\t\t\tconst insertVersion = splitElement.root.document ? splitElement.root.document.version : null;\n\n\t\t\tconst insert = new InsertOperation(\n\t\t\t\tPosition.createAfter( splitElement ),\n\t\t\t\tcopy,\n\t\t\t\tinsertVersion\n\t\t\t);\n\n\t\t\tdelta.addOperation( insert );\n\t\t\tthis.model.applyOperation( insert );\n\n\t\t\tconst moveVersion = insertVersion !== null ? insertVersion + 1 : null;\n\n\t\t\tconst move = new MoveOperation(\n\t\t\t\tposition,\n\t\t\t\tsplitElement.maxOffset - position.offset,\n\t\t\t\tPosition.createFromParentAndOffset( copy, 0 ),\n\t\t\t\tmoveVersion\n\t\t\t);\n\t\t\tmove.isSticky = true;\n\n\t\t\tdelta.addOperation( move );\n\t\t\tthis.model.applyOperation( move );\n\n\t\t\t// Cache result of the first split.\n\t\t\tif ( !firstSplitElement && !firstCopyElement ) {\n\t\t\t\tfirstSplitElement = splitElement;\n\t\t\t\tfirstCopyElement = copy;\n\t\t\t}\n\n\t\t\tposition = Position.createBefore( copy );\n\t\t\tsplitElement = position.parent;\n\t\t} while ( splitElement !== limitElement );\n\n\t\treturn {\n\t\t\tposition,\n\t\t\trange: new Range( Position.createAt( firstSplitElement, 'end' ), Position.createAt( firstCopyElement ) )\n\t\t};\n\t}\n\n\t/**\n\t * Wraps the given range with the given element or with a new element (if a string was passed).\n\t *\n\t * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n\t * If not, an error will be thrown.\n\t *\n\t * @param {module:engine/model/range~Range} range Range to wrap.\n\t * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n\t */\n\twrap( range, elementOrString ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to wrap is not flat.\n\t\t\t *\n\t\t\t * @error writer-wrap-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-range-not-flat: Range to wrap is not flat.' );\n\t\t}\n\n\t\tconst element = elementOrString instanceof Element ? elementOrString : new Element( elementOrString );\n\n\t\tif ( element.childCount > 0 ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is not empty.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-not-empty: Element to wrap with is not empty.' );\n\t\t}\n\n\t\tif ( element.parent !== null ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is already attached to a tree model.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-attached\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-attached: Element to wrap with is already attached to tree model.' );\n\t\t}\n\n\t\tconst delta = new WrapDelta();\n\t\tthis.batch.addDelta( delta );\n\n\t\tconst insertVersion = range.root.document ? range.root.document.version : null;\n\n\t\tconst insert = new InsertOperation( range.end, element, insertVersion );\n\t\tdelta.addOperation( insert );\n\t\tthis.model.applyOperation( insert );\n\n\t\tconst moveVersion = insertVersion !== null ? insertVersion + 1 : null;\n\n\t\tconst targetPosition = Position.createFromParentAndOffset( element, 0 );\n\t\tconst move = new MoveOperation(\n\t\t\trange.start,\n\t\t\trange.end.offset - range.start.offset,\n\t\t\ttargetPosition,\n\t\t\tmoveVersion\n\t\t);\n\t\tdelta.addOperation( move );\n\t\tthis.model.applyOperation( move );\n\t}\n\n\t/**\n\t * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n\t * Throws error if you try to unwrap an element which does not have a parent.\n\t *\n\t * @param {module:engine/model/element~Element} element Element to unwrap.\n\t */\n\tunwrap( element ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( element.parent === null ) {\n\t\t\t/**\n\t\t\t * Trying to unwrap an element which has no parent.\n\t\t\t *\n\t\t\t * @error writer-unwrap-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.' );\n\t\t}\n\n\t\tconst delta = new UnwrapDelta();\n\t\tthis.batch.addDelta( delta );\n\n\t\tconst sourcePosition = Position.createFromParentAndOffset( element, 0 );\n\t\tconst moveVersion = sourcePosition.root.document ? sourcePosition.root.document.version : null;\n\n\t\tconst move = new MoveOperation(\n\t\t\tsourcePosition,\n\t\t\telement.maxOffset,\n\t\t\tPosition.createBefore( element ),\n\t\t\tmoveVersion\n\t\t);\n\n\t\tmove.isSticky = true;\n\t\tdelta.addOperation( move );\n\t\tthis.model.applyOperation( move );\n\n\t\tapplyRemoveOperation( Position.createBefore( element ), 1, delta, this.model );\n\t}\n\n\t/**\n\t * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes.\n\t *\n\t * As the first parameter you can set marker name.\n\t *\n\t * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by the\n\t * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Create marker directly base on marker's name:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false } );\n\t *\n\t * Create marker using operation:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Create marker that affects the editor data:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n\t *\n\t * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String} name Name of a marker to create - must be unique.\n\t * @param {Object} options\n\t * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {module:engine/model/range~Range} options.range Marker range.\n\t * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n\t * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n\t */\n\taddMarker( name, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !options || typeof options.usingOperation != 'boolean' ) {\n\t\t\t/**\n\t\t\t * The `options.usingOperations` parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addMarker-no-usingOperations\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-addMarker-no-usingOperations: The options.usingOperations parameter is required when adding a new marker.'\n\t\t\t);\n\t\t}\n\n\t\tconst usingOperation = options.usingOperation;\n\t\tconst range = options.range;\n\t\tconst affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n\t\tif ( this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Marker with provided name already exists.\n\t\t\t *\n\t\t\t * @error writer-addMarker-marker-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addMarker-marker-exists: Marker with provided name already exists.' );\n\t\t}\n\n\t\tif ( !range ) {\n\t\t\t/**\n\t\t\t * Range parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addMarker-no-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addMarker-no-range: Range parameter is required when adding a new marker.' );\n\t\t}\n\n\t\tif ( !usingOperation ) {\n\t\t\treturn this.model.markers._set( name, range, usingOperation, affectsData );\n\t\t}\n\n\t\tapplyMarkerOperation( this, name, null, range, affectsData );\n\n\t\treturn this.model.markers.get( name );\n\t}\n\n\t/**\n\t * Adds or updates a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n\t * marker's range directly using this method.\n\t *\n\t * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n\t * name is created and returned.\n\t *\n\t * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by\n\t * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Update marker directly base on marker's name:\n\t *\n\t *\t\tupdateMarker( markerName, { range } );\n\t *\n\t * Update marker using operation:\n\t *\n\t *\t\tupdateMarker( marker, { range, usingOperation: true } );\n\t *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Change marker's option (start using operations to manage it):\n\t *\n\t *\t\tupdateMarker( marker, { usingOperation: true } );\n\t *\n\t * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n\t *\n\t *\t\tupdateMarker( markerName, { affectsData: false } );\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String} markerOrName Name of a marker to update, or a marker instance.\n\t * @param {Object} options\n\t * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n\t * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n\t */\n\tupdateMarker( markerOrName, options = {} ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\t\tconst currentMarker = this.model.markers.get( markerName );\n\n\t\tif ( !currentMarker ) {\n\t\t\t/**\n\t\t\t * Marker with provided name does not exists.\n\t\t\t *\n\t\t\t * @error writer-updateMarker-marker-not-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updateMarker-marker-not-exists: Marker with provided name does not exists.' );\n\t\t}\n\n\t\tconst hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n\t\tconst affectsDataDefined = typeof options.affectsData == 'boolean';\n\n\t\t// Use previously defined marker's affectsData if the property is not provided.\n\t\tconst affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n\t\tif ( !hasUsingOperationDefined && !options.range && !affectsDataDefined ) {\n\t\t\t/**\n\t\t\t * One of the options is required - provide range, usingOperations or affectsData.\n\t\t\t *\n\t\t\t * @error writer-updateMarker-wrong-options\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.'\n\t\t\t);\n\t\t}\n\n\t\tconst currentRange = currentMarker.getRange();\n\t\tconst updatedRange = options.range ? options.range : currentRange;\n\n\t\tif ( hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations ) {\n\t\t\t// The marker type is changed so it's necessary to create proper operations.\n\t\t\tif ( options.usingOperation ) {\n\t\t\t\t// If marker changes to a managed one treat this as synchronizing existing marker.\n\t\t\t\t// Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n\t\t\t\tapplyMarkerOperation( this, markerName, null, updatedRange, affectsData );\n\t\t\t} else {\n\t\t\t\t// If marker changes to a marker that do not use operations then we need to create additional operation\n\t\t\t\t// that removes that marker first.\n\t\t\t\tapplyMarkerOperation( this, markerName, currentRange, null, affectsData );\n\n\t\t\t\t// Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\t\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Marker's type doesn't change so update it accordingly.\n\t\tif ( currentMarker.managedUsingOperations ) {\n\t\t\tapplyMarkerOperation( this, markerName, currentRange, updatedRange, affectsData );\n\t\t} else {\n\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n\t * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n\t * it will be destroyed using operation.\n\t *\n\t * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n\t */\n\tremoveMarker( markerOrName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n\t\tif ( !this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to remove marker which does not exist.\n\t\t\t *\n\t\t\t * @error writer-removeMarker-no-marker\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-removeMarker-no-marker: Trying to remove marker which does not exist.' );\n\t\t}\n\n\t\tconst marker = this.model.markers.get( name );\n\n\t\tif ( !marker.managedUsingOperations ) {\n\t\t\tthis.model.markers._remove( name );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldRange = marker.getRange();\n\n\t\tapplyMarkerOperation( this, name, oldRange, null, marker.affectsData );\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selection selection}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/node~Node node}, {@link module:engine/model/position~Position position},\n\t * {@link module:engine/model/range~Range range}, an iterable of {@link module:engine/model/range~Range ranges} or null.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = new Range( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ new Range( start1, end2 ), new Range( star2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\tconst otherSelection = new Selection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\tconst documentSelection = new DocumentSelection( doc );\n\t *\t\twriter.setSelection( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = new Position( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/position~Position|module:engine/model/node~Node|\n\t * Iterable.<module:engine/model/range~Range>|module:engine/model/range~Range|null} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link module:engine/model/position~Position.createAt `Position.createAt()`} parameters.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * Using key and value pair:\n\t *\n\t * \twriter.setSelectionAttribute( 'italic', true );\n\t *\n\t * Using key-value object:\n\t *\n\t * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n\t *\n\t * Using iterable object:\n\t *\n\t * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n\t *\n\t * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n\t * or object / iterable of key => value attribute pairs.\n\t * @param {*} [value] Attribute value.\n\t */\n\tsetSelectionAttribute( keyOrObjectOrIterable, value ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrObjectOrIterable === 'string' ) {\n\t\t\tthis._setSelectionAttribute( keyOrObjectOrIterable, value );\n\t\t} else {\n\t\t\tfor ( const [ key, value ] of toMap( keyOrObjectOrIterable ) ) {\n\t\t\t\tthis._setSelectionAttribute( key, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute(s) with given key(s) from the selection.\n\t *\n\t * Remove one attribute:\n\t *\n\t *\t\twriter.removeSelectionAttribute( 'italic' );\n\t *\n\t * Remove multiple attributes:\n\t *\n\t *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n\t *\n\t * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n\t */\n\tremoveSelectionAttribute( keyOrIterableOfKeys ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrIterableOfKeys === 'string' ) {\n\t\t\tthis._removeSelectionAttribute( keyOrIterableOfKeys );\n\t\t} else {\n\t\t\tfor ( const key of keyOrIterableOfKeys ) {\n\t\t\t\tthis._removeSelectionAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n\t * of the selection from left to right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n\t * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * For the following model fragment:\n\t *\n\t *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n\t *\n\t * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n\t * * Overridden gravity: selection will have `bold` attribute.\n\t *\n\t * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\toverrideSelectionGravity() {\n\t\treturn this.model.document.selection._overrideGravity();\n\t}\n\n\t/**\n\t * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n\t */\n\trestoreSelectionGravity( uid ) {\n\t\tthis.model.document.selection._restoreGravity( uid );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t * @param {*} value Attribute value.\n\t */\n\t_setSelectionAttribute( key, value ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Store attribute in parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.setAttribute( storeKey, value, selection.anchor.parent );\n\t\t}\n\n\t\tselection._setAttribute( key, value );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeSelectionAttribute( key ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.removeAttribute( storeKey, selection.anchor.parent );\n\t\t}\n\n\t\tselection._removeAttribute( key );\n\t}\n\n\t/**\n\t * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n\t *\n\t * @private\n\t */\n\t_assertWriterUsedCorrectly() {\n\t\t/**\n\t\t * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()` or\n\t\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n\t\t *\n\t\t * The writer can only be used inside these blocks which ensures that the model\n\t\t * can only be changed during such \"sessions\".\n\t\t *\n\t\t * @error writer-incorrect-use\n\t\t */\n\t\tif ( this.model._currentWriter !== this ) {\n\t\t\tthrow new CKEditorError( 'writer-incorrect-use: Trying to use a writer outside the change() block.' );\n\t\t}\n\t}\n}\n\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange( writer, key, value, range ) {\n\tconst delta = new AttributeDelta();\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\t// Position of the last split, the beginning of the new range.\n\tlet lastSplitPosition = range.start;\n\n\t// Currently position in the scanning range. Because we need value after the position, it is not a current\n\t// position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\tlet position;\n\n\t// Value before the currently position.\n\tlet valueBefore;\n\n\t// Value after the currently position.\n\tlet valueAfter;\n\n\tfor ( const val of range ) {\n\t\tvalueAfter = val.item.getAttribute( key );\n\n\t\t// At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n\t\t// because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\t\tif ( position && valueBefore != valueAfter ) {\n\t\t\t// if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n\t\t\tif ( valueBefore != value ) {\n\t\t\t\taddOperation();\n\t\t\t}\n\n\t\t\tlastSplitPosition = position;\n\t\t}\n\n\t\tposition = val.nextPosition;\n\t\tvalueBefore = valueAfter;\n\t}\n\n\t// Because position in the loop is not the iterator position (see let position comment), the last position in\n\t// the while loop will be last but one position in the range. We need to check the last position manually.\n\tif ( position instanceof Position && position != lastSplitPosition && valueBefore != value ) {\n\t\taddOperation();\n\t}\n\n\tfunction addOperation() {\n\t\t// Add delta to the batch only if there is at least operation in the delta. Add delta only once.\n\t\tif ( delta.operations.length === 0 ) {\n\t\t\twriter.batch.addDelta( delta );\n\t\t}\n\n\t\tconst range = new Range( lastSplitPosition, position );\n\t\tconst version = range.root.document ? doc.version : null;\n\t\tconst operation = new AttributeOperation( range, key, valueBefore, value, version );\n\n\t\tdelta.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem( writer, key, value, item ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\tconst previousValue = item.getAttribute( key );\n\tlet range, operation;\n\n\tif ( previousValue != value ) {\n\t\tconst isRootChanged = item.root === item;\n\n\t\tconst delta = isRootChanged ? new RootAttributeDelta() : new AttributeDelta();\n\t\twriter.batch.addDelta( delta );\n\n\t\tif ( isRootChanged ) {\n\t\t\t// If we change attributes of root element, we have to use `RootAttributeOperation`.\n\t\t\tconst version = item.document ? doc.version : null;\n\n\t\t\toperation = new RootAttributeOperation( item, key, previousValue, value, version );\n\t\t} else {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\t// If we change the attribute of the element, we do not want to change attributes of its children, so\n\t\t\t\t// the end of the range cannot be after the closing tag, it should be inside that element, before any of\n\t\t\t\t// it's children, so the range will contain only the opening tag.\n\t\t\t\trange = new Range( Position.createBefore( item ), Position.createFromParentAndOffset( item, 0 ) );\n\t\t\t} else {\n\t\t\t\t// If `item` is text proxy, we create a range from the beginning to the end of that text proxy, to change\n\t\t\t\t// all characters represented by it.\n\t\t\t\trange = new Range( Position.createBefore( item ), Position.createAfter( item ) );\n\t\t\t}\n\n\t\t\tconst version = range.root.document ? doc.version : null;\n\n\t\t\toperation = new AttributeOperation( range, key, previousValue, value, version );\n\t\t}\n\n\t\tdelta.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Creates and applies marker operation to {@link module:engine/model/delta/delta~Delta delta}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation( writer, name, oldRange, newRange, affectsData ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\tconst delta = new MarkerDelta();\n\n\tconst operation = new MarkerOperation( name, oldRange, newRange, model.markers, doc.version, affectsData );\n\n\twriter.batch.addDelta( delta );\n\tdelta.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Creates `RemoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given delta instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {module:engine/model/delta~Delta} delta Delta to add new operation to.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation( position, howMany, delta, model ) {\n\tlet operation;\n\n\tif ( position.root.document ) {\n\t\tconst doc = model.document;\n\t\tconst graveyardPosition = new Position( doc.graveyard, [ 0 ] );\n\n\t\toperation = new RemoveOperation( position, howMany, graveyardPosition, doc.version );\n\t} else {\n\t\toperation = new DetachOperation( position, howMany );\n\t}\n\n\tdelta.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree( rootA, rootB ) {\n\t// If it is the same root this is the same tree.\n\tif ( rootA === rootB ) {\n\t\treturn true;\n\t}\n\n\t// If both roots are documents root it is operation within the document what we still treat as the same tree.\n\tif ( rootA instanceof RootElement && rootB instanceof RootElement ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n\t\t * state before and after the change.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems() ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range.createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n\t * been created.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n\t * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n\t */\n\tbufferMarkerChange( markerName, oldRange, newRange, affectsData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\toldRange,\n\t\t\t\tnewRange,\n\t\t\t\taffectsData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newRange = newRange;\n\t\t\tbuffered.affectsData = affectsData;\n\n\t\t\tif ( buffered.oldRange == null && buffered.newRange == null ) {\n\t\t\t\t// The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldRange != null ) {\n\t\t\t\tresult.push( { name, range: change.oldRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newRange != null ) {\n\t\t\t\tresult.push( { name, range: change.newRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectingData`.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tfor ( const [ , change ] of this._changedMarkers ) {\n\t\t\tif ( change.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If markers do not affect the data, check whether there are some changes in elements.\n\t\treturn this._changesInElement.size > 0;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of diff items, each describing a change done on the model. The items are sorted by\n\t * the position on which the change happened. If a position {@link module:engine/model/position~Position#isBefore is before}\n\t * another one, it will be on an earlier index in the diff set.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<Object>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tconst diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ].name ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ].name ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = Range.createFromParentsAndOffsets( element, i, element, i + 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = Range.createFromParentsAndOffsets( element, i, element.getChild( index ), 0 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount < b.changeCount ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ i - 1 ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tdiffSet[ i - 1 ].length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tdiffSet[ i - 1 ].range.end = diffSet[ i - 1 ].range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet.slice();\n\t\tthis._cachedChanges = diffSet.slice().filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard;\n\t\t} else {\n\t\t\treturn this._cachedChanges;\n\t\t}\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position.createFromParentAndOffset( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position.createFromParentAndOffset( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: Range.createFromRange( range ),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: Range.createFromRange( range ),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = Range.createFromParentsAndOffsets( parent, offset, parent, offset + howMany );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( 'text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tactions.push( ...'e'.repeat( change.offset - offset ).split( '' ) );\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tactions.push( ...'i'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tactions.push( ...'r'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset isa at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tactions.push( ...'e'.repeat( oldChildrenLength - oldChildrenHandled ).split( '' ) );\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/history\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * `History` keeps the track of all the deltas applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n\t/**\n\t * Creates an empty History instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Deltas added to the history.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/model/delta/delta~Delta>} module:engine/model/history~History#_deltas\n\t\t */\n\t\tthis._deltas = [];\n\n\t\t/**\n\t\t * Helper structure that maps added delta's base version to the index in {@link module:engine/model/history~History#_deltas}\n\t\t * at which the delta was added.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map} module:engine/model/history~History#_historyPoints\n\t\t */\n\t\tthis._historyPoints = new Map();\n\n\t\t/**\n\t\t * Holds an information which {@link module:engine/model/delta/delta~Delta delta} undoes which\n\t\t * {@link module:engine/model/delta/delta~Delta delta}.\n\t\t *\n\t\t * Keys of the map are \"undoing deltas\", that is deltas that undone some other deltas. For each key, the\n\t\t * value is a delta that has been undone by the \"undoing delta\".\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/history~History#_undoPairs\n\t\t */\n\t\tthis._undoPairs = new Map();\n\n\t\t/**\n\t\t * Holds all undone deltas.\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/delta/delta~Delta>} module:engine/model/history~History#_undoneDeltas\n\t\t */\n\t\tthis._undoneDeltas = new Set();\n\t}\n\n\t/**\n\t * Adds delta to the history.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} delta Delta to add.\n\t */\n\taddDelta( delta ) {\n\t\tif ( delta.operations.length > 0 && !this._historyPoints.has( delta.baseVersion ) ) {\n\t\t\tconst index = this._deltas.length;\n\n\t\t\tthis._deltas[ index ] = delta;\n\t\t\tthis._historyPoints.set( delta.baseVersion, index );\n\t\t}\n\t}\n\n\t/**\n\t * Returns deltas added to the history.\n\t *\n\t * @param {Number} [from=0] Base version from which deltas should be returned (inclusive). Defaults to `0`, which means\n\t * that deltas from the first one will be returned.\n\t * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which deltas should be returned (exclusive).\n\t * Defaults to `Number.POSITIVE_INFINITY` which means that deltas up to the last one will be returned.\n\t * @returns {Iterable.<module:engine/model/delta/delta~Delta>} Deltas added to the history from given base versions range.\n\t */\n\t* getDeltas( from = 0, to = Number.POSITIVE_INFINITY ) {\n\t\t// No deltas added, nothing to yield.\n\t\tif ( this._deltas.length === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Will throw if base version is incorrect.\n\t\tlet fromIndex = this._getIndex( from );\n\n\t\t// Base version is too low or too high and is not found in history.\n\t\tif ( fromIndex == -1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We have correct `fromIndex` so let's iterate starting from it.\n\t\twhile ( fromIndex < this._deltas.length ) {\n\t\t\tconst delta = this._deltas[ fromIndex++ ];\n\n\t\t\tif ( delta.baseVersion >= to ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tyield delta;\n\t\t}\n\t}\n\n\t/**\n\t * Returns delta from history that bases on given `baseVersion`.\n\t *\n\t * @param {Number} baseVersion Base version of the delta to get.\n\t * @returns {module:engine/model/delta/delta~Delta|null} Delta with given base version or `null` if there is no such delta in history.\n\t */\n\tgetDelta( baseVersion ) {\n\t\tconst index = this._historyPoints.get( baseVersion );\n\n\t\treturn index === undefined ? null : this._deltas[ index ];\n\t}\n\n\t/**\n\t * Marks in history that one delta is a delta that is undoing the other delta. By marking deltas this way,\n\t * history is keeping more context information about deltas which helps in operational transformation.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} undoneDelta Delta which is undone by `undoingDelta`.\n\t * @param {module:engine/model/delta/delta~Delta} undoingDelta Delta which undoes `undoneDelta`.\n\t */\n\tsetDeltaAsUndone( undoneDelta, undoingDelta ) {\n\t\tthis._undoPairs.set( undoingDelta, undoneDelta );\n\t\tthis._undoneDeltas.add( undoneDelta );\n\t}\n\n\t/**\n\t * Checks whether given `delta` is undoing by any other delta.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} delta Delta to check.\n\t * @returns {Boolean} `true` if given `delta` is undoing any other delta, `false` otherwise.\n\t */\n\tisUndoingDelta( delta ) {\n\t\treturn this._undoPairs.has( delta );\n\t}\n\n\t/**\n\t * Checks whether given `delta` has been undone by any other delta.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} delta Delta to check.\n\t * @returns {Boolean} `true` if given `delta` has been undone any other delta, `false` otherwise.\n\t */\n\tisUndoneDelta( delta ) {\n\t\treturn this._undoneDeltas.has( delta );\n\t}\n\n\t/**\n\t * For given `undoingDelta`, returns the delta which has been undone by it.\n\t *\n\t * @param {module:engine/model/delta/delta~Delta} undoingDelta\n\t * @returns {module:engine/model/delta/delta~Delta|undefined} Delta that has been undone by given `undoingDelta` or `undefined`\n\t * if given `undoingDelta` is not undoing any other delta.\n\t */\n\tgetUndoneDelta( undoingDelta ) {\n\t\treturn this._undoPairs.get( undoingDelta );\n\t}\n\n\t/**\n\t * Gets an index in {@link module:engine/model/history~History#_deltas} where delta with given `baseVersion` is added.\n\t *\n\t * @private\n\t * @param {Number} baseVersion Base version of delta.\n\t */\n\t_getIndex( baseVersion ) {\n\t\tconst index = this._historyPoints.get( baseVersion );\n\n\t\t// Base version not found - it is either too high or too low, or is in the middle of delta.\n\t\tif ( index === undefined ) {\n\t\t\tconst lastDelta = this._deltas[ this._deltas.length - 1 ];\n\t\t\tconst nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;\n\n\t\t\tif ( baseVersion < 0 || baseVersion >= nextBaseVersion ) {\n\t\t\t\t// Base version is too high or too low - it's acceptable situation.\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Given base version points to the middle of a delta.\n\t\t\t *\n\t\t\t * @error history-wrong-version\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-history-wrong-version: Given base version points to the middle of a delta.' );\n\t\t}\n\n\t\treturn index;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Set of utils to handle unicode characters.\n *\n * @module utils/unicode\n */\n\n/**\n * Checks whether given `character` is a combining mark.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\nexport function isCombiningMark( character ) {\n\treturn !!character && character.length == 1 && /[\\u0300-\\u036f\\u1ab0-\\u1aff\\u1dc0-\\u1dff\\u20d0-\\u20ff\\ufe20-\\ufe2f]/.test( character );\n}\n\n/**\n * Checks whether given `character` is a high half of surrogate pair.\n *\n * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair\n * consist of high surrogate pair character followed by low surrogate pair character.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\nexport function isHighSurrogateHalf( character ) {\n\treturn !!character && character.length == 1 && /[\\ud800-\\udbff]/.test( character );\n}\n\n/**\n * Checks whether given `character` is a low half of surrogate pair.\n *\n * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair\n * consist of high surrogate pair character followed by low surrogate pair character.\n *\n * @param {String} character Character to check.\n * @returns {Boolean}\n */\nexport function isLowSurrogateHalf( character ) {\n\treturn !!character && character.length == 1 && /[\\udc00-\\udfff]/.test( character );\n}\n\n/**\n * Checks whether given offset in a string is inside a surrogate pair (between two surrogate halves).\n *\n * @param {String} string String to check.\n * @param {Number} offset Offset to check.\n * @returns {Boolean}\n */\nexport function isInsideSurrogatePair( string, offset ) {\n\treturn isHighSurrogateHalf( string.charAt( offset - 1 ) ) && isLowSurrogateHalf( string.charAt( offset ) );\n}\n\n/**\n * Checks whether given offset in a string is between base character and combining mark or between two combining marks.\n *\n * @param {String} string String to check.\n * @param {Number} offset Offset to check.\n * @returns {Boolean}\n */\nexport function isInsideCombinedSymbol( string, offset ) {\n\treturn isCombiningMark( string.charAt( offset ) );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/document\n */\n\nimport Differ from './differ';\nimport Range from './range';\nimport Position from './position';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport clone from '@ckeditor/ckeditor5-utils/src/lib/lodash/clone';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\n\nconst graveyardName = '$graveyard';\n\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document {\n\t/**\n\t * Creates an empty document instance with no {@link #roots} (other than\n\t * the {@link #graveyard graveyard root}).\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * The {@link module:engine/model/model~Model model} that the document is a part of.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n\t\t * operations are applied on a proper document version.\n\t\t *\n\t\t * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n\t\t * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The document's history.\n\t\t *\n\t\t * **Note:** Be aware that deltas applied to the document might get removed or changed.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/history~History}\n\t\t */\n\t\tthis.history = new History( this );\n\n\t\t/**\n\t\t * The selection in this document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = new DocumentSelection( this );\n\n\t\t/**\n\t\t * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n\t\t * {@link #getRoot} to manipulate it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/collection~Collection}\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/differ~Differ}\n\t\t */\n\t\tthis.differ = new Differ( model.markers );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the model document.\n\t\t *\n\t\t * @private\n\t\t * @member {Set}\n\t\t */\n\t\tthis._postFixers = new Set();\n\n\t\t// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\t\tthis.createRoot( '$root', graveyardName );\n\n\t\t// First, if the operation is a document operation check if it's base version is correct.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation && operation.baseVersion !== this.version ) {\n\t\t\t\t/**\n\t\t\t\t * Only operations with matching versions can be applied.\n\t\t\t\t *\n\t\t\t\t * @error document-applyOperation-wrong-version\n\t\t\t\t * @param {module:engine/model/operation/operation~Operation} operation\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.',\n\t\t\t\t\t{ operation }\n\t\t\t\t);\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\n\t\t// Then, still before an operation is applied on model, buffer the change in differ.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.differ.bufferOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// After the operation is applied, bump document's version and add the operation to the history.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.version++;\n\t\t\t\tthis.history.addDelta( operation.delta );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Listen to selection changes. If selection changed, mark it.\n\t\tlet hasSelectionChanged = false;\n\n\t\tthis.listenTo( this.selection, 'change', () => {\n\t\t\thasSelectionChanged = true;\n\t\t} );\n\n\t\t// Wait for `_change` event from model, which signalizes that outermost change block has finished.\n\t\t// When this happens, check if there were any changes done on document, and if so, call post-fixers,\n\t\t// fire `change` event for features and conversion and then reset the differ.\n\t\t// Fire `change:data` event when at least one operation or buffered marker changes the data.\n\t\tthis.listenTo( model, '_change', ( evt, writer ) => {\n\t\t\tif ( !this.differ.isEmpty || hasSelectionChanged ) {\n\t\t\t\tthis._callPostFixers( writer );\n\n\t\t\t\tif ( this.differ.hasDataChanges() ) {\n\t\t\t\t\tthis.fire( 'change:data', writer.batch );\n\t\t\t\t} else {\n\t\t\t\t\tthis.fire( 'change', writer.batch );\n\t\t\t\t}\n\n\t\t\t\tthis.differ.reset();\n\t\t\t\thasSelectionChanged = false;\n\t\t\t}\n\t\t} );\n\n\t\t// Buffer marker changes.\n\t\t// This is not covered in buffering operations because markers may change outside of them (when they\n\t\t// are modified using `model.markers` collection, not through `MarkerOperation`).\n\t\tthis.listenTo( model.markers, 'update', ( evt, marker, oldRange, newRange ) => {\n\t\t\t// Whenever marker is updated, buffer that change.\n\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, newRange, marker.affectsData );\n\n\t\t\tif ( oldRange === null ) {\n\t\t\t\t// If this is a new marker, add a listener that will buffer change whenever marker changes.\n\t\t\t\tmarker.on( 'change', ( evt, oldRange ) => {\n\t\t\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, marker.getRange(), marker.affectsData );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n\t *\n\t * @readonly\n\t * @member {module:engine/model/rootelement~RootElement}\n\t */\n\tget graveyard() {\n\t\treturn this.getRoot( graveyardName );\n\t}\n\n\t/**\n\t * Creates a new root.\n\t *\n\t * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n\t * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n\t * @param {String} [rootName='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement} The created root.\n\t */\n\tcreateRoot( elementName = '$root', rootName = 'main' ) {\n\t\tif ( this.roots.get( rootName ) ) {\n\t\t\t/**\n\t\t\t * A root with the specified name already exists.\n\t\t\t *\n\t\t\t * @error model-document-createRoot-name-exists\n\t\t\t * @param {module:engine/model/document~Document} doc\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-document-createRoot-name-exists: Root with specified name already exists.',\n\t\t\t\t{ name: rootName }\n\t\t\t);\n\t\t}\n\n\t\tconst root = new RootElement( this, elementName, rootName );\n\t\tthis.roots.add( root );\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Removes all event listeners set by the document instance.\n\t */\n\tdestroy() {\n\t\tthis.selection.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Returns a root by its name.\n\t *\n\t * @param {String} [name='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n\t * there is no root with the given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n\t *\n\t * @returns {Array.<String>} Roots names.\n\t */\n\tgetRootNames() {\n\t\treturn Array.from( this.roots, root => root.rootName ).filter( name => name != graveyardName );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features that listen to\n\t * the {@link module:engine/model/model~Model#event:_change model's change event} will operate on a correct model state.\n\t *\n\t * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n\t * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n\t * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n\t * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n\t * for the user.\n\t *\n\t * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n\t * callback should add an empty paragraph so that the editor is never empty:\n\t *\n\t *\t\tdocument.registerPostFixer( writer => {\n\t *\t\t\tconst changes = document.differ.getChanges();\n\t *\n\t *\t\t\t// Check if the changes lead to an empty root in the editor.\n\t *\t\t\tfor ( const entry of changes ) {\n\t *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n\t *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n\t *\n\t *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n\t *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n\t *\t\t\t\t\treturn true;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * A custom `toJSON()` method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} A clone of this object with the document property changed to a string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tjson.selection = '[engine.model.DocumentSelection]';\n\t\tjson.model = '[engine.model.Model]';\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Returns the default root for this document which is either the first root that was added to the document using\n\t * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n\t */\n\t_getDefaultRoot() {\n\t\tfor ( const root of this.roots ) {\n\t\t\tif ( root !== this.graveyard ) {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\n\t\treturn this.graveyard;\n\t}\n\n\t/**\n\t * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n\t * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getDefaultRange() {\n\t\tconst defaultRoot = this._getDefaultRoot();\n\t\tconst schema = this.model.schema;\n\n\t\t// Find the first position where the selection can be put.\n\t\tconst position = new Position( defaultRoot, [ 0 ] );\n\t\tconst nearestRange = schema.getNearestSelectionRange( position );\n\n\t\t// If valid selection range is not found - return range collapsed at the beginning of the root.\n\t\treturn nearestRange || new Range( position );\n\t}\n\n\t/**\n\t * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n\t * the {@link #selection document's selection}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range A range to check.\n\t * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n\t */\n\t_validateSelectionRange( range ) {\n\t\treturn validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @private\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n\t * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n\t * during that block's execution.\n\t *\n\t * The changes which this event will cover include:\n\t *\n\t * * document structure changes,\n\t * * selection changes,\n\t * * marker changes.\n\t *\n\t * If you want to be notified about all these changes, then simply listen to this event like this:\n\t *\n\t *\t\tmodel.document.on( 'change', () => {\n\t *\t\t\tconsole.log( 'The document has changed!' );\n\t *\t\t} );\n\t *\n\t * If, however, you only want to be notified about the data changes, then use the\n\t * {@link module:engine/model/document~Document#event:change:data change:data} event,\n\t * which is fired for document structure changes and marker changes (which affects the data).\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * @event change\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t/**\n\t * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n\t * affect the editor data. This is:\n\t *\n\t * * document structure changes,\n\t * * marker changes (which affects the data).\n\t *\n\t * If you want to be notified about the data changes, then listen to this event:\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * If you would like to listen to all document changes, then check out the\n\t * {@link module:engine/model/document~Document#event:change change} event.\n\t *\n\t * @event change:data\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n}\n\nmix( Document, EmitterMixin );\n\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition( rangeBoundary ) {\n\tconst textNode = rangeBoundary.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tconst offset = rangeBoundary.offset - textNode.startOffset;\n\n\t\treturn !isInsideSurrogatePair( data, offset ) && !isInsideCombinedSymbol( data, offset );\n\t}\n\n\treturn true;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/markercollection\n */\n\nimport LiveRange from './liverange';\nimport Position from './position';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\nexport default class MarkerCollection {\n\t/**\n\t * Creates a markers collection.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Stores {@link ~Marker markers} added to the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} #_markers\n\t\t */\n\t\tthis._markers = new Map();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link ~Marker markers} added to the collection.\n\t *\n\t * @returns {Iterable}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._markers.values();\n\t}\n\n\t/**\n\t * Checks if marker with given `markerName` is in the collection.\n\t *\n\t * @param {String} markerName Marker name.\n\t * @returns {Boolean} `true` if marker with given `markerName` is in the collection, `false` otherwise.\n\t */\n\thas( markerName ) {\n\t\treturn this._markers.has( markerName );\n\t}\n\n\t/**\n\t * Returns {@link ~Marker marker} with given `markerName`.\n\t *\n\t * @param {String} markerName Name of marker to get.\n\t * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n\t * not added to the collection.\n\t */\n\tget( markerName ) {\n\t\treturn this._markers.get( markerName ) || null;\n\t}\n\n\t/**\n\t * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n\t * {@link module:engine/model/range~Range range}.\n\t *\n\t * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n\t * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n\t * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n\t * flag has changed.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n\t * @param {module:engine/model/range~Range} range Marker range.\n\t * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n\t * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n\t */\n\t_set( markerOrName, range, managedUsingOperations = false, affectsData = false ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tconst oldRange = oldMarker.getRange();\n\t\t\tlet hasChanged = false;\n\n\t\t\tif ( !oldRange.isEqual( range ) ) {\n\t\t\t\toldMarker._attachLiveRange( LiveRange.createFromRange( range ) );\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( managedUsingOperations != oldMarker.managedUsingOperations ) {\n\t\t\t\toldMarker._managedUsingOperations = managedUsingOperations;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData ) {\n\t\t\t\toldMarker._affectsData = affectsData;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( hasChanged ) {\n\t\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldRange, range );\n\t\t\t}\n\n\t\t\treturn oldMarker;\n\t\t}\n\n\t\tconst liveRange = LiveRange.createFromRange( range );\n\t\tconst marker = new Marker( markerName, liveRange, managedUsingOperations, affectsData );\n\n\t\tthis._markers.set( markerName, marker );\n\t\tthis.fire( 'update:' + markerName, marker, null, range );\n\n\t\treturn marker;\n\t}\n\n\t/**\n\t * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String} markerOrName Marker or name of a marker to remove.\n\t * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n\t */\n\t_remove( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tthis._markers.delete( markerName );\n\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldMarker.getRange(), null );\n\n\t\t\tthis._destroyMarker( oldMarker );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersAtPosition( position ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().containsPosition( position ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} range\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersIntersectingRange( range ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().getIntersection( range ) !== null ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys marker collection and all markers inside it.\n\t */\n\tdestroy() {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tthis._destroyMarker( marker );\n\t\t}\n\n\t\tthis._markers = null;\n\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Iterates over all markers that starts with given `prefix`.\n\t *\n\t *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n\t *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n\t *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n\t *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n\t *\n\t * @param prefix\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersGroup( prefix ) {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tif ( marker.name.startsWith( prefix + ':' ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the marker.\n\t *\n\t * @private\n\t * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n\t */\n\t_destroyMarker( marker ) {\n\t\tmarker.stopListening();\n\t\tmarker._detachLiveRange();\n\t}\n\n\t/**\n\t * Fired whenever marker is added, updated or removed from `MarkerCollection`.\n\t *\n\t * @event update\n\t * @param {module:engine/model/markercollection~Marker} Updated Marker.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it\n\t * means that marker is just added.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it\n\t * means that marker is just removed.\n\t */\n}\n\nmix( MarkerCollection, EmitterMixin );\n\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'set:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcast-converters downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcast-converters upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\nclass Marker {\n\t/**\n\t * Creates a marker instance.\n\t *\n\t * @param {String} name Marker name.\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n\t * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n\t * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t */\n\tconstructor( name, liveRange, managedUsingOperations, affectsData ) {\n\t\t/**\n\t\t * Marker's name.\n\t\t *\n\t\t * @readonly\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Range marked by the marker.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/model/liverange~LiveRange}\n\t\t */\n\t\tthis._liveRange = this._attachLiveRange( liveRange );\n\n\t\t/**\n\t\t * Flag indicates if the marker is managed using operations or not.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._managedUsingOperations = managedUsingOperations;\n\n\t\t/**\n\t\t * Specifies whether the marker affects the data produced by the data pipeline\n\t\t * (is persisted in the editor's data).\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._affectsData = affectsData;\n\t}\n\n\t/**\n\t * A value indicating if the marker is managed using operations.\n\t * See {@link ~Marker marker class description} to learn more about marker types.\n\t * See {@link module:engine/model/writer~Writer#addMarker}.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget managedUsingOperations() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.' );\n\t\t}\n\n\t\treturn this._managedUsingOperations;\n\t}\n\n\t/**\n\t * A value indicating if the marker changes the data.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget affectsData() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.' );\n\t\t}\n\n\t\treturn this._affectsData;\n\t}\n\n\t/**\n\t * Returns current marker start position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetStart() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.' );\n\t\t}\n\n\t\treturn Position.createFromPosition( this._liveRange.start );\n\t}\n\n\t/**\n\t * Returns current marker end position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetEnd() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.' );\n\t\t}\n\n\t\treturn Position.createFromPosition( this._liveRange.end );\n\t}\n\n\t/**\n\t * Returns a range that represents the current state of the marker.\n\t *\n\t * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n\t * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n\t * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n\t * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n\t * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n\t * that it's data is up-to-date.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tgetRange() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.' );\n\t\t}\n\n\t\treturn Range.createFromRange( this._liveRange );\n\t}\n\n\t/**\n\t * Binds new live range to the marker and detach the old one if is attached.\n\t *\n\t * @protected\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n\t * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n\t */\n\t_attachLiveRange( liveRange ) {\n\t\tif ( this._liveRange ) {\n\t\t\tthis._detachLiveRange();\n\t\t}\n\n\t\t// Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n\t\tliveRange.delegate( 'change:range' ).to( this );\n\t\tliveRange.delegate( 'change:content' ).to( this );\n\n\t\tthis._liveRange = liveRange;\n\n\t\treturn liveRange;\n\t}\n\n\t/**\n\t * Unbinds and destroys currently attached live range.\n\t *\n\t * @protected\n\t */\n\t_detachLiveRange() {\n\t\tthis._liveRange.stopDelegating( 'change:range', this );\n\t\tthis._liveRange.stopDelegating( 'change:content', this );\n\t\tthis._liveRange.detach();\n\t\tthis._liveRange = null;\n\t}\n\n\t/**\n\t * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:range\n\t * @event change:range\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n\n\t/**\n\t * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:content\n\t * @event change:content\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n}\n\nmix( Marker, EmitterMixin );\n\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/liveposition\n */\n\nimport Position from './position';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * `LivePosition` is a type of {@link module:engine/model/position~Position Position}\n * that updates itself as {@link module:engine/model/document~Document document}\n * is changed through operations. It may be used as a bookmark.\n *\n * **Note:** Contrary to {@link module:engine/model/position~Position}, `LivePosition` works only in roots that are\n * {@link module:engine/model/rootelement~RootElement}.\n * If {@link module:engine/model/documentfragment~DocumentFragment} is passed, error will be thrown.\n *\n * **Note:** Be very careful when dealing with `LivePosition`. Each `LivePosition` instance bind events that might\n * have to be unbound.\n * Use {@link module:engine/model/liveposition~LivePosition#detach} whenever you don't need `LivePosition` anymore.\n *\n * @extends module:engine/model/position~Position\n */\nexport default class LivePosition extends Position {\n\t/**\n\t * Creates a live position.\n\t *\n\t * @see module:engine/model/position~Position\n\t * @param {module:engine/model/rootelement~RootElement} root\n\t * @param {Array.<Number>} path\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness] Defaults to `'sticksToNext'`.\n\t * See {@link module:engine/model/liveposition~LivePosition#stickiness}.\n\t */\n\tconstructor( root, path, stickiness ) {\n\t\tsuper( root, path );\n\n\t\tif ( !this.root.is( 'rootElement' ) ) {\n\t\t\t/**\n\t\t\t * LivePosition's root has to be an instance of RootElement.\n\t\t\t *\n\t\t\t * @error liveposition-root-not-rootelement\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-liveposition-root-not-rootelement: LivePosition\\'s root has to be an instance of RootElement.'\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Flag representing `LivePosition` stickiness. `LivePosition` might be sticking to previous node or next node.\n\t\t * Whenever some nodes are inserted at the same position as `LivePosition`, `stickiness` is checked to decide if\n\t\t * LivePosition should be moved. Similar applies when a range of nodes is moved and one of it's boundary\n\t\t * position is same as `LivePosition`.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t *\t\tInsert:\n\t\t *\t\tPosition is at | and we insert at the same position, marked as ^:\n\t\t *\t\t- | sticks to previous node: `<p>f|^oo</p>` => `<p>f|baroo</p>`\n\t\t *\t\t- | sticks to next node: `<p>f^|oo</p>` => `<p>fbar|oo</p>`\n\t\t *\n\t\t *\t\tMove:\n\t\t *\t\tPosition is at | and range [ ] is moved to position ^:\n\t\t *\t\t- | sticks to previous node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f|</p><p>booar</p>`\n\t\t *\t\t- | sticks to next node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f</p><p>b|ooar</p>`\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/liveposition~LivePosition#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness || 'sticksToNext';\n\n\t\tbindWithDocument.call( this );\n\t}\n\n\t/**\n\t * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance\n\t * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was\n\t * referring to it).\n\t */\n\tdetach() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * @static\n\t * @method module:engine/model/liveposition~LivePosition.createAfter\n\t * @see module:engine/model/position~Position.createAfter\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {module:engine/model/liveposition~LivePosition}\n\t */\n\n\t/**\n\t * @static\n\t * @method module:engine/model/liveposition~LivePosition.createBefore\n\t * @see module:engine/model/position~Position.createBefore\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {module:engine/model/liveposition~LivePosition}\n\t */\n\n\t/**\n\t * @static\n\t * @method module:engine/model/liveposition~LivePosition.createFromParentAndOffset\n\t * @see module:engine/model/position~Position.createFromParentAndOffset\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @returns {module:engine/model/liveposition~LivePosition}\n\t */\n\n\t/**\n\t * @static\n\t * @method module:engine/model/liveposition~LivePosition.createFromPosition\n\t * @see module:engine/model/position~Position.createFromPosition\n\t * @param {module:engine/model/position~Position} position\n\t * @returns {module:engine/model/liveposition~LivePosition}\n\t */\n\n\t/**\n\t * Fired when `LivePosition` instance is changed due to changes on {@link module:engine/model/document~Document}.\n\t *\n\t * @event module:engine/model/liveposition~LivePosition#change\n\t * @param {module:engine/model/position~Position} oldPosition Position equal to this live position before it got changed.\n\t */\n}\n\n/**\n * Binds this `LivePosition` to the {@link module:engine/model/document~Document document} that owns\n * this position's {@link module:engine/model/position~Position#root root}.\n *\n * @ignore\n * @private\n * @method module:engine/model/liveposition~LivePosition.bindWithDocument\n */\nfunction bindWithDocument() {\n\t// Operation types handled by LivePosition (these are operations that change model tree structure).\n\tconst supportedTypes = new Set( [ 'insert', 'move', 'remove', 'reinsert' ] );\n\n\tthis.listenTo(\n\t\tthis.root.document.model,\n\t\t'applyOperation',\n\t\t( event, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( !operation.isDocumentOperation ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( supportedTypes.has( operation.type ) ) {\n\t\t\t\ttransform.call( this, operation );\n\t\t\t}\n\t\t},\n\t\t{ priority: 'low' }\n\t);\n}\n\n/**\n * Updates this position accordingly to the updates applied to the model. Bases on change events.\n *\n * @ignore\n * @private\n * @method transform\n * @param {module:engine/model/operation/operation~Operation} operation Executed operation.\n */\nfunction transform( operation ) {\n\t/* eslint-disable no-case-declarations */\n\tlet range;\n\tlet position;\n\n\tif ( operation.type == 'insert' ) {\n\t\trange = Range.createFromPositionAndShift( operation.position, operation.nodes.maxOffset );\n\t} else {\n\t\trange = Range.createFromPositionAndShift( operation.getMovedRangeStart(), operation.howMany );\n\t\tposition = operation.sourcePosition;\n\t}\n\n\tconst howMany = range.end.offset - range.start.offset;\n\tlet transformed;\n\n\tswitch ( operation.type ) {\n\t\tcase 'insert':\n\t\t\tconst insertBefore = this.stickiness == 'sticksToNext';\n\t\t\ttransformed = this._getTransformedByInsertion( range.start, howMany, insertBefore );\n\t\t\tbreak;\n\n\t\tcase 'move':\n\t\tcase 'remove':\n\t\tcase 'reinsert':\n\t\t\tconst originalRange = Range.createFromPositionAndShift( position, howMany );\n\n\t\t\tconst gotMoved = originalRange.containsPosition( this ) ||\n\t\t\t\t( originalRange.start.isEqual( this ) && this.stickiness == 'sticksToNext' ) ||\n\t\t\t\t( originalRange.end.isEqual( this ) && this.stickiness == 'sticksToPrevious' );\n\n\t\t\t// We can't use ._getTransformedByMove() because we have a different if-condition.\n\t\t\tif ( gotMoved ) {\n\t\t\t\ttransformed = this._getCombined( position, range.start );\n\t\t\t} else {\n\t\t\t\tconst insertBefore = this.stickiness == 'sticksToNext';\n\n\t\t\t\t// `Position._getTransformedByMove` is expecting `targetPosition` to be \"before\" move\n\t\t\t\t// (before transformation). `range.start` is already after the move happened.\n\t\t\t\t// We have to revert `targetPosition` to the state before the move.\n\t\t\t\tconst targetPosition = range.start._getTransformedByInsertion( position, howMany );\n\n\t\t\t\ttransformed = this._getTransformedByMove( position, targetPosition, howMany, insertBefore );\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif ( !this.isEqual( transformed ) ) {\n\t\tconst oldPosition = Position.createFromPosition( this );\n\n\t\tthis.path = transformed.path;\n\t\tthis.root = transformed.root;\n\n\t\tthis.fire( 'change', oldPosition );\n\t}\n\t/* eslint-enable no-case-declarations */\n}\n\nmix( LivePosition, EmitterMixin );\n\n/**\n * Enum representing how position is \"sticking\" with their neighbour nodes.\n * Possible values: `'sticksToNext'`, `'sticksToPrevious'`.\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\n\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste\n * functionality to work.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection into which the content should be inserted.\n */\nexport default function insertContent( model, content, selection ) {\n\tmodel.change( writer => {\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tmodel.deleteContent( selection );\n\t\t}\n\n\t\tconst insertion = new Insertion( model, writer, selection.anchor );\n\n\t\tlet nodesToInsert;\n\n\t\tif ( content.is( 'documentFragment' ) ) {\n\t\t\tnodesToInsert = content.getChildren();\n\t\t} else {\n\t\t\tnodesToInsert = [ content ];\n\t\t}\n\n\t\tinsertion.handleNodes( nodesToInsert, {\n\t\t\t// The set of children being inserted is the only set in this context\n\t\t\t// so it's the first and last (it's a hack ;)).\n\t\t\tisFirst: true,\n\t\t\tisLast: true\n\t\t} );\n\n\t\tconst newRange = insertion.getSelectionRange();\n\n\t\t/* istanbul ignore else */\n\t\tif ( newRange ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\twriter.setSelection( newRange );\n\t\t\t} else {\n\t\t\t\tselection.setTo( newRange );\n\t\t\t}\n\t\t} else {\n\t\t\t// We are not testing else because it's a safe check for unpredictable edge cases:\n\t\t\t// an insertion without proper range to select.\n\n\t\t\t/**\n\t\t\t * Cannot determine a proper selection range after insertion.\n\t\t\t *\n\t\t\t * @warning insertcontent-no-range\n\t\t\t */\n\t\t\tlog.warn( 'insertcontent-no-range: Cannot determine a proper selection range after insertion.' );\n\t\t}\n\t} );\n}\n\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n\tconstructor( model, writer, position ) {\n\t\t/**\n\t\t * The model in context of which the insertion should be performed.\n\t\t *\n\t\t * @member {module:engine/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Batch to which deltas will be added.\n\t\t *\n\t\t * @member {module:engine/controller/writer~Batch} #writer\n\t\t */\n\t\tthis.writer = writer;\n\n\t\t/**\n\t\t * The position at which (or near which) the next node will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} #position\n\t\t */\n\t\tthis.position = position;\n\n\t\t/**\n\t\t * Elements with which the inserted elements can be merged.\n\t\t *\n\t\t *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n\t\t *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n\t\t *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n\t\t *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n\t\t *\n\t\t *\n\t\t * @member {Set} #canMergeWith\n\t\t */\n\t\tthis.canMergeWith = new Set( [ this.position.parent ] );\n\n\t\t/**\n\t\t * Schema of the model.\n\t\t *\n\t\t * @member {module:engine/model/schema~Schema} #schema\n\t\t */\n\t\tthis.schema = model.schema;\n\n\t\tthis._filterAttributesOf = [];\n\t}\n\n\t/**\n\t * Handles insertion of a set of nodes.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n\t * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.\n\t * If the parent context is passed it means that the parent element was stripped (was not allowed).\n\t */\n\thandleNodes( nodes, parentContext ) {\n\t\tnodes = Array.from( nodes );\n\n\t\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\t\tconst node = nodes[ i ];\n\n\t\t\tthis._handleNode( node, {\n\t\t\t\tisFirst: i === 0 && parentContext.isFirst,\n\t\t\t\tisLast: ( i === ( nodes.length - 1 ) ) && parentContext.isLast\n\t\t\t} );\n\t\t}\n\n\t\t// TMP this will become a post-fixer.\n\t\tthis.schema.removeDisallowedAttributes( this._filterAttributesOf, this.writer );\n\t\tthis._filterAttributesOf = [];\n\t}\n\n\t/**\n\t * Returns range to be selected after insertion.\n\t * Returns null if there is no valid range to select after insertion.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetSelectionRange() {\n\t\tif ( this.nodeToSelect ) {\n\t\t\treturn Range.createOn( this.nodeToSelect );\n\t\t}\n\n\t\treturn this.model.schema.getNearestSelectionRange( this.position );\n\t}\n\n\t/**\n\t * Handles insertion of a single node.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @param {Object} context\n\t * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.\n\t * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.\n\t */\n\t_handleNode( node, context ) {\n\t\t// Let's handle object in a special way.\n\t\t// * They should never be merged with other elements.\n\t\t// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n\t\tif ( this.schema.isObject( node ) ) {\n\t\t\tthis._handleObject( node, context );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Try to find a place for the given node.\n\t\t// Split the position.parent's branch up to a point where the node can be inserted.\n\t\t// If it isn't allowed in the whole branch, then of course don't split anything.\n\t\tconst isAllowed = this._checkAndSplitToAllowedPosition( node, context );\n\n\t\tif ( !isAllowed ) {\n\t\t\tthis._handleDisallowedNode( node, context );\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._insert( node );\n\n\t\t// After the node was inserted we may try to merge it with its siblings.\n\t\t// This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)\n\t\t// and only if the selection was in those elements initially.\n\t\t//\n\t\t// E.g.:\n\t\t// <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n\t\t// and:\n\t\t// <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>y</p><p>z</p> => <p>xy[]z</p>\n\t\t// but:\n\t\t// <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)\n\t\t// <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deletetContents\n\t\t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t it's exactly the same case as above)\n\t\tthis._mergeSiblingsOf( node, context );\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/element~Element} node The object element.\n\t * @param {Object} context\n\t */\n\t_handleObject( node, context ) {\n\t\t// Try finding it a place in the tree.\n\t\tif ( this._checkAndSplitToAllowedPosition( node ) ) {\n\t\t\tthis._insert( node );\n\t\t}\n\t\t// Try autoparagraphing.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n\t * @param {Object} context\n\t */\n\t_handleDisallowedNode( node, context ) {\n\t\t// If the node is an element, try inserting its children (strip the parent).\n\t\tif ( node.is( 'element' ) ) {\n\t\t\tthis.handleNodes( node.getChildren(), context );\n\t\t}\n\t\t// If text is not allowed, try autoparagraphing it.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to insert.\n\t */\n\t_insert( node ) {\n\t\t/* istanbul ignore if */\n\t\tif ( !this.schema.checkChild( this.position, node ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\t\t\tlog.error(\n\t\t\t\t'insertcontent-wrong-position: The node cannot be inserted on the given position.',\n\t\t\t\t{ node, position: this.position }\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst livePos = LivePosition.createFromPosition( this.position );\n\n\t\tthis.writer.insert( node, this.position );\n\n\t\tthis.position = Position.createFromPosition( livePos );\n\t\tlivePos.detach();\n\n\t\t// The last inserted object should be selected because we can't put a collapsed selection after it.\n\t\tif ( this.schema.isObject( node ) && !this.schema.checkChild( this.position, '$text' ) ) {\n\t\t\tthis.nodeToSelect = node;\n\t\t} else {\n\t\t\tthis.nodeToSelect = null;\n\t\t}\n\n\t\tthis._filterAttributesOf.push( node );\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t */\n\t_mergeSiblingsOf( node, context ) {\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergeLeft = this._canMergeLeft( node, context );\n\t\tconst mergeRight = this._canMergeRight( node, context );\n\t\tconst mergePosLeft = LivePosition.createBefore( node );\n\t\tconst mergePosRight = LivePosition.createAfter( node );\n\n\t\tif ( mergeLeft ) {\n\t\t\tconst position = LivePosition.createFromPosition( this.position );\n\n\t\t\tthis.writer.merge( mergePosLeft );\n\n\t\t\tthis.position = Position.createFromPosition( position );\n\t\t\tposition.detach();\n\t\t}\n\n\t\tif ( mergeRight ) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif ( !this.position.isEqual( mergePosRight ) ) {\n\t\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t\t// At this point the insertion position should be after the node we'll merge. If it isn't,\n\t\t\t\t// it should need to be secured as in the left merge case.\n\t\t\t\tlog.error( 'insertcontent-wrong-position-on-merge: The insertion position should equal the merge position' );\n\t\t\t}\n\n\t\t\t// Move the position to the previous node, so it isn't moved to the graveyard on merge.\n\t\t\t// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\t\t\tthis.position = Position.createAt( mergePosRight.nodeBefore, 'end' );\n\n\t\t\t// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n\t\t\t// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\t\t\tconst position = new LivePosition( this.position.root, this.position.path, 'sticksToPrevious' );\n\n\t\t\tthis.writer.merge( mergePosRight );\n\n\t\t\tthis.position = Position.createFromPosition( position );\n\t\t\tposition.detach();\n\t\t}\n\n\t\tif ( mergeLeft || mergeRight ) {\n\t\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t\t// we need to mark the new container.\n\t\t\tthis._filterAttributesOf.push( this.position.parent );\n\t\t}\n\n\t\tmergePosLeft.detach();\n\t\tmergePosRight.detach();\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with previous sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t * @returns {Boolean}\n\t */\n\t_canMergeLeft( node, context ) {\n\t\tconst previousSibling = node.previousSibling;\n\n\t\treturn context.isFirst &&\n\t\t\t( previousSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( previousSibling ) &&\n\t\t\tthis.model.schema.checkMerge( previousSibling, node );\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with next sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t * @returns {Boolean}\n\t */\n\t_canMergeRight( node, context ) {\n\t\tconst nextSibling = node.nextSibling;\n\n\t\treturn context.isLast &&\n\t\t\t( nextSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( nextSibling ) &&\n\t\t\tthis.model.schema.checkMerge( node, nextSibling );\n\t}\n\n\t/**\n\t * Tries wrapping the node in a new paragraph and inserting it this way.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n\t * @param {Object} context\n\t */\n\t_tryAutoparagraphing( node, context ) {\n\t\tconst paragraph = this.writer.createElement( 'paragraph' );\n\n\t\t// Do not autoparagraph if the paragraph won't be allowed there,\n\t\t// cause that would lead to an infinite loop. The paragraph would be rejected in\n\t\t// the next _handleNode() call and we'd be here again.\n\t\tif ( this._getAllowedIn( paragraph, this.position.parent ) && this.schema.checkChild( paragraph, node ) ) {\n\t\t\tparagraph._appendChild( node );\n\t\t\tthis._handleNode( paragraph, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {Boolean} Whether an allowed position was found.\n\t * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n\t */\n\t_checkAndSplitToAllowedPosition( node ) {\n\t\tconst allowedIn = this._getAllowedIn( node, this.position.parent );\n\n\t\tif ( !allowedIn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\twhile ( allowedIn != this.position.parent ) {\n\t\t\t// If a parent which we'd need to leave is a limit element, break.\n\t\t\tif ( this.schema.isLimit( this.position.parent ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( this.position.isAtStart ) {\n\t\t\t\tconst parent = this.position.parent;\n\t\t\t\tthis.position = Position.createBefore( parent );\n\n\t\t\t\t// Special case – parent is empty (<p>^</p>) so isAtStart == isAtEnd == true.\n\t\t\t\t// We can remove the element after moving selection out of it.\n\t\t\t\tif ( parent.isEmpty ) {\n\t\t\t\t\tthis.writer.remove( parent );\n\t\t\t\t}\n\t\t\t} else if ( this.position.isAtEnd ) {\n\t\t\t\tthis.position = Position.createAfter( this.position.parent );\n\t\t\t} else {\n\t\t\t\tconst tempPos = Position.createAfter( this.position.parent );\n\n\t\t\t\tthis.writer.split( this.position );\n\n\t\t\t\tthis.position = tempPos;\n\n\t\t\t\tthis.canMergeWith.add( this.position.nodeAfter );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to check.\n\t * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getAllowedIn( node, element ) {\n\t\tif ( this.schema.checkChild( element, node ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\tif ( element.parent ) {\n\t\t\treturn this._getAllowedIn( node, element.parent );\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Position from '../position';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {module:engine/model/batch~Batch} batch Batch to which the deltas will be added.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst selRange = selection.getFirstRange();\n\t\tconst startPos = selRange.start;\n\t\tconst endPos = LivePosition.createFromPosition( selRange.end );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !selRange.start.isTouching( selRange.end ) ) {\n\t\t\twriter.remove( selRange );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPos, endPos );\n\n\t\t\t// TMP this will be replaced with a postifxer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPos.parent.getChildren(), writer );\n\t\t}\n\n\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\twriter.setSelection( startPos );\n\t\t} else {\n\t\t\tselection.setTo( startPos );\n\t\t}\n\n\t\t// 4. Autoparagraphing.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\tif ( shouldAutoparagraph( schema, startPos ) ) {\n\t\t\tinsertParagraph( writer, startPos, selection );\n\t\t}\n\n\t\tendPos.detach();\n\t} );\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPos, endPos ) {\n\tconst startParent = startPos.parent;\n\tconst endParent = endPos.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[]</p><p>{}y</p></$root> => <$root><p>xy</p>[]{}</$root>\n\tif ( startParent == endParent ) {\n\t\treturn;\n\t}\n\n\t// If one of the positions is a root, then there's nothing more to merge (at least in the current state of implementation).\n\t// Theoretically in this case we could unwrap the <p>: <$root>x[]<p>{}y</p></$root>, but we don't need to support it yet\n\t// so let's just abort.\n\tif ( !startParent.parent || !endParent.parent ) {\n\t\treturn;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endParent into startParent in this case:\n\t// <limit><startParent>x[]</startParent></limit><endParent>{}</endParent>\n\tif ( !checkCanBeMerged( startPos, endPos, writer.model.schema ) ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge. For example:\n\t// <a><b>x[]</b></a><c><d>{}y</d></c>\n\t// will become:\n\t// <a><b>xy</b>[]</a><c>{}</c>\n\tstartPos = Position.createAfter( startParent );\n\tendPos = Position.createBefore( endParent );\n\n\tif ( !endPos.isEqual( startPos ) ) {\n\t\t// In this case, before we merge, we need to move `endParent` to the `startPos`:\n\t\t// <a><b>x[]</b></a><c><d>{}y</d></c>\n\t\t// becomes:\n\t\t// <a><b>x</b>[]<d>y</d></a><c>{}</c>\n\t\twriter.insert( endParent, startPos );\n\t}\n\n\t// Merge two siblings:\n\t// <a>x</a>[]<b>y</b> -> <a>xy</a> (the usual case)\n\t// <a><b>x</b>[]<d>y</d></a><c></c> -> <a><b>xy</b>[]</a><c></c> (this is the \"move parent\" case shown above)\n\twriter.merge( startPos );\n\n\t// Remove empty end ancestors:\n\t// <a>fo[o</a><b><a><c>bar]</c></a></b>\n\t// becomes:\n\t// <a>fo[]</a><b><a>{}</a></b>\n\t// So we can remove <a> and <b>.\n\twhile ( endPos.parent.isEmpty ) {\n\t\tconst parentToRemove = endPos.parent;\n\n\t\tendPos = Position.createBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Continue merging next level.\n\tmergeBranches( writer, startPos, endPos );\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction checkCanBeMerged( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( paragraph, 0 );\n\t} else {\n\t\tselection.setTo( paragraph, 0 );\n\t}\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( Range.createIn( limitElement ) );\n\tinsertParagraph( writer, Position.createAt( limitElement ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\n\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\n\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n */\nexport default function modifySelection( model, selection, options = {} ) {\n\tconst schema = model.schema;\n\tconst isForward = options.direction != 'backward';\n\tconst unit = options.unit ? options.unit : 'character';\n\n\tconst focus = selection.focus;\n\n\tconst walker = new TreeWalker( {\n\t\tboundaries: getSearchRange( focus, isForward ),\n\t\tsingleCharacters: true,\n\t\tdirection: isForward ? 'forward' : 'backward'\n\t} );\n\n\tconst data = { walker, schema, isForward, unit };\n\n\tlet next;\n\n\twhile ( ( next = walker.next() ) ) {\n\t\tif ( next.done ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = tryExtendingTo( data, next.value );\n\n\t\tif ( position ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelectionFocus( position );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tselection.setFocus( position );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\nfunction tryExtendingTo( data, value ) {\n\t// If found text, we can certainly put the focus in it. Let's just find a correct position\n\t// based on the unit.\n\tif ( value.type == 'text' ) {\n\t\tif ( data.unit === 'word' ) {\n\t\t\treturn getCorrectWordBreakPosition( data.walker, data.isForward );\n\t\t}\n\n\t\treturn getCorrectPosition( data.walker, data.unit, data.isForward );\n\t}\n\n\t// Entering an element.\n\tif ( value.type == ( data.isForward ? 'elementStart' : 'elementEnd' ) ) {\n\t\t// If it's an object, we can select it now.\n\t\tif ( data.schema.isObject( value.item ) ) {\n\t\t\treturn Position.createAt( value.item, data.isForward ? 'after' : 'before' );\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( data.schema.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\treturn value.nextPosition;\n\t\t}\n\t}\n\t// Leaving an element.\n\telse {\n\t\t// If leaving a limit element, stop.\n\t\tif ( data.schema.isLimit( value.item ) ) {\n\t\t\t// NOTE: Fast-forward the walker until the end.\n\t\t\tdata.walker.skip( () => true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( data.schema.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\treturn value.nextPosition;\n\t\t}\n\t}\n}\n\n// Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\nfunction getCorrectPosition( walker, unit ) {\n\tconst textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile ( isInsideSurrogatePair( data, offset ) || ( unit == 'character' && isInsideCombinedSymbol( data, offset ) ) ) {\n\t\t\twalker.next();\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\n// Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction getCorrectWordBreakPosition( walker, isForward ) {\n\tlet textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile ( !isAtWordBoundary( textNode.data, offset, isForward ) && !isAtNodeBoundary( textNode, offset, isForward ) ) {\n\t\t\twalker.next();\n\n\t\t\t// Check of adjacent text nodes with different attributes (like BOLD).\n\t\t\t// Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n\t\t\t// should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\t\t\tconst nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;\n\n\t\t\t// Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\t\t\tif ( nextNode && nextNode.is( 'text' ) ) {\n\t\t\t\t// Check boundary char of an adjacent text node.\n\t\t\t\tconst boundaryChar = nextNode.data.charAt( isForward ? 0 : nextNode.data.length - 1 );\n\n\t\t\t\t// Go to the next node if the character at the boundary of that node belongs to the same word.\n\t\t\t\tif ( !wordBoundaryCharacters.includes( boundaryChar ) ) {\n\t\t\t\t\t// If adjacent text node belongs to the same word go to it & reset values.\n\t\t\t\t\twalker.next();\n\n\t\t\t\t\ttextNode = walker.position.textNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\nfunction getSearchRange( start, isForward ) {\n\tconst root = start.root;\n\tconst searchEnd = Position.createAt( root, isForward ? 'end' : 0 );\n\n\tif ( isForward ) {\n\t\treturn new Range( start, searchEnd );\n\t} else {\n\t\treturn new Range( searchEnd, start );\n\t}\n}\n\n// Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtWordBoundary( data, offset, isForward ) {\n\t// The offset to check depends on direction.\n\tconst offsetToCheck = offset + ( isForward ? 0 : -1 );\n\n\treturn wordBoundaryCharacters.includes( data.charAt( offsetToCheck ) );\n}\n\n// Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtNodeBoundary( textNode, offset, isForward ) {\n\treturn offset === ( isForward ? textNode.endOffset : 0 );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/utils/getselectedcontent\n */\n\nimport Range from '../range';\nimport Position from '../position';\n\n/**\n * Gets a clone of the selected content.\n *\n * For example, for the following selection:\n *\n * ```html\n * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n * ```\n *\n * It will return a document fragment with such a content:\n *\n * ```html\n * <quote><h>st</h></quote><p>se</p>\n * ```\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection of which content will be returned.\n * @returns {module:engine/model/documentfragment~DocumentFragment}\n */\nexport default function getSelectedContent( model, selection ) {\n\treturn model.change( writer => {\n\t\tconst frag = writer.createDocumentFragment();\n\t\tconst range = selection.getFirstRange();\n\n\t\tif ( !range || range.isCollapsed ) {\n\t\t\treturn frag;\n\t\t}\n\n\t\tconst root = range.start.root;\n\t\tconst commonPath = range.start.getCommonPath( range.end );\n\t\tconst commonParent = root.getNodeByPath( commonPath );\n\n\t\t// ## 1st step\n\t\t//\n\t\t// First, we'll clone a fragment represented by a minimal flat range\n\t\t// containing the original range to be cloned.\n\t\t// E.g. let's consider such a range:\n\t\t//\n\t\t// <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n\t\t//\n\t\t// A minimal flat range containing this one is:\n\t\t//\n\t\t// <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>\n\t\t//\n\t\t// We can easily clone this structure, preserving e.g. the <quote> element.\n\t\tlet flatSubtreeRange;\n\n\t\tif ( range.start.parent == range.end.parent ) {\n\t\t\t// The original range is flat, so take it.\n\t\t\tflatSubtreeRange = range;\n\t\t} else {\n\t\t\tflatSubtreeRange = Range.createFromParentsAndOffsets(\n\t\t\t\tcommonParent, range.start.path[ commonPath.length ],\n\t\t\t\tcommonParent, range.end.path[ commonPath.length ] + 1\n\t\t\t);\n\t\t}\n\n\t\tconst howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;\n\n\t\t// Clone the whole contents.\n\t\tfor ( const item of flatSubtreeRange.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'textProxy' ) ) {\n\t\t\t\twriter.appendText( item.data, item.getAttributes(), frag );\n\t\t\t} else {\n\t\t\t\twriter.append( item._clone( true ), frag );\n\t\t\t}\n\t\t}\n\n\t\t// ## 2nd step\n\t\t//\n\t\t// If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.\n\t\t//\n\t\t// For example, for the range shown in the 1st step comment, we need to remove these pieces:\n\t\t//\n\t\t// <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>\n\t\t//\n\t\t// So this will be the final copied content:\n\t\t//\n\t\t// <quote><h>st</h></quote><p>se</p>\n\t\t//\n\t\t// In order to do that, we remove content from these two ranges:\n\t\t//\n\t\t// [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]\n\t\tif ( flatSubtreeRange != range ) {\n\t\t\t// Find the position of the original range in the cloned fragment.\n\t\t\tconst newRange = range._getTransformedByMove( flatSubtreeRange.start, Position.createAt( frag, 0 ), howMany )[ 0 ];\n\n\t\t\tconst leftExcessRange = new Range( Position.createAt( frag ), newRange.start );\n\t\t\tconst rightExcessRange = new Range( newRange.end, Position.createAt( frag, 'end' ) );\n\n\t\t\tremoveRangeContent( rightExcessRange, writer );\n\t\t\tremoveRangeContent( leftExcessRange, writer );\n\t\t}\n\n\t\treturn frag;\n\t} );\n}\n\n// After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,\n// this function will, most likely, be able to rewritten using getMinimalFlatRanges().\nfunction removeRangeContent( range, writer ) {\n\tconst parentsToCheck = [];\n\n\tArray.from( range.getItems( { direction: 'backward' } ) )\n\t\t// We should better store ranges because text proxies will lose integrity\n\t\t// with the text nodes when we'll start removing content.\n\t\t.map( item => Range.createOn( item ) )\n\t\t// Filter only these items which are fully contained in the passed range.\n\t\t//\n\t\t// E.g. for the following range: [<quote><p>y</p><h>fir]st</h>\n\t\t// the walker will return the entire <h> element, when only the \"fir\" item inside it is fully contained.\n\t\t.filter( itemRange => {\n\t\t\t// We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.\n\t\t\tconst contained =\n\t\t\t\t( itemRange.start.isAfter( range.start ) || itemRange.start.isEqual( range.start ) ) &&\n\t\t\t\t( itemRange.end.isBefore( range.end ) || itemRange.end.isEqual( range.end ) );\n\n\t\t\treturn contained;\n\t\t} )\n\t\t.forEach( itemRange => {\n\t\t\tparentsToCheck.push( itemRange.start.parent );\n\n\t\t\twriter.remove( itemRange );\n\t\t} );\n\n\t// Remove ancestors of the removed items if they turned to be empty now\n\t// (their whole content was contained in the range).\n\tparentsToCheck.forEach( parentToCheck => {\n\t\tlet parent = parentToCheck;\n\n\t\twhile ( parent.parent && parent.isEmpty ) {\n\t\t\tconst removeRange = Range.createOn( parent );\n\n\t\t\tparent = parent.parent;\n\n\t\t\twriter.remove( removeRange );\n\t\t}\n\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\n\nimport Range from '../range';\nimport Position from '../position';\n\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isObject object elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><image></image>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport function injectSelectionPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => selectionPostFixer( writer, model ) );\n}\n\n// The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction selectionPostFixer( writer, model ) {\n\tconst selection = model.document.selection;\n\tconst schema = model.schema;\n\n\tconst ranges = [];\n\n\tlet wasFixed = false;\n\n\tfor ( const modelRange of selection.getRanges() ) {\n\t\t// Go through all ranges in selection and try fixing each of them.\n\t\t// Those ranges might overlap but will be corrected later.\n\t\tconst correctedRange = tryFixingRange( modelRange, schema );\n\n\t\tif ( correctedRange ) {\n\t\t\tranges.push( correctedRange );\n\t\t\twasFixed = true;\n\t\t} else {\n\t\t\tranges.push( modelRange );\n\t\t}\n\t}\n\n\t// If any of ranges were corrected update the selection.\n\tif ( wasFixed ) {\n\t\t// The above algorithm might create ranges that intersects each other when selection contains more then one range.\n\t\t// This is case happens mostly on Firefox which creates multiple ranges for selected table.\n\t\tlet fixedRanges = ranges;\n\n\t\t// Fixing selection with many ranges usually breaks the selection in Firefox. As only Firefox supports multiple selection ranges\n\t\t// we simply create one continuous range from fixed selection ranges (even if they are not adjacent).\n\t\tif ( ranges.length > 1 ) {\n\t\t\tconst selectionStart = ranges[ 0 ].start;\n\t\t\tconst selectionEnd = ranges[ ranges.length - 1 ].end;\n\n\t\t\tfixedRanges = [ new Range( selectionStart, selectionEnd ) ];\n\t\t}\n\n\t\twriter.setSelection( fixedRanges, { backward: selection.isBackward } );\n\t}\n}\n\n// Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingRange( range, schema ) {\n\tif ( range.isCollapsed ) {\n\t\treturn tryFixingCollapsedRange( range, schema );\n\t}\n\n\treturn tryFixingNonCollapsedRage( range, schema );\n}\n\n// Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingCollapsedRange( range, schema ) {\n\tconst originalPosition = range.start;\n\n\tconst nearestSelectionRange = schema.getNearestSelectionRange( originalPosition );\n\n\t// This might be null ie when editor data is empty.\n\t// In such cases there is no need to fix the selection range.\n\tif ( !nearestSelectionRange ) {\n\t\treturn null;\n\t}\n\n\tconst fixedPosition = nearestSelectionRange.start;\n\n\t// Fixed position is the same as original - no need to return corrected range.\n\tif ( originalPosition.isEqual( fixedPosition ) ) {\n\t\treturn null;\n\t}\n\n\t// Check single node selection (happens in tables).\n\tif ( fixedPosition.nodeAfter && schema.isLimit( fixedPosition.nodeAfter ) ) {\n\t\treturn new Range( fixedPosition, Position.createAfter( fixedPosition.nodeAfter ) );\n\t}\n\n\treturn new Range( fixedPosition );\n}\n\n// Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingNonCollapsedRage( range, schema ) {\n\tconst start = range.start;\n\tconst end = range.end;\n\n\tconst isTextAllowedOnStart = schema.checkChild( start, '$text' );\n\tconst isTextAllowedOnEnd = schema.checkChild( end, '$text' );\n\n\tconst startLimitElement = schema.getLimitElement( start );\n\tconst endLimitElement = schema.getLimitElement( end );\n\n\t// Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\tif ( startLimitElement === endLimitElement ) {\n\t\t// Range is valid when both position allows to place a text:\n\t\t// - <block>f[oobarba]z</block>\n\t\t// This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n\t\tif ( isTextAllowedOnStart && isTextAllowedOnEnd ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n\t\t// - [<block>foo</block>]    ->    <block>[foo]</block>\n\t\t// - [<block>foo]</block>    ->    <block>[foo]</block>\n\t\t// - <block>f[oo</block>]    ->    <block>f[oo]</block>\n\t\tif ( checkSelectionOnNonLimitElements( start, end, schema ) ) {\n\t\t\tconst fixedStart = schema.getNearestSelectionRange( start, 'forward' );\n\t\t\tconst fixedEnd = schema.getNearestSelectionRange( end, 'backward' );\n\n\t\t\treturn new Range( fixedStart ? fixedStart.start : start, fixedEnd ? fixedEnd.start : end );\n\t\t}\n\t}\n\n\tconst isStartInLimit = startLimitElement && !startLimitElement.is( 'rootElement' );\n\tconst isEndInLimit = endLimitElement && !endLimitElement.is( 'rootElement' );\n\n\t// At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n\t// then the range crossed limit element boundaries and needs to be fixed.\n\tif ( isStartInLimit || isEndInLimit ) {\n\t\t// Although we've already found limit element on start/end positions we must find the outer-most limit element.\n\t\t// as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\t\tconst fixedStart = isStartInLimit ? expandSelectionOnIsLimitNode( Position.createAt( startLimitElement ), schema, 'start' ) : start;\n\t\tconst fixedEnd = isEndInLimit ? expandSelectionOnIsLimitNode( Position.createAt( endLimitElement ), schema, 'end' ) : end;\n\n\t\treturn new Range( fixedStart, fixedEnd );\n\t}\n\n\t// Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\treturn null;\n}\n\n// Expands selection so it contains whole limit node.\n//\n// @param {module:engine/model/position~Position} position\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/position~Position}\nfunction expandSelectionOnIsLimitNode( position, schema, expandToDirection ) {\n\tlet node = position.parent;\n\tlet parent = node;\n\n\t// Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\twhile ( schema.isLimit( parent ) && parent.parent ) {\n\t\tnode = parent;\n\t\tparent = parent.parent;\n\t}\n\n\t// Depending on direction of expanding selection return position before or after found node.\n\treturn expandToDirection === 'start' ? Position.createBefore( node ) : Position.createAfter( node );\n}\n\n// Checks whether both range ends are placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\nfunction checkSelectionOnNonLimitElements( start, end, schema ) {\n\tconst startIsOnBlock = ( start.nodeAfter && !schema.isLimit( start.nodeAfter ) ) || schema.checkChild( start, '$text' );\n\tconst endIsOnBlock = ( end.nodeBefore && !schema.isLimit( end.nodeBefore ) ) || schema.checkChild( end, '$text' );\n\n\treturn startIsOnBlock && endIsOnBlock;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/model/model\n */\n\n// Load all basic deltas and transformations, they register themselves.\nimport './delta/basic-deltas';\nimport './delta/basic-transformations';\n\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport deltaTransform from './delta/transform';\nimport ModelElement from './element';\nimport ModelRange from './range';\n\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model {\n\tconstructor() {\n\t\t/**\n\t\t * Model's marker collection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis.markers = new MarkerCollection();\n\n\t\t/**\n\t\t * Model's document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis.document = new Document( this );\n\n\t\t/**\n\t\t * Model's schema.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/schema~Schema}\n\t\t */\n\t\tthis.schema = new Schema();\n\n\t\t/**\n\t\t * All callbacks added by {@link module:engine/model/model~Model#change} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Function>}\n\t\t */\n\t\tthis._pendingChanges = [];\n\n\t\t/**\n\t\t * The last created and currently used writer instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/writer~Writer}\n\t\t */\n\t\tthis._currentWriter = null;\n\n\t\t[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation' ]\n\t\t\t.forEach( methodName => this.decorate( methodName ) );\n\n\t\t// Adding operation validation with `highest` priority, so it is called before any other feature would like\n\t\t// to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\t\tthis.on( 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\toperation._validate();\n\t\t}, { priority: 'highest' } );\n\n\t\t// Register some default abstract entities.\n\t\tthis.schema.register( '$root', {\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.register( '$block', {\n\t\t\tallowIn: '$root',\n\t\t\tisBlock: true\n\t\t} );\n\t\tthis.schema.register( '$text', {\n\t\t\tallowIn: '$block'\n\t\t} );\n\t\tthis.schema.register( '$clipboardHolder', {\n\t\t\tallowContentOf: '$root',\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.extend( '$text', { allowIn: '$clipboardHolder' } );\n\n\t\t// Element needed by `upcastElementToMarker` converter.\n\t\t// This element temporarily represents marker bound during conversion process and is removed\n\t\t// at the end of conversion. `UpcastDispatcher` or at least `Conversion` class looks like a better for this\n\t\t// registration but both know nothing about Schema.\n\t\tthis.schema.register( '$marker', {\n\t\t\tallowIn: [ '$root', '$block' ]\n\t\t} );\n\n\t\tinjectSelectionPostFixer( this );\n\t}\n\n\t/**\n\t * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n\t * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n\t * the {@link module:engine/model/document~Document#selection document's selection}, and\n\t * {@link module:engine/model/model~Model#markers model markers}.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n\t * into a single undo step.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n\t *\n\t *\t\t\tmodel.change( writer => {\n\t *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n\t *\t\t} );\n\t *\n\t * The callback of the `change()` block is executed synchronously.\n\t *\n\t * You can also return a value from the change block.\n\t *\n\t *\t\tconst img = model.change( writer => {\n\t *\t\t\treturn writer.createElement( 'img' );\n\t *\t\t} );\n\t *\n\t * @see #enqueueChange\n\t * @param {Function} callback Callback function which may modify the model.\n\t * @returns {*} Value returned by the callback.\n\t */\n\tchange( callback ) {\n\t\tif ( this._pendingChanges.length === 0 ) {\n\t\t\t// If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n\t\t\tthis._pendingChanges.push( { batch: new Batch(), callback } );\n\n\t\t\treturn this._runPendingChanges()[ 0 ];\n\t\t} else {\n\t\t\t// If this is not the outermost block, just execute the callback.\n\t\t\treturn callback( this._currentWriter );\n\t\t}\n\t}\n\n\t/**\n\t * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n\t *\n\t * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n\t * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n\t * it will be delayed and executed after the outermost block.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconsole.log( 1 );\n\t *\n\t *\t\t\tmodel.enqueueChange( writer => {\n\t *\t\t\t\tconsole.log( 2 );\n\t *\t\t\t} );\n\t *\n\t * \t\t\tconsole.log( 3 );\n\t *\t\t} ); // Will log: 1, 3, 2.\n\t *\n\t * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n\t * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n\t * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n\t *\n\t * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n\t *\n\t *\t\tmodel.enqueueChange( batch, writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * The batch instance can be obtained from {@link module:engine/model/writer~Writer#batch the writer}.\n\t *\n\t * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n\t * If not defined, a new batch will be created.\n\t * @param {Function} callback Callback function which may modify the model.\n\t */\n\tenqueueChange( batchOrType, callback ) {\n\t\tif ( typeof batchOrType === 'string' ) {\n\t\t\tbatchOrType = new Batch( batchOrType );\n\t\t} else if ( typeof batchOrType == 'function' ) {\n\t\t\tcallback = batchOrType;\n\t\t\tbatchOrType = new Batch();\n\t\t}\n\n\t\tthis._pendingChanges.push( { batch: batchOrType, callback } );\n\n\t\tif ( this._pendingChanges.length == 1 ) {\n\t\t\tthis._runPendingChanges();\n\t\t}\n\t}\n\n\t/**\n\t * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function to apply\n\t * {@link module:engine/model/operation/operation~Operation operations} on the model.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to apply\n\t */\n\tapplyOperation( operation ) {\n\t\toperation._execute();\n\t}\n\n\t/**\n\t * Transforms two sets of deltas by themselves. Returns both transformed sets.\n\t *\n\t * @param {Array.<module:engine/model/delta/delta~Delta>} deltasA Array with the first set of deltas to transform. These\n\t * deltas are considered more important (than `deltasB`) when resolving conflicts.\n\t * @param {Array.<module:engine/model/delta/delta~Delta>} deltasB Array with the second set of deltas to transform. These\n\t * deltas are considered less important (than `deltasA`) when resolving conflicts.\n\t * @param {Boolean} [useContext=false] When set to `true`, transformation will store and use additional context\n\t * information to guarantee more expected results. Should be used whenever deltas related to already applied\n\t * deltas are transformed (for example when undoing changes).\n\t * @returns {Object}\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasA The first set of deltas transformed\n\t * by the second set of deltas.\n\t * @returns {Array.<module:engine/model/delta/delta~Delta>} return.deltasB The second set of deltas transformed\n\t * by the first set of deltas.\n\t */\n\ttransformDeltas( deltasA, deltasB, useContext = false ) {\n\t\treturn deltaTransform.transformDeltaSets( deltasA, deltasB, useContext ? this.document : null );\n\t}\n\n\t/**\n\t * Inserts content into the editor (specified selection) as one would expect the paste\n\t * functionality to work.\n\t *\n\t * @fires insertContent\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection into which the content should be inserted.\n\t */\n\tinsertContent( content, selection ) {\n\t\tinsertContent( this, content, selection );\n\t}\n\n\t/**\n\t * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n\t *\n\t * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n\t * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n\t * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n\t * then that behavior should be implemented in the view's listener. At the same time, the table feature\n\t * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n\t * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n\t * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n\t *\n\t * @fires deleteContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection of which the content should be deleted.\n\t * @param {module:engine/model/batch~Batch} batch Batch to which the deltas will be added.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n\t *\n\t * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n\t *\n\t * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n\t * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n\t *\n\t * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n\t * elements will not be merged.\n\t *\n\t * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n\t * paragraph when the entire content was selected.\n\t *\n\t * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n\t *\n\t * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n\t * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`)\n\t */\n\tdeleteContent( selection, options ) {\n\t\tdeleteContent( this, selection, options );\n\t}\n\n\t/**\n\t * Modifies the selection. Currently, the supported modifications are:\n\t *\n\t * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n\t * Possible values for `unit` are:\n\t *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n\t *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n\t *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n\t *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n\t *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n\t *  why `'character'` value is most natural and common method of modifying selection.\n\t *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n\t *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n\t *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n\t *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n\t *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n\t *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n\t *  extension will include whole \"surrogate pair\".\n\t *  * `'word'` - moves selection by a whole word.\n\t *\n\t * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n\t *\n\t * @fires modifySelection\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection to modify.\n\t * @param {Object} [options]\n\t * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n\t */\n\tmodifySelection( selection, options ) {\n\t\tmodifySelection( this, selection, options );\n\t}\n\n\t/**\n\t * Gets a clone of the selected content.\n\t *\n\t * For example, for the following selection:\n\t *\n\t * ```html\n\t * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>\n\t * ```\n\t *\n\t * It will return a document fragment with such a content:\n\t *\n\t * ```html\n\t * <quote><h>st</h></quote><p>se</p>\n\t * ```\n\t *\n\t * @fires getSelectedContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection of which content will be returned.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetSelectedContent( selection ) {\n\t\treturn getSelectedContent( this, selection );\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/range~Range range} or {@link module:engine/model/element~Element element}\n\t * has any content.\n\t *\n\t * Content is any text node or element which is registered in {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n\t * @returns {Boolean}\n\t */\n\thasContent( rangeOrElement ) {\n\t\tif ( rangeOrElement instanceof ModelElement ) {\n\t\t\trangeOrElement = ModelRange.createIn( rangeOrElement );\n\t\t}\n\n\t\tif ( rangeOrElement.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const item of rangeOrElement.getItems() ) {\n\t\t\t// Remember, `TreeWalker` returns always `textProxy` nodes.\n\t\t\tif ( item.is( 'textProxy' ) || this.schema.isObject( item ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n\t */\n\tdestroy() {\n\t\tthis.document.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n\t * which calls callbacks and returns array of values returned by these callbacks.\n\t *\n\t * @private\n\t * @returns {Array.<*>} Array of values returned by callbacks.\n\t */\n\t_runPendingChanges() {\n\t\tconst ret = [];\n\n\t\twhile ( this._pendingChanges.length ) {\n\t\t\t// Create a new writer using batch instance created for this chain of changes.\n\t\t\tconst currentBatch = this._pendingChanges[ 0 ].batch;\n\t\t\tthis._currentWriter = new Writer( this, currentBatch );\n\n\t\t\t// Execute changes callback and gather the returned value.\n\t\t\tconst callbackReturnValue = this._pendingChanges[ 0 ].callback( this._currentWriter );\n\t\t\tret.push( callbackReturnValue );\n\n\t\t\t// Fire internal `_change` event.\n\t\t\tthis.fire( '_change', this._currentWriter );\n\n\t\t\tthis._pendingChanges.shift();\n\t\t\tthis._currentWriter = null;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Fired after leaving each {@link module:engine/model/model~Model#enqueueChange} block or outermost\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * **Note:** This is an internal event! Use {@link module:engine/model/document~Document#event:change} instead.\n\t *\n\t * @protected\n\t * @event _change\n\t * @param {module:engine/model/writer~Writer} writer `Writer` instance that has been used in the change block.\n\t */\n\n\t/**\n\t * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n\t * using {@link #applyOperation}.\n\t *\n\t * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n\t * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n\t * be used.\n\t *\n\t * A few callbacks are already added to this event by engine internal classes:\n\t *\n\t * * with `highest` priority operation is validated,\n\t * * with `normal` priority operation is executed,\n\t * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n\t * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n\t * update themselves.\n\t *\n\t * @event applyOperation\n\t * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t */\n\n\t/**\n\t * Event fired when {@link #insertContent} method is called.\n\t *\n\t * The {@link #insertContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event insertContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #deleteContent} method is called.\n\t *\n\t * The {@link #deleteContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event deleteContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #modifySelection} method is called.\n\t *\n\t * The {@link #modifySelection default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event modifySelection\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #getSelectedContent} method is called.\n\t *\n\t * The {@link #getSelectedContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event getSelectedContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n}\n\nmix( Model, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/keystrokehandler\n */\n\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n\n/**\n * Keystroke handler registers keystrokes so the callbacks associated\n * with these keystrokes will be executed if the matching `keydown` is fired\n * by a defined emitter.\n *\n *\t\tconst handler = new KeystrokeHandler();\n *\n *\t\thandler.listenTo( emitter );\n *\n *\t\thandler.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n */\nexport default class KeystrokeHandler {\n\t/**\n\t * Creates an instance of the keystroke handler.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Listener used to listen to events for easier keystroke handler destruction.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/dom/emittermixin~Emitter}\n\t\t */\n\t\tthis._listener = Object.create( DomEmitterMixin );\n\t}\n\n\t/**\n\t * Starts listening for `keydown` events from a given emitter.\n\t *\n\t * @param {module:utils/emittermixin~Emitter} emitter\n\t */\n\tlistenTo( emitter ) {\n\t\t// The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n\t\t// keystroke so the listeners can be attached to them with different priorities.\n\t\t//\n\t\t// E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n\t\t// as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n\t\t// method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n\t\t// only with other listeners of this particular event, thus making it possible to prioritize\n\t\t// the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n\t\t// the KeystrokeHandler re–uses it to do its job.\n\t\tthis._listener.listenTo( emitter, 'keydown', ( evt, keyEvtData ) => {\n\t\t\tthis._listener.fire( '_keydown:' + getCode( keyEvtData ), keyEvtData );\n\t\t} );\n\t}\n\n\t/**\n\t * Registers a handler for the specified keystroke.\n\t *\n\t * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n\t * the {@link module:utils/keyboard~parseKeystroke} function.\n\t * @param {Function} callback A function called with the\n\t * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n\t * a helper to both `preventDefault` and `stopPropagation` of the event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n\t * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n\t * are called in the order they were added.\n\t */\n\tset( keystroke, callback, options = {} ) {\n\t\tconst keyCode = parseKeystroke( keystroke );\n\t\tconst priority = options.priority;\n\n\t\t// Execute the passed callback on KeystrokeHandler#_keydown.\n\t\t// TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n\t\tthis._listener.listenTo( this._listener, '_keydown:' + keyCode, ( evt, keyEvtData ) => {\n\t\t\tcallback( keyEvtData, () => {\n\t\t\t\t// Stop the event in the DOM: no listener in the web page\n\t\t\t\t// will be triggered by this event.\n\t\t\t\tkeyEvtData.preventDefault();\n\t\t\t\tkeyEvtData.stopPropagation();\n\n\t\t\t\t// Stop the event in the KeystrokeHandler: no more callbacks\n\t\t\t\t// will be executed for this keystroke.\n\t\t\t\tevt.stop();\n\t\t\t} );\n\n\t\t\t// Mark this keystroke as handled by the callback. See: #press.\n\t\t\tevt.return = true;\n\t\t}, { priority } );\n\t}\n\n\t/**\n\t * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n\t *\n\t * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n\t * @returns {Boolean} Whether the keystroke was handled.\n\t */\n\tpress( keyEvtData ) {\n\t\treturn !!this._listener.fire( '_keydown:' + getCode( keyEvtData ), keyEvtData );\n\t}\n\n\t/**\n\t * Destroys the keystroke handler.\n\t */\n\tdestroy() {\n\t\tthis._listener.stopListening();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/editingkeystrokehandler\n */\n\nimport KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';\n\n/**\n * A keystroke handler for editor editing. Its instance is available\n * in {@link module:core/editor/editor~Editor#keystrokes} so plugins\n * can register their keystrokes.\n *\n * E.g. an undo plugin would do this:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+Z', 'undo' );\n *\t\teditor.keystrokes.set( 'Ctrl+Shift+Z', 'redo' );\n *\t\teditor.keystrokes.set( 'Ctrl+Y', 'redo' );\n *\n * @extends utils/keystrokehandler~KeystrokeHandler\n */\nexport default class EditingKeystrokeHandler extends KeystrokeHandler {\n\t/**\n\t * Creates an instance of the keystroke handler.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t */\n\tconstructor( editor ) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The editor instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor}\n\t\t */\n\t\tthis.editor = editor;\n\t}\n\n\t/**\n\t * Registers a handler for the specified keystroke.\n\t *\n\t * The handler can be specified as a command name or a callback.\n\t *\n\t * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n\t * the {@link module:utils/keyboard~parseKeystroke} function.\n\t * @param {Function|String} callback If a string is passed, then the keystroke will\n\t * {@link module:core/editor/editor~Editor#execute execute a command}.\n\t * If a function, then it will be called with the\n\t * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n\t * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.\n\t * @param {Object} [options={}] Additional options.\n\t * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n\t * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n\t * are called in the order they were added.\n\t */\n\tset( keystroke, callback, options = {} ) {\n\t\tif ( typeof callback == 'string' ) {\n\t\t\tconst commandName = callback;\n\n\t\t\tcallback = ( evtData, cancel ) => {\n\t\t\t\tthis.editor.execute( commandName );\n\t\t\t\tcancel();\n\t\t\t};\n\t\t}\n\n\t\tsuper.set( keystroke, callback, options );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/editor/editor\n */\n\nimport Config from '@ckeditor/ckeditor5-utils/src/config';\nimport EditingController from '@ckeditor/ckeditor5-engine/src/controller/editingcontroller';\nimport PluginCollection from '../plugincollection';\nimport CommandCollection from '../commandcollection';\nimport Locale from '@ckeditor/ckeditor5-utils/src/locale';\nimport DataController from '@ckeditor/ckeditor5-engine/src/controller/datacontroller';\nimport Conversion from '@ckeditor/ckeditor5-engine/src/conversion/conversion';\nimport Model from '@ckeditor/ckeditor5-engine/src/model/model';\nimport EditingKeystrokeHandler from '../editingkeystrokehandler';\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Class representing a basic, generic editor.\n *\n * Check out the list of its subclasses to learn about specific editor implementations.\n *\n * All editor implementations (like {@link module:editor-classic/classiceditor~ClassicEditor} or\n * {@link module:editor-inline/inlineeditor~InlineEditor}) should extend this class. They can add their\n * own methods and properties.\n *\n * When you are implementing a plugin, then this editor represents the API\n * which your plugin can expect to get when using its {@link module:core/plugin~Plugin#editor} property.\n *\n * This API should be sufficient in order to implement the \"editing\" part of your feature\n * (schema definition, conversion, commands, keystrokes, etc.).\n * It does not define the editor UI, which is available only if the\n * the specific editor implements also the {@link module:core/editor/editorwithui~EditorWithUI} interface\n * (as most editor implementations do).\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Editor {\n\t/**\n\t * Creates a new instance of the Editor class.\n\t *\n\t * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.\n\t *\n\t * @param {Object} config The editor config.\n\t */\n\tconstructor( config ) {\n\t\tconst availablePlugins = this.constructor.builtinPlugins;\n\n\t\t/**\n\t\t * Holds all configurations specific to this editor instance.\n\t\t *\n\t\t *\t\teditor.config.get( 'image.toolbar' );\n\t\t *\t\t// -> [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/config~Config}\n\t\t */\n\t\tthis.config = new Config( config, this.constructor.defaultConfig );\n\n\t\tthis.config.define( 'plugins', availablePlugins );\n\n\t\t/**\n\t\t * The plugins loaded and in use by this editor instance.\n\t\t *\n\t\t *\t\teditor.plugins.get( 'Clipboard' ); // -> instance of the Clipboard plugin.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/plugincollection~PluginCollection}\n\t\t */\n\t\tthis.plugins = new PluginCollection( this, availablePlugins );\n\n\t\t/**\n\t\t * Commands registered to the editor.\n\t\t *\n\t\t * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:\n\t\t *\n\t\t *\t\t// Execute the bold command:\n\t\t *\t\teditor.execute( 'bold' );\n\t\t *\n\t\t *\t\t// Check the state of the bold command:\n\t\t *\t\teditor.commands.get( 'bold' ).value;\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/commandcollection~CommandCollection}\n\t\t */\n\t\tthis.commands = new CommandCollection();\n\n\t\t/**\n\t\t * @readonly\n\t\t * @member {module:utils/locale~Locale}\n\t\t */\n\t\tthis.locale = new Locale( this.config.get( 'language' ) );\n\n\t\t/**\n\t\t * Shorthand for {@link module:utils/locale~Locale#t}.\n\t\t *\n\t\t * @see module:utils/locale~Locale#t\n\t\t * @method #t\n\t\t */\n\t\tthis.t = this.locale.t;\n\n\t\t/**\n\t\t * Indicates the editor life-cycle state.\n\t\t *\n\t\t * The editor is in one of the following states:\n\t\t *\n\t\t * * `initializing` - during the editor initialization (before {@link module:core/editor/editor~Editor.create `Editor.create()`})\n\t\t * finished its job,\n\t\t * * `ready` - after the promise returned by the {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t * method is resolved,\n\t\t * * `destroyed` - once the {@link #destroy `editor.destroy()`} method was called.\n\t\t *\n\t\t * @observable\n\t\t * @member {'initializing'|'ready'|'destroyed'} #state\n\t\t */\n\t\tthis.set( 'state', 'initializing' );\n\t\tthis.once( 'ready', () => ( this.state = 'ready' ), { priority: 'high' } );\n\t\tthis.once( 'destroy', () => ( this.state = 'destroyed' ), { priority: 'high' } );\n\n\t\t/**\n\t\t * Defines whether this editor is in read-only mode.\n\t\t *\n\t\t * In read-only mode the editor {@link #commands commands} are disabled so it is not possible\n\t\t * to modify document by using them.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * The editor's model.\n\t\t *\n\t\t * The central point of the editor's abstract data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = new Model();\n\n\t\t/**\n\t\t * The {@link module:engine/controller/datacontroller~DataController data controller}.\n\t\t * Used e.g. for setting and retrieving editor data.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/controller/datacontroller~DataController}\n\t\t */\n\t\tthis.data = new DataController( this.model );\n\n\t\t/**\n\t\t * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.\n\t\t * Controls user input and rendering the content for editing.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/controller/editingcontroller~EditingController}\n\t\t */\n\t\tthis.editing = new EditingController( this.model );\n\t\tthis.editing.view.document.bind( 'isReadOnly' ).to( this );\n\n\t\t/**\n\t\t * Conversion manager through which you can register model to view and view to model converters.\n\t\t *\n\t\t * See {@link module:engine/conversion/conversion~Conversion}'s documentation to learn how to add converters.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/conversion~Conversion}\n\t\t */\n\t\tthis.conversion = new Conversion();\n\n\t\tthis.conversion.register( 'downcast', [ this.editing.downcastDispatcher, this.data.downcastDispatcher ] );\n\t\tthis.conversion.register( 'editingDowncast', [ this.editing.downcastDispatcher ] );\n\t\tthis.conversion.register( 'dataDowncast', [ this.data.downcastDispatcher ] );\n\n\t\tthis.conversion.register( 'upcast', [ this.data.upcastDispatcher ] );\n\n\t\t/**\n\t\t * Instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.\n\t\t *\n\t\t * It allows setting simple keystrokes:\n\t\t *\n\t\t *\t\t// Execute the bold command on Ctrl+E:\n\t\t *\t\teditor.keystrokes.set( 'Ctrl+E', 'bold' );\n\t\t *\n\t\t *\t\t// Execute your own callback:\n\t\t *\t\teditor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {\n\t\t *\t\t\tconsole.log( data.keyCode );\n\t\t *\n\t\t *\t\t\t// Prevent default (native) action and stop the underlying keydown event\n\t\t *\t\t\t// so no other editor feature will interfere.\n\t\t *\t\t\tcancel();\n\t\t *\t\t} );\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editingkeystrokehandler~EditingKeystrokeHandler}\n\t\t */\n\t\tthis.keystrokes = new EditingKeystrokeHandler( this );\n\t\tthis.keystrokes.listenTo( this.editing.view.document );\n\t}\n\n\t/**\n\t * Loads and initializes plugins specified in the config.\n\t *\n\t * @returns {Promise} A promise which resolves once the initialization is completed.\n\t */\n\tinitPlugins() {\n\t\tconst that = this;\n\t\tconst config = this.config;\n\n\t\treturn loadPlugins()\n\t\t\t.then( loadedPlugins => {\n\t\t\t\treturn initPlugins( loadedPlugins, 'init' )\n\t\t\t\t\t.then( () => initPlugins( loadedPlugins, 'afterInit' ) );\n\t\t\t} )\n\t\t\t.then( () => this.fire( 'pluginsReady' ) );\n\n\t\tfunction loadPlugins() {\n\t\t\tconst plugins = config.get( 'plugins' ) || [];\n\t\t\tconst removePlugins = config.get( 'removePlugins' ) || [];\n\n\t\t\treturn that.plugins.load( plugins, removePlugins );\n\t\t}\n\n\t\tfunction initPlugins( loadedPlugins, method ) {\n\t\t\treturn loadedPlugins.reduce( ( promise, plugin ) => {\n\t\t\t\tif ( !plugin[ method ] ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\treturn promise.then( plugin[ method ].bind( plugin ) );\n\t\t\t}, Promise.resolve() );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the editor instance, releasing all resources used by it.\n\t *\n\t * **Note** The editor cannot be destroyed during the initialization phase so if it is called\n\t * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.\n\t *\n\t * @fires destroy\n\t * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.\n\t */\n\tdestroy() {\n\t\tlet readyPromise = Promise.resolve();\n\n\t\tif ( this.state == 'initializing' ) {\n\t\t\treadyPromise = new Promise( resolve => this.once( 'ready', resolve ) );\n\t\t}\n\n\t\treturn readyPromise\n\t\t\t.then( () => {\n\t\t\t\tthis.fire( 'destroy' );\n\t\t\t\tthis.stopListening();\n\t\t\t\tthis.commands.destroy();\n\t\t\t} )\n\t\t\t.then( () => this.plugins.destroy() )\n\t\t\t.then( () => {\n\t\t\t\tthis.model.destroy();\n\t\t\t\tthis.data.destroy();\n\t\t\t\tthis.editing.destroy();\n\t\t\t\tthis.keystrokes.destroy();\n\t\t\t} );\n\t}\n\n\t/**\n\t * Executes specified command with given parameters.\n\t *\n\t * Shorthand for:\n\t *\n\t *\t\teditor.commands.get( commandName ).execute( ... );\n\t *\n\t * @param {String} commandName Name of command to execute.\n\t * @param {*} [...commandParams] Command parameters.\n\t */\n\texecute( ...args ) {\n\t\tthis.commands.execute( ...args );\n\t}\n\n\t/**\n\t * Creates and initializes a new editor instance.\n\t *\n\t * @param {Object} config The editor config. You can find the list of config options in\n\t * {@link module:core/editor/editorconfig~EditorConfig}.\n\t * @returns {Promise} Promise resolved once editor is ready.\n\t * @returns {module:core/editor/editor~Editor} return.editor The editor instance.\n\t */\n\tstatic create( config ) {\n\t\treturn new Promise( resolve => {\n\t\t\tconst editor = new this( config );\n\n\t\t\tresolve(\n\t\t\t\teditor.initPlugins()\n\t\t\t\t\t.then( () => {\n\t\t\t\t\t\teditor.fire( 'dataReady' );\n\t\t\t\t\t\teditor.fire( 'ready' );\n\t\t\t\t\t} )\n\t\t\t\t\t.then( () => editor )\n\t\t\t);\n\t\t} );\n\t}\n}\n\nmix( Editor, ObservableMixin );\n\n/**\n * Fired after {@link #initPlugins plugins are initialized}.\n *\n * @event pluginsReady\n */\n\n/**\n * Fired when the data loaded to the editor is ready. If a specific editor doesn't load\n * any data initially, this event will be fired right before {@link #event:ready}.\n *\n * @event dataReady\n */\n\n/**\n * Fired when {@link #event:pluginsReady plugins}, and {@link #event:dataReady data} and all additional\n * editor components are ready.\n *\n * Note: This event is most useful for plugin developers. When integrating the editor with your website or\n * application you do not have to listen to `editor#ready` because when the promise returned by the static\n * {@link module:core/editor/editor~Editor.create `Editor.create()`} event is resolved, the editor is already ready.\n * In fact, since the first moment when the editor instance is available to you is inside `then()`'s callback,\n * you cannot even add a listener to the `editor#ready` event.\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event ready\n */\n\n/**\n * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to\n * perform the clean-up in any plugin.\n *\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event destroy\n */\n\n/**\n * An array of plugins built into this editor class.\n * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized\n * during the editor initialization.\n *\n * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and\n * unless `config.plugins` is passed.\n *\n *\t\t// Build some plugins into the editor class first.\n *\t\tClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];\n *\n *\t\t// Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was\n *\t\t// defined, now you can call create() without any configuration.\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> instance of the Foo plugin\n *\t\t\t\teditor.plugins.get( BarPlugin ); // -> instance of the Bar plugin\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Don't initialize this plugins (note: it's defined by a string):\n *\t\t\t\tremovePlugins: [ 'Foo' ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> undefined\n *\t\t\t\teditor.config.get( BarPlugin ); // -> instance of the Bar plugin\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Load only this plugin. Can also be define by a string if\n *\t\t\t\t// this plugin was built into the editor class.\n *\t\t\t\tplugins: [ FooPlugin ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> instance of the Foo plugin\n *\t\t\t\teditor.config.get( BarPlugin ); // -> undefined\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.defaultConfig}.\n *\n * @static\n * @member {Array.<Function>} module:core/editor/editor~Editor.builtinPlugins\n */\n\n/**\n * The default config which is built into the editor class.\n * It is used in CKEditor 5 builds to provide the default config options which are later used during editor initialization.\n *\n *\t\tClassicEditor.defaultConfig = {\n *\t\t\tfoo: 1,\n *\t\t\tbar: 2\n *\t\t};\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 2\n *\t\t\t} );\n *\n *\t\t// The default options can be overridden by the config passed to create().\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, { bar: 3 } )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 3\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.builtinPlugins}.\n *\n * @static\n * @member {Object} module:core/editor/editor~Editor.defaultConfig\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/viewcollection\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Collects {@link module:ui/view~View} instances.\n *\n *\t\tconst parentView = new ParentView( locale );\n *\t\tconst collection = new ViewCollection( locale );\n *\n *\t\tcollection.setParent( parentView.element );\n *\n *\t\tconst viewA = new ChildView( locale );\n *\t\tconst viewB = new ChildView( locale );\n *\n * View collection renders and manages view {@link module:ui/view~View#element elements}:\n *\n *\t\tcollection.add( viewA );\n *\t\tcollection.add( viewB );\n *\n *\t\tconsole.log( parentView.element.firsChild ); // -> viewA.element\n *\t\tconsole.log( parentView.element.lastChild ); // -> viewB.element\n *\n * It {@link module:ui/viewcollection~ViewCollection#delegate propagates} DOM events too:\n *\n *\t\t// Delegate #click and #keydown events from viewA and viewB to the parentView.\n *\t\tcollection.delegate( 'click' ).to( parentView );\n *\n *\t\tparentView.on( 'click', ( evt ) => {\n *\t\t\tconsole.log( `${ evt.source } has been clicked.` );\n *\t\t} );\n *\n *\t\t// This event will be delegated to the parentView.\n *\t\tviewB.fire( 'click' );\n *\n * **Note**: A view collection can be used directly in the {@link module:ui/template~TemplateDefinition definition}\n * of a {@link module:ui/template~Template template}.\n *\n * @extends module:utils/collection~Collection\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class ViewCollection extends Collection {\n\t/**\n\t * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.\n\t *\n\t * @param {module:utils/locale~Locale} [locale] The {@link module:core/editor/editor~Editor editor's locale} instance.\n\t */\n\tconstructor( locale ) {\n\t\tsuper( {\n\t\t\t// An #id Number attribute should be legal and not break the `ViewCollection` instance.\n\t\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/93\n\t\t\tidProperty: 'viewUid'\n\t\t} );\n\n\t\t// Handle {@link module:ui/view~View#element} in DOM when a new view is added to the collection.\n\t\tthis.on( 'add', ( evt, view, index ) => {\n\t\t\tif ( !view.isRendered ) {\n\t\t\t\tview.render();\n\t\t\t}\n\n\t\t\tif ( view.element && this._parentElement ) {\n\t\t\t\tthis._parentElement.insertBefore( view.element, this._parentElement.children[ index ] );\n\t\t\t}\n\t\t} );\n\n\t\t// Handle {@link module:ui/view~View#element} in DOM when a view is removed from the collection.\n\t\tthis.on( 'remove', ( evt, view ) => {\n\t\t\tif ( view.element && this._parentElement ) {\n\t\t\t\tview.element.remove();\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.\n\t\t * See the view {@link module:ui/view~View#locale locale} property.\n\t\t *\n\t\t * @member {module:utils/locale~Locale}\n\t\t */\n\t\tthis.locale = locale;\n\n\t\t/**\n\t\t * A parent element within which child views are rendered and managed in DOM.\n\t\t *\n\t\t * @protected\n\t\t * @member {HTMLElement}\n\t\t */\n\t\tthis._parentElement = null;\n\t}\n\n\t/**\n\t * Destroys the view collection along with child views.\n\t * See the view {@link module:ui/view~View#destroy} method.\n\t */\n\tdestroy() {\n\t\tthis.map( view => view.destroy() );\n\t}\n\n\t/**\n\t * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and\n\t * {@link #remove removing} views in the collection synchronizes their\n\t * {@link module:ui/view~View#element elements} in the parent element.\n\t *\n\t * @param {HTMLElement} element A new parent element.\n\t */\n\tsetParent( elementOrDocFragment ) {\n\t\tthis._parentElement = elementOrDocFragment;\n\t}\n\n\t/**\n\t * Delegates selected events coming from within views in the collection to any\n\t * {@link module:utils/emittermixin~Emitter}.\n\t *\n\t * For the following views and collection:\n\t *\n\t *\t\tconst viewA = new View();\n\t *\t\tconst viewB = new View();\n\t *\t\tconst viewC = new View();\n\t *\n\t *\t\tconst views = parentView.createCollection();\n\t *\n\t *\t\tviews.delegate( 'eventX' ).to( viewB );\n\t *\t\tviews.delegate( 'eventX', 'eventY' ).to( viewC );\n\t *\n\t *\t\tviews.add( viewA );\n\t *\n\t * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:\n\t *\n\t *\t\tviewA.fire( 'eventX', customData );\n\t *\n\t * and `eventY` is delegated (fired by) `viewC` along with `customData`:\n\t *\n\t *\t\tviewA.fire( 'eventY', customData );\n\t *\n\t * See {@link module:utils/emittermixin~EmitterMixin#delegate}.\n\t *\n\t * @param {...String} events {@link module:ui/view~View} event names to be delegated to another\n\t * {@link module:utils/emittermixin~Emitter}.\n\t * @returns {Object}\n\t * @returns {Function} return.to A function which accepts the destination of\n\t * {@link module:utils/emittermixin~EmitterMixin#delegate delegated} events.\n\t */\n\tdelegate( ...events ) {\n\t\tif ( !events.length || !isStringArray( events ) ) {\n\t\t\t/**\n\t\t\t * All event names must be strings.\n\t\t\t *\n\t\t\t * @error ui-viewcollection-delegate-wrong-events\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'ui-viewcollection-delegate-wrong-events: All event names must be strings.' );\n\t\t}\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n\t\t\t *\n\t\t\t * @memberOf module:ui/viewcollection~ViewCollection#delegate\n\t\t\t * @function module:ui/viewcollection~ViewCollection#delegate.to\n\t\t\t * @param {module:utils/emittermixin~EmitterMixin} dest An `EmitterMixin` instance which is\n\t\t\t * the destination for delegated events.\n\t\t\t */\n\t\t\tto: dest => {\n\t\t\t\t// Activate delegating on existing views in this collection.\n\t\t\t\tfor ( const view of this ) {\n\t\t\t\t\tfor ( const evtName of events ) {\n\t\t\t\t\t\tview.delegate( evtName ).to( dest );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Activate delegating on future views in this collection.\n\t\t\t\tthis.on( 'add', ( evt, view ) => {\n\t\t\t\t\tfor ( const evtName of events ) {\n\t\t\t\t\t\tview.delegate( evtName ).to( dest );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\t// Deactivate delegating when view is removed from this collection.\n\t\t\t\tthis.on( 'remove', ( evt, view ) => {\n\t\t\t\t\tfor ( const evtName of events ) {\n\t\t\t\t\t\tview.stopDelegating( evtName, dest );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Removes a child view from the collection. If the {@link #setParent parent element} of the\n\t * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed\n\t * in DOM, reflecting the order of the collection.\n\t *\n\t * See the {@link #add} method.\n\t *\n\t * @method #remove\n\t * @param {module:ui/view~View|Number|String} subject The view to remove, its id or index in the collection.\n\t * @returns {Object} The removed view.\n\t */\n}\n\nmix( Collection, ObservableMixin );\n\n// Check if all entries of the array are of `String` type.\n//\n// @private\n// @param {Array} arr An array to be checked.\n// @returns {Boolean}\nfunction isStringArray( arr ) {\n\treturn arr.every( a => typeof a == 'string' );\n}\n","import baseClone from './_baseClone';\n\n/**\n * This method is like `_.cloneWith` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @param {Function} [customizer] The function to customize cloning.\n * @returns {*} Returns the deep cloned value.\n * @see _.cloneWith\n * @example\n *\n * function customizer(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(true);\n *   }\n * }\n *\n * var el = _.cloneDeepWith(document.body, customizer);\n *\n * console.log(el === document.body);\n * // => false\n * console.log(el.nodeName);\n * // => 'BODY'\n * console.log(el.childNodes.length);\n * // => 20\n */\nfunction cloneDeepWith(value, customizer) {\n  return baseClone(value, true, true, customizer);\n}\n\nexport default cloneDeepWith;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/template\n */\n\n/* global document */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport View from './view';\nimport ViewCollection from './viewcollection';\nimport cloneDeepWith from '@ckeditor/ckeditor5-utils/src/lib/lodash/cloneDeepWith';\nimport isObject from '@ckeditor/ckeditor5-utils/src/lib/lodash/isObject';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\n\nconst xhtmlNs = 'http://www.w3.org/1999/xhtml';\n\n/**\n * A basic Template class. It renders a DOM HTML element or text from a\n * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,\n * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.\n *\n * A simple template can look like this:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\tclass: 'foo',\n *\t\t\t\tstyle: {\n *\t\t\t\t\tbackgroundColor: 'yellow'\n *\t\t\t\t}\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t}\n *\t\t\tchildren: [\n *\t\t\t\t'A paragraph.'\n *\t\t\t]\n *\t\t} ).render();\n *\n * and it will render the following HTML element:\n *\n *\t\t<p class=\"foo\" style=\"background-color: yellow;\">A paragraph.</p>\n *\n * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.\n *\n * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex\n * template definitions.\n *\n* @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Template {\n\t/**\n\t * Creates an instance of the {@link ~Template} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the template.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, normalize( clone( def ) ) );\n\n\t\t/**\n\t\t * Indicates whether this particular Template instance has been\n\t\t * {@link #render rendered}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._isRendered = false;\n\n\t\t/**\n\t\t * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template\n\t\t * renders to an HTML element.\n\t\t *\n\t\t * @member {String} #tag\n\t\t */\n\n\t\t/**\n\t\t * The text of the template. It also indicates that the template renders to a DOM text node.\n\t\t *\n\t\t * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text\n\t\t */\n\n\t\t/**\n\t\t * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with\n\t\t * the attributes of an HTML element.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Object} #attributes\n\t\t */\n\n\t\t/**\n\t\t * The children of the template. They can be either:\n\t\t * * independent instances of {@link ~Template} (sub–templates),\n\t\t * * native DOM Nodes.\n\t\t *\n\t\t * **Note**: This property only makes sense when {@link #tag} is defined.\n\t\t *\n\t\t * @member {Array.<module:ui/template~Template|Node>} #children\n\t\t */\n\n\t\t/**\n\t\t * The DOM event listeners of the template.\n\t\t *\n\t\t * @member {Object} #eventListeners\n\t\t */\n\n\t\t/**\n\t\t * The data used by the {@link #revert} method to restore a node to its original state.\n\t\t *\n\t\t * See: {@link #apply}.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {module:ui/template~RenderData}\n\t\t */\n\t\tthis._revertData = null;\n\t}\n\n\t/**\n\t * Renders a DOM Node (an HTML element or text) out of the template.\n\t *\n\t *\t\tconst domNode = new Template( { ... } ).render();\n\t *\n\t * See: {@link #apply}.\n\t *\n\t * @returns {HTMLElement|Text}\n\t */\n\trender() {\n\t\tconst node = this._renderNode( {\n\t\t\tintoFragment: true\n\t\t} );\n\n\t\tthis._isRendered = true;\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Applies the template to an existing DOM Node, either HTML element or text.\n\t *\n\t * **Note:** No new DOM nodes will be created. Applying extends\n\t * {@link module:ui/template~TemplateDefinition attributes} and\n\t * {@link module:ui/template~TemplateDefinition event listeners} only.\n\t *\n\t * **Note:** Existing `class` and `style` attributes are extended when a template\n\t * is applied to an HTML element, while other attributes and `textContent` are overridden.\n\t *\n\t * **Note:** The process of applying a template can be easily reverted using the\n\t * {@link module:ui/template~Template#revert} method.\n\t *\n\t *\t\tconst element = document.createElement( 'div' );\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattrs: {\n\t *\t\t\t\tid: 'first-div',\n\t *\t\t\t\tclass: bind.to( 'divClass' )\n\t *\t\t\t},\n\t *\t\t\ton: {\n\t *\t\t\t\tclick: bind( 'elementClicked' ) // Will be fired by the observable.\n\t *\t\t\t}\n\t *\t\t\tchildren: [\n\t *\t\t\t\t'Div text.'\n\t *\t\t\t]\n\t *\t\t} ).apply( element );\n\t *\n\t *\t\telement.outerHTML == \"<div id=\"first-div\" class=\"my-div\">Div text.</div>\"\n\t *\n\t * @see module:ui/template~Template#render\n\t * @see module:ui/template~Template#revert\n\t * @param {Node} node Root node for the template to apply.\n\t */\n\tapply( node ) {\n\t\tthis._revertData = getEmptyRevertData();\n\n\t\tthis._renderNode( {\n\t\t\tnode,\n\t\t\tisApplying: true,\n\t\t\trevertData: this._revertData\n\t\t} );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.\n\t *\n\t * @param {Node} node The root node for the template to revert. In most of the cases, it is the\n\t * same node used by {@link module:ui/template~Template#apply}.\n\t */\n\trevert( node ) {\n\t\tif ( !this._revertData ) {\n\t\t\t/**\n\t\t\t * Attempting to revert a template which has not been applied yet.\n\t\t\t *\n\t\t\t * @error ui-template-revert-not-applied\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.' );\n\t\t}\n\n\t\tthis._revertTemplateFromNode( node, this._revertData );\n\t}\n\n\t/**\n\t * Returns an iterator which traverses the template in search of {@link module:ui/view~View}\n\t * instances and returns them one by one.\n\t *\n\t *\t\tconst viewFoo = new View();\n\t *\t\tconst viewBar = new View();\n\t *\t\tconst viewBaz = new View();\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'div',\n\t *\t\t\tchildren: [\n\t *\t\t\t\tviewFoo,\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'div',\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\tviewBar\n\t *\t\t\t\t\t]\n\t *\t\t\t\t},\n\t *\t\t\t\tviewBaz\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Logs: viewFoo, viewBar, viewBaz\n\t *\t\tfor ( const view of template.getViews() ) {\n\t *\t\t\tconsole.log( view );\n\t *\t\t}\n\t *\n\t * @returns {Iterable.<module:ui/view~View>}\n\t */\n\t* getViews() {\n\t\tfunction* search( def ) {\n\t\t\tif ( def.children ) {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isView( child ) ) {\n\t\t\t\t\t\tyield child;\n\t\t\t\t\t} else if ( isTemplate( child ) ) {\n\t\t\t\t\t\tyield* search( child );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tyield* search( this );\n\t}\n\n\t/**\n\t * An entry point to the interface which binds DOM nodes to\n\t * {@link module:utils/observablemixin~Observable observables}.\n\t * There are two types of bindings:\n\t *\n\t * * HTML element attributes or text `textContent` synchronized with attributes of an\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}\n\t * and {@link module:ui/template~BindChain#if}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\tattrs: {\n\t *\t\t\t\t// Binds the element \"class\" attribute to observable#classAttribute.\n\t *\t\t\t\tclass: bind.to( 'classAttribute' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * * DOM events fired on HTML element propagated through\n\t * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tnew Template( {\n\t *\t\t\ton: {\n\t *\t\t\t\t// Will be fired by the observable.\n\t *\t\t\t\tclick: bind( 'elementClicked' )\n\t *\t\t\t}\n\t *\t\t} ).render();\n\t *\n\t * Also see {@link module:ui/view~View#bindTemplate}.\n\t *\n\t * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.\n\t * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute\n\t * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.\n\t * @returns {module:ui/template~BindChain}\n\t */\n\tstatic bind( observable, emitter ) {\n\t\treturn {\n\t\t\tto( eventNameOrFunctionOrAttribute, callback ) {\n\t\t\t\treturn new TemplateToBinding( {\n\t\t\t\t\teventNameOrFunction: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tattribute: eventNameOrFunctionOrAttribute,\n\t\t\t\t\tobservable, emitter, callback\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\tif( attribute, valueIfTrue, callback ) {\n\t\t\t\treturn new TemplateIfBinding( {\n\t\t\t\t\tobservable, emitter, attribute, valueIfTrue, callback\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Extends an existing {@link module:ui/template~Template} instance with some additional content\n\t * from another {@link module:ui/template~TemplateDefinition}.\n\t *\n\t *\t\tconst bind = Template.bind( observable, emitter );\n\t *\n\t *\t\tconst template = new Template( {\n\t *\t\t\ttag: 'p',\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'a',\n\t *\t\t\t\tdata-x: bind.to( 'foo' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\ttag: 'span',\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'b'\n\t *\t\t\t\t\t},\n\t *\t\t\t\t\tchildren: [\n\t *\t\t\t\t\t\t'Span'\n\t *\t\t\t\t\t]\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t } );\n\t *\n\t *\t\t// Instance-level extension.\n\t *\t\tTemplate.extend( template, {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'b',\n\t *\t\t\t\tdata-x: bind.to( 'bar' )\n\t *\t\t\t},\n\t *\t\t\tchildren: [\n\t *\t\t\t\t{\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\tclass: 'c'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Child extension.\n\t *\t\tTemplate.extend( template.children[ 0 ], {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: 'd'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * the `outerHTML` of `template.render()` is:\n\t *\n\t *\t\t<p class=\"a b\" data-x=\"{ observable.foo } { observable.bar }\">\n\t *\t\t\t<span class=\"b c d\">Span</span>\n\t *\t\t</p>\n\t *\n\t * @param {module:ui/template~Template} template An existing template instance to be extended.\n\t * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.\n\t */\n\tstatic extend( template, def ) {\n\t\tif ( template._isRendered ) {\n\t\t\t/**\n\t\t\t * Extending a template after rendering may not work as expected. To make sure\n\t\t\t * the {@link module:ui/template~Template.extend extending} works for an element,\n\t\t\t * make sure it happens before {@link #render} is called.\n\t\t\t *\n\t\t\t * @error template-extend-render\n\t\t\t */\n\t\t\tlog.warn( 'template-extend-render: Attempting to extend a template which has already been rendered.' );\n\t\t}\n\n\t\textendTemplate( template, normalize( clone( def ) ) );\n\t}\n\n\t/**\n\t * Renders a DOM Node (either an HTML element or text) out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderNode( data ) {\n\t\tlet isInvalid;\n\n\t\tif ( data.node ) {\n\t\t\t// When applying, a definition cannot have \"tag\" and \"text\" at the same time.\n\t\t\tisInvalid = this.tag && this.text;\n\t\t} else {\n\t\t\t// When rendering, a definition must have either \"tag\" or \"text\": XOR( this.tag, this.text ).\n\t\t\tisInvalid = this.tag ? this.text : !this.text;\n\t\t}\n\n\t\tif ( isInvalid ) {\n\t\t\t/**\n\t\t\t * Node definition cannot have the \"tag\" and \"text\" properties at the same time.\n\t\t\t * Node definition must have either \"tag\" or \"text\" when rendering a new Node.\n\t\t\t *\n\t\t\t * @error ui-template-wrong-syntax\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-wrong-syntax: Node definition must have either \"tag\" or \"text\" when rendering a new Node.'\n\t\t\t);\n\t\t}\n\n\t\tif ( this.text ) {\n\t\t\treturn this._renderText( data );\n\t\t} else {\n\t\t\treturn this._renderElement( data );\n\t\t}\n\t}\n\n\t/**\n\t * Renders an HTML element out of the template.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElement( data ) {\n\t\tlet node = data.node;\n\n\t\tif ( !node ) {\n\t\t\tnode = data.node = document.createElementNS( this.ns || xhtmlNs, this.tag );\n\t\t}\n\n\t\tthis._renderAttributes( data );\n\t\tthis._renderElementChildren( data );\n\t\tthis._setUpListeners( data );\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders a text node out of {@link module:ui/template~Template#text}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderText( data ) {\n\t\tlet node = data.node;\n\n\t\t// Save the original textContent to revert it in #revert().\n\t\tif ( node ) {\n\t\t\tdata.revertData.text = node.textContent;\n\t\t} else {\n\t\t\tnode = data.node = document.createTextNode( '' );\n\t\t}\n\n\t\t// Check if this Text Node is bound to Observable. Cases:\n\t\t//\n\t\t//\t\ttext: [ Template.bind( ... ).to( ... ) ]\n\t\t//\n\t\t//\t\ttext: [\n\t\t//\t\t\t'foo',\n\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t//\t\t\t...\n\t\t//\t\t]\n\t\t//\n\t\tif ( hasTemplateBinding( this.text ) ) {\n\t\t\tthis._bindToObservable( {\n\t\t\t\tschema: this.text,\n\t\t\t\tupdater: getTextUpdater( node ),\n\t\t\t\tdata\n\t\t\t} );\n\t\t}\n\t\t// Simply set text. Cases:\n\t\t//\n\t\t//\t\ttext: [ 'all', 'are', 'static' ]\n\t\t//\n\t\t//\t\ttext: [ 'foo' ]\n\t\t//\n\t\telse {\n\t\t\tnode.textContent = this.text.join( '' );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderAttributes( data ) {\n\t\tlet attrName, attrValue, domAttrValue, attrNs;\n\n\t\tif ( !this.attributes ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = data.node;\n\t\tconst revertData = data.revertData;\n\n\t\tfor ( attrName in this.attributes ) {\n\t\t\t// Current attribute value in DOM.\n\t\t\tdomAttrValue = node.getAttribute( attrName );\n\n\t\t\t// The value to be set.\n\t\t\tattrValue = this.attributes[ attrName ];\n\n\t\t\t// Save revert data.\n\t\t\tif ( revertData ) {\n\t\t\t\trevertData.attributes[ attrName ] = domAttrValue;\n\t\t\t}\n\n\t\t\t// Detect custom namespace:\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tattrNs = ( isObject( attrValue[ 0 ] ) && attrValue[ 0 ].ns ) ? attrValue[ 0 ].ns : null;\n\n\t\t\t// Activate binding if one is found. Cases:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'bar',\n\t\t\t//\t\t\tTemplate.bind( ... ).to( ... ),\n\t\t\t//\t\t\t'baz'\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\t//\t\tclass: {\n\t\t\t//\t\t\tns: 'abc',\n\t\t\t//\t\t\tvalue: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( attrValue ) ) {\n\t\t\t\t// Normalize attributes with additional data like namespace:\n\t\t\t\t//\n\t\t\t\t//\t\tclass: {\n\t\t\t\t//\t\t\tns: 'abc',\n\t\t\t\t//\t\t\tvalue: [ ... ]\n\t\t\t\t//\t\t}\n\t\t\t\t//\n\t\t\t\tconst valueToBind = attrNs ? attrValue[ 0 ].value : attrValue;\n\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && shouldExtend( attrName ) ) {\n\t\t\t\t\tvalueToBind.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: valueToBind,\n\t\t\t\t\tupdater: getAttributeUpdater( node, attrName, attrNs ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Style attribute could be an Object so it needs to be parsed in a specific way.\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\twidth: '100px',\n\t\t\t//\t\t\theight: Template.bind( ... ).to( ... )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse if ( attrName == 'style' && typeof attrValue[ 0 ] !== 'string' ) {\n\t\t\t\tthis._renderStyleAttribute( attrValue[ 0 ], data );\n\t\t\t}\n\n\t\t\t// Otherwise simply set the static attribute:\n\t\t\t//\n\t\t\t//\t\tclass: [ 'foo' ]\n\t\t\t//\n\t\t\t//\t\tclass: [ 'all', 'are', 'static' ]\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t{\n\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t//\t\t\t\tvalue: [ 'foo' ]\n\t\t\t//\t\t\t}\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\telse {\n\t\t\t\t// Extend the original value of attributes like \"style\" and \"class\",\n\t\t\t\t// don't override them.\n\t\t\t\tif ( revertData && domAttrValue && shouldExtend( attrName ) ) {\n\t\t\t\t\tattrValue.unshift( domAttrValue );\n\t\t\t\t}\n\n\t\t\t\tattrValue = attrValue\n\t\t\t\t\t// Retrieve \"values\" from:\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tclass: [\n\t\t\t\t\t//\t\t\t{\n\t\t\t\t\t//\t\t\t\tns: 'abc',\n\t\t\t\t\t//\t\t\t\tvalue: [ ... ]\n\t\t\t\t\t//\t\t\t}\n\t\t\t\t\t//\t\t]\n\t\t\t\t\t//\n\t\t\t\t\t.map( val => val ? ( val.value || val ) : val )\n\t\t\t\t\t// Flatten the array.\n\t\t\t\t\t.reduce( ( prev, next ) => prev.concat( next ), [] )\n\t\t\t\t\t// Convert into string.\n\t\t\t\t\t.reduce( arrayValueReducer, '' );\n\n\t\t\t\tif ( !isFalsy( attrValue ) ) {\n\t\t\t\t\tnode.setAttributeNS( attrNs, attrName, attrValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders the `style` attribute of an HTML element based on\n\t * {@link module:ui/template~Template#attributes}.\n\t *\n\t * A style attribute is an {Object} with static values:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: 'red'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * or values bound to {@link module:ui/model~Model} properties:\n\t *\n\t *\t\tattributes: {\n\t *\t\t\tstyle: {\n\t *\t\t\t\tcolor: bind.to( ... )\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be\n\t * needed.\n\t *\n\t * @private\n\t * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderStyleAttribute( styles, data ) {\n\t\tconst node = data.node;\n\n\t\tfor ( const styleName in styles ) {\n\t\t\tconst styleValue = styles[ styleName ];\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: bind.to( 'attribute' )\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\tif ( hasTemplateBinding( styleValue ) ) {\n\t\t\t\tthis._bindToObservable( {\n\t\t\t\t\tschema: [ styleValue ],\n\t\t\t\t\tupdater: getStyleUpdater( node, styleName ),\n\t\t\t\t\tdata\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Cases:\n\t\t\t//\n\t\t\t//\t\tstyle: {\n\t\t\t//\t\t\tcolor: 'red'\n\t\t\t//\t\t}\n\t\t\t//\n\t\t\telse {\n\t\t\t\tnode.style[ styleName ] = styleValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_renderElementChildren( data ) {\n\t\tconst node = data.node;\n\t\tconst container = data.intoFragment ? document.createDocumentFragment() : node;\n\t\tconst isApplying = data.isApplying;\n\t\tlet childIndex = 0;\n\n\t\tfor ( const child of this.children ) {\n\t\t\tif ( isViewCollection( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tchild.setParent( node );\n\n\t\t\t\t\t// Note: ViewCollection renders its children.\n\t\t\t\t\tfor ( const view of child ) {\n\t\t\t\t\t\tcontainer.appendChild( view.element );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( isView( child ) ) {\n\t\t\t\tif ( !isApplying ) {\n\t\t\t\t\tif ( !child.isRendered ) {\n\t\t\t\t\t\tchild.render();\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer.appendChild( child.element );\n\t\t\t\t}\n\t\t\t} else if ( isNode( child ) ) {\n\t\t\t\tcontainer.appendChild( child );\n\t\t\t} else {\n\t\t\t\tif ( isApplying ) {\n\t\t\t\t\tconst revertData = data.revertData;\n\t\t\t\t\tconst childRevertData = getEmptyRevertData();\n\n\t\t\t\t\trevertData.children.push( childRevertData );\n\n\t\t\t\t\tchild._renderNode( {\n\t\t\t\t\t\tnode: container.childNodes[ childIndex++ ],\n\t\t\t\t\t\tisApplying: true,\n\t\t\t\t\t\trevertData: childRevertData\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.appendChild( child.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( data.intoFragment ) {\n\t\t\tnode.appendChild( container );\n\t\t}\n\t}\n\n\t/**\n\t * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}\n\t * on an HTML element.\n\t *\n\t * @protected\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t */\n\t_setUpListeners( data ) {\n\t\tif ( !this.eventListeners ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const key in this.eventListeners ) {\n\t\t\tconst revertBindings = this.eventListeners[ key ].map( schemaItem => {\n\t\t\t\tconst [ domEvtName, domSelector ] = key.split( '@' );\n\n\t\t\t\treturn schemaItem.activateDomEventListener( domEvtName, domSelector, data );\n\t\t\t} );\n\n\t\t\tif ( data.revertData ) {\n\t\t\t\tdata.revertData.bindings.push( revertBindings );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}\n\t * activates the binding and sets its initial value.\n\t *\n\t * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or\n\t * text node `textContent`.\n\t *\n\t * @protected\n\t * @param {Object} options Binding options.\n\t * @param {module:ui/template~TemplateValueSchema} options.schema\n\t * @param {Function} options.updater A function which updates the DOM (like attribute or text).\n\t * @param {module:ui/template~RenderData} options.data Rendering data.\n\t */\n\t_bindToObservable( { schema, updater, data } ) {\n\t\tconst revertData = data.revertData;\n\n\t\t// Set initial values.\n\t\tsyncValueSchemaValue( schema, updater, data );\n\n\t\tconst revertBindings = schema\n\t\t\t// Filter \"falsy\" (false, undefined, null, '') value schema components out.\n\t\t\t.filter( item => !isFalsy( item ) )\n\t\t\t// Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.\n\t\t\t.filter( item => item.observable )\n\t\t\t// Once only the actual binding are left, let the emitter listen to observable change:attribute event.\n\t\t\t// TODO: Reduce the number of listeners attached as many bindings may listen\n\t\t\t// to the same observable attribute.\n\t\t\t.map( templateBinding => templateBinding.activateAttributeListener( schema, updater, data ) );\n\n\t\tif ( revertData ) {\n\t\t\trevertData.bindings.push( revertBindings );\n\t\t}\n\t}\n\n\t/**\n\t * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to\n\t * return it to the original state.\n\t *\n\t * @protected\n\t * @param {HTMLElement|Text} node A node to be reverted.\n\t * @param {module:ui/template~RenderData#revertData} revertData Stores information about\n\t * what changes have been made by {@link #apply} to the node.\n\t */\n\t_revertTemplateFromNode( node, revertData ) {\n\t\tfor ( const binding of revertData.bindings ) {\n\t\t\t// Each binding may consist of several observable+observable#attribute.\n\t\t\t// like the following has 2:\n\t\t\t//\n\t\t\t//\t\tclass: [\n\t\t\t//\t\t\t'x',\n\t\t\t//\t\t\tbind.to( 'foo' ),\n\t\t\t//\t\t\t'y',\n\t\t\t//\t\t\tbind.to( 'bar' )\n\t\t\t//\t\t]\n\t\t\t//\n\t\t\tfor ( const revertBinding of binding ) {\n\t\t\t\trevertBinding();\n\t\t\t}\n\t\t}\n\n\t\tif ( revertData.text ) {\n\t\t\tnode.textContent = revertData.text;\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const attrName in revertData.attributes ) {\n\t\t\tconst attrValue = revertData.attributes[ attrName ];\n\n\t\t\t// When the attribute has **not** been set before #apply().\n\t\t\tif ( attrValue === null ) {\n\t\t\t\tnode.removeAttribute( attrName );\n\t\t\t} else {\n\t\t\t\tnode.setAttribute( attrName, attrValue );\n\t\t\t}\n\t\t}\n\n\t\tfor ( let i = 0; i < revertData.children.length; ++i ) {\n\t\t\tthis._revertTemplateFromNode( node.childNodes[ i ], revertData.children[ i ] );\n\t\t}\n\t}\n}\n\nmix( Template, EmitterMixin );\n\n/**\n * Describes a binding created by the {@link module:ui/template~Template.bind} interface.\n *\n * @protected\n */\nexport class TemplateBinding {\n\t/**\n\t * Creates an instance of the {@link module:ui/template~TemplateBinding} class.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} def The definition of the binding.\n\t */\n\tconstructor( def ) {\n\t\tObject.assign( this, def );\n\n\t\t/**\n\t\t * An observable instance of the binding. It either:\n\t\t *\n\t\t * * provides the attribute with the value,\n\t\t * * or passes the event when a corresponding DOM event is fired.\n\t\t *\n\t\t * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable\n\t\t */\n\n\t\t/**\n\t\t * An {@link module:utils/emittermixin~Emitter} used by the binding to:\n\t\t *\n\t\t * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},\n\t\t * * or listen to the event in the DOM.\n\t\t *\n\t\t * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter\n\t\t */\n\n\t\t/**\n\t\t * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.\n\t\t *\n\t\t * @member {String} module:ui/template~TemplateBinding#attribute\n\t\t */\n\n\t\t/**\n\t\t * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.\n\t\t *\n\t\t * @member {Function} [module:ui/template~TemplateBinding#callback]\n\t\t */\n\t}\n\n\t/**\n\t * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the\n\t * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.\n\t *\n\t * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.\n\t * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}.\n\t */\n\tgetValue( node ) {\n\t\tconst value = this.observable[ this.attribute ];\n\n\t\treturn this.callback ? this.callback( value, node ) : value;\n\t}\n\n\t/**\n\t * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated\n\t * value of {@link module:ui/template~TemplateValueSchema}.\n\t *\n\t * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.\n\t * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateAttributeListener( schema, updater, data ) {\n\t\tconst callback = () => syncValueSchemaValue( schema, updater, data );\n\n\t\tthis.emitter.listenTo( this.observable, 'change:' + this.attribute, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( this.observable, 'change:' + this.attribute, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes either:\n *\n * * a binding to an {@link module:utils/observablemixin~Observable},\n * * or a native DOM event binding.\n *\n * It is created by the {@link module:ui/template~BindChain#to} method.\n *\n * @protected\n */\nexport class TemplateToBinding extends TemplateBinding {\n\t/**\n\t * Activates the listener for the native DOM event, which when fired, is propagated by\n\t * the {@link module:ui/template~TemplateBinding#emitter}.\n\t *\n\t * @param {String} domEvtName The name of the native DOM event.\n\t * @param {String} domSelector The selector in the DOM to filter delegated events.\n\t * @param {module:ui/template~RenderData} data Rendering data.\n\t * @returns {Function} A function to sever the listener binding.\n\t */\n\tactivateDomEventListener( domEvtName, domSelector, data ) {\n\t\tconst callback = ( evt, domEvt ) => {\n\t\t\tif ( !domSelector || domEvt.target.matches( domSelector ) ) {\n\t\t\t\tif ( typeof this.eventNameOrFunction == 'function' ) {\n\t\t\t\t\tthis.eventNameOrFunction( domEvt );\n\t\t\t\t} else {\n\t\t\t\t\tthis.observable.fire( this.eventNameOrFunction, domEvt );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.emitter.listenTo( data.node, domEvtName, callback );\n\n\t\t// Allows revert of the listener.\n\t\treturn () => {\n\t\t\tthis.emitter.stopListening( data.node, domEvtName, callback );\n\t\t};\n\t}\n}\n\n/**\n * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}\n * method.\n *\n * @protected\n */\nexport class TemplateIfBinding extends TemplateBinding {\n\t/**\n\t * @inheritDoc\n\t */\n\tgetValue( node ) {\n\t\tconst value = super.getValue( node );\n\n\t\treturn isFalsy( value ) ? false : ( this.valueIfTrue || true );\n\t}\n\n\t/**\n\t * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in\n\t * {@link module:ui/template~TemplateBinding#observable} is `true`.\n\t *\n\t * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]\n\t */\n}\n\n// Checks whether given {@link module:ui/template~TemplateValueSchema} contains a\n// {@link module:ui/template~TemplateBinding}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @returns {Boolean}\nfunction hasTemplateBinding( schema ) {\n\tif ( !schema ) {\n\t\treturn false;\n\t}\n\n\t// Normalize attributes with additional data like namespace:\n\t//\n\t//\t\tclass: {\n\t//\t\t\tns: 'abc',\n\t//\t\t\tvalue: [ ... ]\n\t//\t\t}\n\t//\n\tif ( schema.value ) {\n\t\tschema = schema.value;\n\t}\n\n\tif ( Array.isArray( schema ) ) {\n\t\treturn schema.some( hasTemplateBinding );\n\t} else if ( schema instanceof TemplateBinding ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of\n// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}\n// items.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\n// @returns {Array}\nfunction getValueSchemaValue( schema, node ) {\n\treturn schema.map( schemaItem => {\n\t\t// Process {@link module:ui/template~TemplateBinding} bindings.\n\t\tif ( schemaItem instanceof TemplateBinding ) {\n\t\t\treturn schemaItem.getValue( node );\n\t\t}\n\n\t\t// All static values like strings, numbers, and \"falsy\" values (false, null, undefined, '', etc.) just pass.\n\t\treturn schemaItem;\n\t} );\n}\n\n// A function executed each time the bound Observable attribute changes, which updates the DOM with a value\n// constructed from {@link module:ui/template~TemplateValueSchema}.\n//\n// @param {module:ui/template~TemplateValueSchema} schema\n// @param {Function} updater A function which updates the DOM (like attribute or text).\n// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.\nfunction syncValueSchemaValue( schema, updater, { node } ) {\n\tlet value = getValueSchemaValue( schema, node );\n\n\t// Check if schema is a single Template.bind.if, like:\n\t//\n\t//\t\tclass: Template.bind.if( 'foo' )\n\t//\n\tif ( schema.length == 1 && schema[ 0 ] instanceof TemplateIfBinding ) {\n\t\tvalue = value[ 0 ];\n\t} else {\n\t\tvalue = value.reduce( arrayValueReducer, '' );\n\t}\n\n\tif ( isFalsy( value ) ) {\n\t\tupdater.remove();\n\t} else {\n\t\tupdater.set( value );\n\t}\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset `textContent`.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @returns {Object}\nfunction getTextUpdater( node ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tnode.textContent = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tnode.textContent = '';\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of DOM Node to set or reset an attribute.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} attrName Name of the attribute to be modified.\n// @param {String} [ns=null] Namespace to use.\n// @returns {Object}\nfunction getAttributeUpdater( el, attrName, ns ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.setAttributeNS( ns, attrName, value );\n\t\t},\n\n\t\tremove() {\n\t\t\tel.removeAttributeNS( ns, attrName );\n\t\t}\n\t};\n}\n\n// Returns an object consisting of `set` and `remove` functions, which\n// can be used in the context of CSSStyleDeclaration to set or remove a style.\n// @see module:ui/view~View#_bindToObservable\n//\n// @param {Node} node DOM Node to be modified.\n// @param {String} styleName Name of the style to be modified.\n// @returns {Object}\nfunction getStyleUpdater( el, styleName ) {\n\treturn {\n\t\tset( value ) {\n\t\t\tel.style[ styleName ] = value;\n\t\t},\n\n\t\tremove() {\n\t\t\tel.style[ styleName ] = null;\n\t\t}\n\t};\n}\n\n// Clones definition of the template.\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition}\nfunction clone( def ) {\n\tconst clone = cloneDeepWith( def, value => {\n\t\t// Don't clone the `Template.bind`* bindings because of the references to Observable\n\t\t// and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy\n\t\t// cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins\n\t\t// along with the definition.\n\t\t//\n\t\t// Don't clone Template instances if provided as a child. They're simply #render()ed\n\t\t// and nothing should interfere.\n\t\t//\n\t\t// Also don't clone View instances if provided as a child of the Template. The template\n\t\t// instance will be extracted from the View during the normalization and there's no need\n\t\t// to clone it.\n\t\tif ( value && ( value instanceof TemplateBinding || isTemplate( value ) || isView( value ) || isViewCollection( value ) ) ) {\n\t\t\treturn value;\n\t\t}\n\t} );\n\n\treturn clone;\n}\n\n// Normalizes given {@link module:ui/template~TemplateDefinition}.\n//\n// See:\n//  * {@link normalizeAttributes}\n//  * {@link normalizeListeners}\n//  * {@link normalizePlainTextDefinition}\n//  * {@link normalizeTextDefinition}\n//\n// @param {module:ui/template~TemplateDefinition} def\n// @returns {module:ui/template~TemplateDefinition} Normalized definition.\nfunction normalize( def ) {\n\tif ( typeof def == 'string' ) {\n\t\tdef = normalizePlainTextDefinition( def );\n\t} else if ( def.text ) {\n\t\tnormalizeTextDefinition( def );\n\t}\n\n\tif ( def.on ) {\n\t\tdef.eventListeners = normalizeListeners( def.on );\n\n\t\t// Template mixes EmitterMixin, so delete #on to avoid collision.\n\t\tdelete def.on;\n\t}\n\n\tif ( !def.text ) {\n\t\tif ( def.attributes ) {\n\t\t\tnormalizeAttributes( def.attributes );\n\t\t}\n\n\t\tconst children = [];\n\n\t\tif ( def.children ) {\n\t\t\tif ( isViewCollection( def.children ) ) {\n\t\t\t\tchildren.push( def.children );\n\t\t\t} else {\n\t\t\t\tfor ( const child of def.children ) {\n\t\t\t\t\tif ( isTemplate( child ) || isView( child ) || isNode( child ) ) {\n\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildren.push( new Template( child ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdef.children = children;\n\t}\n\n\treturn def;\n}\n\n// Normalizes \"attributes\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tattributes: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: {\n//\t\t\t\tvalue: 'bar'\n//\t\t\t}\n//\t\t}\n//\n// becomes\n//\n//\t\tattributes: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: {\n//\t\t\t\tvalue: [ 'bar' ]\n//\t\t\t}\n//\t\t}\n//\n// @param {Object} attrs\nfunction normalizeAttributes( attrs ) {\n\tfor ( const a in attrs ) {\n\t\tif ( attrs[ a ].value ) {\n\t\t\tattrs[ a ].value = [].concat( attrs[ a ].value );\n\t\t}\n\n\t\tarrayify( attrs, a );\n\t}\n}\n\n// Normalizes \"on\" section of {@link module:ui/template~TemplateDefinition}.\n//\n//\t\ton: {\n//\t\t\ta: 'bar',\n//\t\t\tb: {@link module:ui/template~TemplateBinding},\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// becomes\n//\n//\t\ton: {\n//\t\t\ta: [ 'bar' ],\n//\t\t\tb: [ {@link module:ui/template~TemplateBinding} ],\n//\t\t\tc: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]\n//\t\t}\n//\n// @param {Object} listeners\n// @returns {Object} Object containing normalized listeners.\nfunction normalizeListeners( listeners ) {\n\tfor ( const l in listeners ) {\n\t\tarrayify( listeners, l );\n\t}\n\n\treturn listeners;\n}\n\n// Normalizes \"string\" {@link module:ui/template~TemplateDefinition}.\n//\n//\t\t\"foo\"\n//\n// becomes\n//\n//\t\t{ text: [ 'foo' ] },\n//\n// @param {String} def\n// @returns {module:ui/template~TemplateDefinition} Normalized template definition.\nfunction normalizePlainTextDefinition( def ) {\n\treturn {\n\t\ttext: [ def ]\n\t};\n}\n\n// Normalizes text {@link module:ui/template~TemplateDefinition}.\n//\n//\t\tchildren: [\n//\t\t\t{ text: 'def' },\n//\t\t\t{ text: {@link module:ui/template~TemplateBinding} }\n//\t\t]\n//\n// becomes\n//\n//\t\tchildren: [\n//\t\t\t{ text: [ 'def' ] },\n//\t\t\t{ text: [ {@link module:ui/template~TemplateBinding} ] }\n//\t\t]\n//\n// @param {module:ui/template~TemplateDefinition} def\nfunction normalizeTextDefinition( def ) {\n\tif ( !Array.isArray( def.text ) ) {\n\t\tdef.text = [ def.text ];\n\t}\n}\n\n// Wraps an entry in Object in an Array, if not already one.\n//\n//\t\t{\n//\t\t\tx: 'y',\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// becomes\n//\n//\t\t{\n//\t\t\tx: [ 'y' ],\n//\t\t\ta: [ 'b' ]\n//\t\t}\n//\n// @param {Object} obj\n// @param {String} key\nfunction arrayify( obj, key ) {\n\tif ( !Array.isArray( obj[ key ] ) ) {\n\t\tobj[ key ] = [ obj[ key ] ];\n\t}\n}\n\n// A helper which concatenates the value avoiding unwanted\n// leading white spaces.\n//\n// @param {String} prev\n// @param {String} cur\n// @returns {String}\nfunction arrayValueReducer( prev, cur ) {\n\tif ( isFalsy( cur ) ) {\n\t\treturn prev;\n\t} else if ( isFalsy( prev ) ) {\n\t\treturn cur;\n\t} else {\n\t\treturn `${ prev } ${ cur }`;\n\t}\n}\n\n// Extends one object defined in the following format:\n//\n//\t\t{\n//\t\t\tkey1: [Array1],\n//\t\t\tkey2: [Array2],\n//\t\t\t...\n//\t\t\tkeyN: [ArrayN]\n//\t\t}\n//\n// with another object of the same data format.\n//\n// @param {Object} obj Base object.\n// @param {Object} ext Object extending base.\n// @returns {String}\nfunction extendObjectValueArray( obj, ext ) {\n\tfor ( const a in ext ) {\n\t\tif ( obj[ a ] ) {\n\t\t\tobj[ a ].push( ...ext[ a ] );\n\t\t} else {\n\t\t\tobj[ a ] = ext[ a ];\n\t\t}\n\t}\n}\n\n// A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance\n// with content from {module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.\n//\n// @param {module:ui/template~Template} def A template instance to be extended.\n// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.\nfunction extendTemplate( template, def ) {\n\tif ( def.attributes ) {\n\t\tif ( !template.attributes ) {\n\t\t\ttemplate.attributes = {};\n\t\t}\n\n\t\textendObjectValueArray( template.attributes, def.attributes );\n\t}\n\n\tif ( def.eventListeners ) {\n\t\tif ( !template.eventListeners ) {\n\t\t\ttemplate.eventListeners = {};\n\t\t}\n\n\t\textendObjectValueArray( template.eventListeners, def.eventListeners );\n\t}\n\n\tif ( def.text ) {\n\t\ttemplate.text.push( ...def.text );\n\t}\n\n\tif ( def.children && def.children.length ) {\n\t\tif ( template.children.length != def.children.length ) {\n\t\t\t/**\n\t\t\t * The number of children in extended definition does not match.\n\t\t\t *\n\t\t\t * @error ui-template-extend-children-mismatch\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'ui-template-extend-children-mismatch: The number of children in extended definition does not match.'\n\t\t\t);\n\t\t}\n\n\t\tlet childIndex = 0;\n\n\t\tfor ( const childDef of def.children ) {\n\t\t\textendTemplate( template.children[ childIndex++ ], childDef );\n\t\t}\n\t}\n}\n\n// Checks if value is \"falsy\".\n// Note: 0 (Number) is not \"falsy\" in this context.\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isFalsy( value ) {\n\treturn !value && value !== 0;\n}\n\n// Checks if the item is an instance of {@link module:ui/view~View}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isView( item ) {\n\treturn item instanceof View;\n}\n\n// Checks if the item is an instance of {@link module:ui/template~Template}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isTemplate( item ) {\n\treturn item instanceof Template;\n}\n\n// Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}\n//\n// @private\n// @param {*} value Value to be checked.\nfunction isViewCollection( item ) {\n\treturn item instanceof ViewCollection;\n}\n\n// Creates an empty skeleton for {@link module:ui/template~Template#revert}\n// data.\n//\n// @private\nfunction getEmptyRevertData() {\n\treturn {\n\t\tchildren: [],\n\t\tbindings: [],\n\t\tattributes: {}\n\t};\n}\n\n// Checks whether an attribute should be extended when\n// {@link module:ui/template~Template#apply} is called.\n//\n// @private\n// @param {String} attrName Attribute name to check.\nfunction shouldExtend( attrName ) {\n\treturn attrName == 'class' || attrName == 'style';\n}\n\n/**\n * A definition of the {@link module:ui/template~Template}. It describes what kind of\n * node a template will render (HTML element or text), attributes of an element, DOM event\n * listeners and children.\n *\n * Also see:\n * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,\n * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.\n *\n * A sample definition on an HTML element can look like this:\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\ttag: 'span',\n *\t\t\t\t\tattributes: { ... },\n *\t\t\t\t\tchildren: [ ... ],\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\ttext: 'static–text'\n *\t\t\t\t},\n *\t\t\t\t'also-static–text',\n *\t\t\t],\n *\t\t\tattributes: {\n *\t\t\t\tclass: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tid: {@link module:ui/template~TemplateValueSchema},\n *\t\t\t\tstyle: {@link module:ui/template~TemplateValueSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t},\n *\t\t\ton: {\n *\t\t\t\t'click': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// Document.querySelector format is also accepted.\n *\t\t\t\t'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}\n *\n *\t\t\t\t// ...\n *\t\t\t}\n *\t\t} );\n *\n * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node\n * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:\n *\n *\t\tconst view = new SomeView();\n *\t\tconst childTemplate = new Template( { ... } );\n *\t\tconst childNode = document.createElement( 'b' );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: [\n *\t\t\t\t// view#element will be added as a child of this <p>.\n *\t\t\t\tview,\n *\n * \t\t\t\t// The output of childTemplate.render() will be added here.\n *\t\t\t\tchildTemplate,\n *\n *\t\t\t\t// Native DOM nodes are included directly in the rendered output.\n *\t\t\t\tchildNode\n *\t\t\t]\n *\t\t} );\n *\n * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:\n *\n *\t\tconst collection = new ViewCollection();\n *\t\tcollection.add( someView );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\n *\t\t\tchildren: collection\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateDefinition\n * @type Object\n *\n * @property {String} tag See the template {@link module:ui/template~Template#tag} property.\n *\n * @property {Array.<module:ui/template~TemplateDefinition>} [children]\n * See the template {@link module:ui/template~Template#children} property.\n *\n * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]\n * See the template {@link module:ui/template~Template#attributes} property.\n *\n * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]\n * See the template {@link module:ui/template~Template#text} property.\n *\n * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]\n * See the template {@link module:ui/template~Template#eventListeners} property.\n */\n\n/**\n * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple\n * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn where to use it,\n * * {@link module:ui/template~Template.bind} to learn how to configure\n * {@link module:utils/observablemixin~Observable} attribute bindings,\n * * {@link module:ui/template~Template#render} to learn how to render a template,\n * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}\n * methods to learn more about bindings.\n *\n * Attribute values can be described in many different ways:\n *\n *\t\t// Bind helper will create bindings to attributes of the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// A plain string schema.\n *\t\t\t\t'class': 'static-text',\n *\n *\t\t\t\t// An object schema, binds to the \"foo\" attribute of the\n *\t\t\t\t// observable and follows its value.\n *\t\t\t\t'class': bind.to( 'foo' ),\n *\n *\t\t\t\t// An array schema, combines the above.\n *\t\t\t\t'class': [\n *\t\t\t\t\t'static-text',\n *\t\t\t\t\tbind.to( 'bar', () => { ... } ),\n *\n * \t\t\t\t\t// Bindings can also be conditional.\n *\t\t\t\t\tbind.if( 'baz', 'class-when-baz-is-true' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema, with a custom namespace, e.g. useful for creating SVGs.\n *\t\t\t\t'class': {\n *\t\t\t\t\tns: 'http://ns.url',\n *\t\t\t\t\tvalue: [\n *\t\t\t\t\t\tbind.if( 'baz', 'value-when-true' ),\n *\t\t\t\t\t\t'static-text'\n *\t\t\t\t\t]\n *\t\t\t\t},\n *\n *\t\t\t\t// An object schema, specific for styles.\n *\t\t\t\tstyle: {\n *\t\t\t\t\tcolor: 'red',\n *\t\t\t\t\tbackgroundColor: bind.to( 'qux', () => { ... } )\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * Text nodes can also have complex values:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\t// Will render a \"foo\" text node.\n *\t\tnew Template( {\n *\t\t\ttext: 'foo'\n *\t\t} );\n *\n *\t\t// Will render a \"static text: {observable.foo}\" text node.\n *\t\t// The text of the node will be updated as the \"foo\" attribute changes.\n *\t\tnew Template( {\n *\t\t\ttext: [\n *\t\t\t\t'static text: ',\n *\t\t\t\tbind.to( 'foo', () => { ... } )\n *\t\t\t]\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateValueSchema\n * @type {Object|String|Array}\n */\n\n/**\n * Describes an event listener attached to an HTML element. Such listener can propagate DOM events\n * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks\n * or both, if necessary.\n *\n * Also see:\n * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,\n * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.\n *\n * Check out different ways of attaching event listeners below:\n *\n *\t\t// Bind helper will propagate events through the observable.\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\ton: {\n *\t\t\t\t// An object schema. The observable will fire the \"clicked\" event upon DOM \"click\".\n *\t\t\t\tclick: bind.to( 'clicked' )\n *\n *\t\t\t\t// An object schema. It will work for \"click\" event on \"a.foo\" children only.\n *\t\t\t\t'click@a.foo': bind.to( 'clicked' )\n *\n *\t\t\t\t// An array schema, makes the observable propagate multiple events.\n *\t\t\t\tclick: [\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( 'executed' )\n *\t\t\t\t],\n *\n *\t\t\t\t// An array schema with a custom callback.\n *\t\t\t\t'click@a.foo': {\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\t\t\t\t\tbind.to( evt => {\n *\t\t\t\t\t\tconsole.log( `${ evt.target } has been clicked!` );\n *\t\t\t\t\t} }\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n * @typedef module:ui/template~TemplateListenerSchema\n * @type {Object|String|Array}\n */\n\n/**\n * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`\n * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.\n *\n * @interface module:ui/template~BindChain\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to either:\n *\n * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable\n * attribute as it changes,\n * * or an HTML element DOM event, so the DOM events are propagated through an observable.\n *\n * Some common use cases of `to()` bindings are presented below:\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'p',\n *\t\t\tattributes: {\n *\t\t\t\t// class=\"...\" attribute gets bound to `observable#a`\n *\t\t\t\tclass: bind.to( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t// <p>...</p> gets bound to observable#b; always `toUpperCase()`.\n *\t\t\t\t{\n *\t\t\t\t\ttext: bind.to( 'b', ( value, node ) => value.toUpperCase() )\n *\t\t\t\t}\n *\t\t\t],\n *\t\t\ton: {\n *\t\t\t\tclick: [\n *\t\t\t\t\t// An observable will fire \"clicked\" upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( 'clicked' ),\n *\n *\t\t\t\t\t// A custom callback will be executed upon \"click\" in the DOM.\n *\t\t\t\t\tbind.to( () => {\n *\t\t\t\t\t\t...\n *\t\t\t\t\t} )\n *\t\t\t\t]\n *\t\t\t}\n *\t\t} ).render();\n *\n * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and\n * {@link module:ui/template~TemplateListenerSchema}.\n *\n * @method #to\n * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of\n * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text\n * node `textContent` so it remains in sync with the observable attribute as it changes.\n *\n * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`\n * depending on the \"falseness\" of an {@link module:utils/observablemixin~Observable} attribute.\n *\n *\t\tconst bind = Template.bind( observable, emitter );\n *\n *\t\tnew Template( {\n *\t\t\ttag: 'input',\n *\t\t\tattributes: {\n *\t\t\t\t// <input checked> when `observable#a` is not undefined/null/false/''\n *\t\t\t\t// <input> when `observable#a` is undefined/null/false\n *\t\t\t\tchecked: bind.if( 'a' )\n *\t\t\t},\n *\t\t\tchildren: [\n *\t\t\t\t{\n *\t\t\t\t\t// <input>\"b-is-not-set\"</input> when `observable#b` is undefined/null/false/''\n *\t\t\t\t\t// <input></input> when `observable#b` is not \"falsy\"\n *\t\t\t\t\ttext: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )\n *\t\t\t\t}\n *\t\t\t]\n *\t\t} ).render();\n *\n * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.\n *\n * @method #if\n * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.\n * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not\n * undefined/null/false/'' (empty string).\n * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.\n * @returns {module:ui/template~TemplateBinding}\n */\n\n/**\n * The {@link module:ui/template~Template#_renderNode} configuration.\n *\n * @private\n * @interface module:ui/template~RenderData\n */\n\n/**\n * Tells {@link module:ui/template~Template#_renderNode} to render\n * children into `DocumentFragment` first and then append the fragment\n * to the parent element. It is a speed optimization.\n *\n * @member {Boolean} #intoFragment\n */\n\n/**\n * A node which is being rendered.\n *\n * @member {HTMLElement|Text} #node\n */\n\n/**\n * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has\n * been provided by {@module:ui/template~Template#apply}.\n *\n * @member {Boolean} #isApplying\n */\n\n/**\n * An object storing the data that helps {@module:ui/template~Template#revert}\n * bringing back an element to its initial state, i.e. before\n * {@module:ui/template~Template#apply} was called.\n *\n * @member {Object} #revertData\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/view\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ViewCollection from './viewcollection';\nimport Template from './template';\nimport DomEmitterMixin from '@ckeditor/ckeditor5-utils/src/dom/emittermixin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\nimport '../theme/globals/globals.css';\n\n/**\n * The basic view class, which represents an HTML element created out of a\n * {@link module:ui/view~View#template}. Views are building blocks of the user interface and handle\n * interaction\n *\n * Views {@link module:ui/view~View#registerChild aggregate} children in\n * {@link module:ui/view~View#createCollection collections} and manage the life cycle of DOM\n * listeners e.g. by handling rendering and destruction.\n *\n * See the {@link module:ui/template~TemplateDefinition} syntax to learn more about shaping view\n * elements, attributes and listeners.\n *\n *\t\tclass SampleView extends View {\n *\t\t\tconstructor( locale ) {\n *\t\t\t\tsuper( locale );\n *\n *\t\t\t\tconst bind = this.bindTemplate;\n *\n *\t\t\t\t// Views define their interface (state) using observable attributes.\n *\t\t\t\tthis.set( 'elementClass', 'bar' );\n *\n *\t\t\t\tthis.setTemplate( {\n *\t\t\t\t\ttag: 'p',\n *\n *\t\t\t\t\t// The element of the view can be defined with its children.\n *\t\t\t\t\tchildren: [\n *\t\t\t\t\t\t'Hello',\n *\t\t\t\t\t\t{\n *\t\t\t\t\t\t\ttag: 'b',\n *\t\t\t\t\t\t\tchildren: [ 'world!' ]\n *\t\t\t\t\t\t}\n *\t\t\t\t\t],\n *\t\t\t\t\tattributes: {\n *\t\t\t\t\t\tclass: [\n *\t\t\t\t\t\t\t'foo',\n *\n *\t\t\t\t\t\t\t// Observable attributes control the state of the view in DOM.\n *\t\t\t\t\t\t\tbind.to( 'elementClass' )\n *\t\t\t\t\t\t]\n *\t\t\t\t\t},\n *\t\t\t\t\ton: {\n *\t\t\t\t\t\t// Views listen to DOM events and propagate them.\n *\t\t\t\t\t\tclick: bind.to( 'clicked' )\n *\t\t\t\t\t}\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n *\n *\t\tconst view = new SampleView( locale );\n *\n *\t\tview.render();\n *\n *\t\t// Append <p class=\"foo bar\">Hello<b>world</b></p> to the <body>\n *\t\tdocument.body.appendChild( view.element );\n *\n *\t\t// Change the class attribute to <p class=\"foo baz\">Hello<b>world</b></p>\n *\t\tview.elementClass = 'baz';\n *\n *\t\t// Respond to the \"click\" event in DOM by executing a custom action.\n *\t\tview.on( 'clicked', () => {\n *\t\t\tconsole.log( 'The view has been clicked!' );\n *\t\t} );\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class View {\n\t/**\n\t * Creates an instance of the {@link module:ui/view~View} class.\n\t *\n\t * Also see {@link #render}.\n\t *\n\t * @param {module:utils/locale~Locale} [locale] The localization services instance.\n\t */\n\tconstructor( locale ) {\n\t\t/**\n\t\t * An HTML element of the view. `null` until {@link #render rendered}\n\t\t * from the {@link #template}.\n\t\t *\n\t\t *\t\tclass SampleView extends View {\n\t\t *\t\t\tconstructor() {\n\t\t *\t\t\t\tsuper();\n\t\t *\n\t\t *\t\t\t\t// A template instance the #element will be created from.\n\t\t *\t\t\t\tthis.setTemplate( {\n\t\t *\t\t\t\t\ttag: 'p'\n\t\t *\n\t\t *\t\t\t\t\t// ...\n\t\t *\t\t\t\t} );\n\t\t *\t\t\t}\n\t\t *\t\t}\n\t\t *\n\t\t *\t\tconst view = new SampleView();\n\t\t *\n\t\t *\t\t// Renders the #template.\n\t\t *\t\tview.render();\n\t\t *\n\t\t *\t\t// Append the HTML element of the view to <body>.\n\t\t *\t\tdocument.body.appendChild( view.element );\n\t\t *\n\t\t * **Note**: The element of the view can also be assigned directly:\n\t\t *\n\t\t *\t\tview.element = document.querySelector( '#my-container' );\n\t\t *\n\t\t * @member {HTMLElement}\n\t\t */\n\t\tthis.element = null;\n\n\t\t/**\n\t\t * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isRendered\n\t\t */\n\t\tthis.isRendered = false;\n\n\t\t/**\n\t\t * A set of tools to localize the user interface.\n\t\t *\n\t\t * Also see {@link module:core/editor/editor~Editor#locale}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/locale~Locale}\n\t\t */\n\t\tthis.locale = locale;\n\n\t\t/**\n\t\t * Shorthand for {@link module:utils/locale~Locale#t}.\n\t\t *\n\t\t * Note: If {@link #locale} instance hasn't been passed to the view this method may not\n\t\t * be available.\n\t\t *\n\t\t * @see module:utils/locale~Locale#t\n\t\t * @method\n\t\t */\n\t\tthis.t = locale && locale.t;\n\n\t\t/**\n\t\t * Collections registered with {@link #createCollection}.\n\t\t *\n\t\t * @protected\n\t\t * @member {Set.<module:ui/viewcollection~ViewCollection>}\n\t\t */\n\t\tthis._viewCollections = new Collection();\n\n\t\t/**\n\t\t * A collection of view instances, which have been added directly\n\t\t * into the {@link module:ui/template~Template#children}.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n\t\tthis._unboundChildren = this.createCollection();\n\n\t\t// Pass parent locale to its children.\n\t\tthis._viewCollections.on( 'add', ( evt, collection ) => {\n\t\t\tcollection.locale = locale;\n\t\t} );\n\n\t\t/**\n\t\t * Template of this view. It provides the {@link #element} representing\n\t\t * the view in DOM, which is {@link #render rendered}.\n\t\t *\n\t\t * @member {module:ui/template~Template} #template\n\t\t */\n\n\t\t/**\n\t\t * Cached {@link module:ui/template~BindChain bind chain} object created by the\n\t\t * {@link #template}. See {@link #bindTemplate}.\n\t\t *\n\t\t * @private\n\t\t * @member {Object} #_bindTemplate\n\t\t */\n\n\t\tthis.decorate( 'render' );\n\t}\n\n\t/**\n\t * Shorthand for {@link module:ui/template~Template.bind}, a binding\n\t * {@link module:ui/template~BindChain interface} pre–configured for the view instance.\n\t *\n\t * It provides {@link module:ui/template~BindChain#to `to()`} and\n\t * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with\n\t * observable attributes and attach DOM listeners.\n\t *\n\t *\t\tclass SampleView extends View {\n\t *\t\t\tconstructor( locale ) {\n\t *\t\t\t\tsuper( locale );\n\t *\n\t *\t\t\t\tconst bind = this.bindTemplate;\n\t *\n\t *\t\t\t\t// These {@link module:utils/observablemixin~Observable observable} attributes will control\n\t *\t\t\t\t// the state of the view in DOM.\n\t *\t\t\t\tthis.set( {\n\t *\t\t\t\t\telementClass: 'foo',\n\t *\t\t\t\t \tisEnabled: true\n\t *\t\t\t\t } );\n\t *\n\t *\t\t\t\tthis.setTemplate( {\n\t *\t\t\t\t\ttag: 'p',\n\t *\n\t *\t\t\t\t\tattributes: {\n\t *\t\t\t\t\t\t// The class HTML attribute will follow elementClass\n\t *\t\t\t\t\t\t// and isEnabled view attributes.\n\t *\t\t\t\t\t\tclass: [\n\t *\t\t\t\t\t\t\tbind.to( 'elementClass' )\n\t *\t\t\t\t\t\t\tbind.if( 'isEnabled', 'present-when-enabled' )\n\t *\t\t\t\t\t\t]\n\t *\t\t\t\t\t},\n\t *\n\t *\t\t\t\t\ton: {\n\t *\t\t\t\t\t\t// The view will fire the \"clicked\" event upon clicking <p> in DOM.\n\t *\t\t\t\t\t\tclick: bind.to( 'clicked' )\n\t *\t\t\t\t\t}\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * @method #bindTemplate\n\t */\n\tget bindTemplate() {\n\t\tif ( this._bindTemplate ) {\n\t\t\treturn this._bindTemplate;\n\t\t}\n\n\t\treturn ( this._bindTemplate = Template.bind( this, this ) );\n\t}\n\n\t/**\n\t * Creates a new collection of views, which can be used as\n\t * {@link module:ui/template~Template#children} of this view.\n\t *\n\t *\t\tclass SampleView extends View {\n\t *\t\t\tconstructor( locale ) {\n\t *\t\t\t\tsuper( locale );\n\t *\n\t *\t\t\t\tthis.items = this.createCollection();\n \t *\n\t *\t\t\t\tthis.setTemplate( {\n\t *\t\t\t\t\ttag: 'p',\n\t *\n\t *\t\t\t\t\t// `items` collection will render here.\n\t *\t\t\t\t\tchildren: this.items\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst view = new SampleView( locale );\n\t *\t\tconst child = new ChildView( locale );\n\t *\n\t *\t\tview.render();\n\t *\n\t *\t\t// It will append <p></p> to the <body>.\n\t *\t\tdocument.body.appendChild( view.element );\n\t *\n\t *\t\t// From now on the child is nested under its parent, which is also reflected in DOM.\n\t *\t\t// <p><child#element></p>\n\t *\t\tview.items.add( child );\n\t *\n\t * @returns {module:ui/viewcollection~ViewCollection} A new collection of view instances.\n\t */\n\tcreateCollection() {\n\t\tconst collection = new ViewCollection();\n\n\t\tthis._viewCollections.add( collection );\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Registers a new child view under the view instance. Once registered, a child\n\t * view is managed by its parent, including {@link #render rendering}\n\t * and {@link #destroy destruction}.\n\t *\n\t * To revert this, use {@link #deregisterChild}.\n\t *\n\t *\t\tclass SampleView extends View {\n\t *\t\t\tconstructor( locale ) {\n\t *\t\t\t\tsuper( locale );\n\t *\n\t *\t\t\t\tthis.childA = new SomeChildView( locale );\n\t *\t\t\t\tthis.childB = new SomeChildView( locale );\n\t *\n\t *\t\t\t\tthis.setTemplate( { tag: 'p' } );\n\t *\n\t *\t\t\t\t// Register the children.\n\t *\t\t\t\tthis.registerChild( [ this.childA, this.childB ] );\n\t *\t\t\t}\n\t *\n\t *\t\t\trender() {\n\t *\t\t\t\tsuper.render();\n\t *\n\t *\t\t\t\tthis.element.appendChild( this.childA.element );\n\t *\t\t\t\tthis.element.appendChild( this.childB.element );\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst view = new SampleView( locale );\n\t *\n\t *\t\tview.render();\n\t *\n\t *\t\t// Will append <p><childA#element><b></b><childB#element></p>.\n\t *\t\tdocument.body.appendChild( view.element );\n\t *\n\t * **Note**: There's no need to add child views if they're already referenced in the\n\t * {@link #template}:\n\t *\n\t *\t\tclass SampleView extends View {\n\t *\t\t\tconstructor( locale ) {\n\t *\t\t\t\tsuper( locale );\n\t *\n\t *\t\t\t\tthis.childA = new SomeChildView( locale );\n\t *\t\t\t\tthis.childB = new SomeChildView( locale );\n\t *\n\t *\t\t\t\tthis.setTemplate( {\n\t *\t\t\t\t\ttag: 'p',\n\t *\n \t *\t\t\t\t\t// These children will be added automatically. There's no\n \t *\t\t\t\t\t// need to call {@link #registerChild} for any of them.\n\t *\t\t\t\t\tchildren: [ this.childA, this.childB ]\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\n\t *\t\t\t// ...\n\t *\t\t}\n\t *\n\t * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Children views to be registered.\n\t */\n\tregisterChild( children ) {\n\t\tif ( !isIterable( children ) ) {\n\t\t\tchildren = [ children ];\n\t\t}\n\n\t\tfor ( const child of children ) {\n\t\t\tthis._unboundChildren.add( child );\n\t\t}\n\t}\n\n\t/**\n\t * The opposite of {@link #registerChild}. Removes a child view from this view instance.\n\t * Once removed, the child is no longer managed by its parent, e.g. it can safely\n\t * become a child of another parent view.\n\t *\n\t * @see #registerChild\n\t * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Child views to be removed.\n\t */\n\tderegisterChild( children ) {\n\t\tif ( !isIterable( children ) ) {\n\t\t\tchildren = [ children ];\n\t\t}\n\n\t\tfor ( const child of children ) {\n\t\t\tthis._unboundChildren.remove( child );\n\t\t}\n\t}\n\n\t/**\n\t * Sets the {@link #template} of the view with with given definition.\n\t *\n\t * A shorthand for:\n\t *\n\t *\t\tview.setTemplate( definition );\n\t *\n\t * @param {module:ui/template~TemplateDefinition} definition Definition of view's template.\n\t */\n\tsetTemplate( definition ) {\n\t\tthis.template = new Template( definition );\n\t}\n\n\t/**\n\t * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with\n\t * with given definition.\n\t *\n\t * A shorthand for:\n\t *\n\t *\t\tTemplate.extend( view.template, definition );\n\t *\n\t * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.\n\t *\n\t * @param {module:ui/template~TemplateDefinition} definition Definition which\n\t * extends the {@link #template}.\n\t */\n\textendTemplate( definition ) {\n\t\tTemplate.extend( this.template, definition );\n\t}\n\n\t/**\n\t * Recursively renders the view.\n\t *\n\t * Once the view is rendered:\n\t * * the {@link #element} becomes an HTML element out of {@link #template},\n\t * * the {@link #isRendered} flag is set `true`.\n\t *\n\t * **Note**: The children of the view:\n\t * * defined directly in the {@link #template}\n\t * * residing in collections created by the {@link #createCollection} method,\n\t * * and added by {@link #registerChild}\n\t * are also rendered in the process.\n\t *\n\t * In general, `render()` method is the right place to keep the code which refers to the\n\t * {@link #element} and should be executed at the very beginning of the view's life cycle.\n\t *\n\t * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before\n\t * the view is rendered. To allow an early customization of the view (e.g. by its parent),\n\t * such references should be done in `render()`.\n\t *\n\t *\t\tclass SampleView extends View {\n\t *\t\t\tconstructor() {\n\t *\t\t\t\tthis.setTemplate( {\n\t *\t\t\t\t\t// ...\n\t *\t\t\t\t} );\n\t *\t\t\t},\n\t *\n\t *\t\t\trender() {\n\t *\t\t\t\t// View#element becomes available.\n\t *\t\t\t\tsuper.render();\n\t *\n\t *\t\t\t\t// The \"scroll\" listener depends on #element.\n\t *\t\t\t\tthis.listenTo( window, 'scroll', () => {\n\t *\t\t\t\t\t// A reference to #element would render the #template and make it non-extendable.\n\t *\t\t\t\t\tif ( window.scrollY > 0 ) {\n\t *\t\t\t\t\t\tthis.element.scrollLeft = 100;\n\t *\t\t\t\t\t} else {\n\t *\t\t\t\t\t\tthis.element.scrollLeft = 0;\n\t *\t\t\t\t\t}\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst view = new SampleView();\n\t *\n\t *\t\t// Let's customize the view before it gets rendered.\n\t *\t\tview.extendTemplate( {\n\t *\t\t\tattributes: {\n\t *\t\t\t\tclass: [\n\t *\t\t\t\t\t'additional-class'\n\t *\t\t\t\t]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Late rendering allows customization of the view.\n\t *\t\tview.render();\n\t */\n\trender() {\n\t\tif ( this.isRendered ) {\n\t\t\t/**\n\t\t\t * This View has already been rendered.\n\t\t\t *\n\t\t\t * @error ui-view-render-rendered\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'ui-view-render-already-rendered: This View has already been rendered.' );\n\t\t}\n\n\t\t// Render #element of the view.\n\t\tif ( this.template ) {\n\t\t\tthis.element = this.template.render();\n\n\t\t\t// Auto–register view children from #template.\n\t\t\tthis.registerChild( this.template.getViews() );\n\t\t}\n\n\t\tthis.isRendered = true;\n\t}\n\n\t/**\n\t * Recursively destroys the view instance and child views added by {@link #registerChild} and\n\t * residing in collections created by the {@link #createCollection}.\n\t *\n\t * Destruction disables all event listeners:\n\t * * created on the view, e.g. `view.on( 'event', () => {} )`,\n\t * * defined in the {@link #template} for DOM events.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\n\t\tthis._viewCollections.map( c => c.destroy() );\n\t}\n\n\t/**\n\t * Event fired by the {@link #render} method. Actual rendering is executed as a listener to\n\t * this event with the default priority.\n\t *\n\t * See {@link module:utils/observablemixin~ObservableMixin.decorate} for more information and samples.\n\t *\n\t * @event render\n\t */\n}\n\nmix( View, DomEmitterMixin );\nmix( View, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/editorui/editoruiview\n */\n\n/* globals document */\n\nimport View from '../view';\nimport Template from '../template';\n\nimport '../../theme/components/editorui/editorui.css';\n\n/**\n * The editor UI view class. Base class for the editor main views.\n *\n * @extends module:ui/view~View\n */\nexport default class EditorUIView extends View {\n\t/**\n\t * Creates an instance of the editor UI view class.\n\t *\n\t * @param {module:utils/locale~Locale} [locale] The locale instance.\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * Collection of the child views, detached from the DOM\n\t\t * structure of the editor, like panels, icons etc.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/viewcollection~ViewCollection} #body\n\t\t */\n\t\tthis.body = this.createCollection();\n\n\t\t/**\n\t\t * The element holding elements of the 'body' region.\n\t\t *\n\t\t * @private\n\t\t * @member {HTMLElement} #_bodyCollectionContainer\n\t\t */\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\tthis._renderBodyCollection();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis._bodyCollectionContainer.remove();\n\n\t\treturn super.destroy();\n\t}\n\n\t/**\n\t * Creates and appends to `<body>` the {@link #body} collection container.\n\t *\n\t * @private\n\t */\n\t_renderBodyCollection() {\n\t\tconst bodyElement = this._bodyCollectionContainer = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-reset_all',\n\t\t\t\t\t'ck-body',\n\t\t\t\t\t'ck-rounded-corners'\n\t\t\t\t]\n\t\t\t},\n\t\t\tchildren: this.body\n\t\t} ).render();\n\n\t\tdocument.body.appendChild( bodyElement );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* global setTimeout, clearTimeout */\n\n/**\n * @module utils/focustracker\n */\n\nimport DomEmitterMixin from './dom/emittermixin';\nimport ObservableMixin from './observablemixin';\nimport CKEditorError from './ckeditorerror';\nimport mix from './mix';\n\n/**\n * Allows observing a group of `HTMLElement`s whether at least one of them is focused.\n *\n * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,\n * or were used outside of its UI.\n *\n * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`\n * which contain other `focusable` elements. But note that this wrapper element has to be focusable too\n * (have e.g. `tabindex=\"-1\"`).\n *\n * @mixes module:utils/dom/emittermixin~EmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class FocusTracker {\n\tconstructor() {\n\t\t/**\n\t\t * True when one of the registered elements is focused.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * Currently focused element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {HTMLElement}\n\t\t */\n\t\tthis.focusedElement = null;\n\n\t\t/**\n\t\t * List of registered elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<HTMLElement>}\n\t\t */\n\t\tthis._elements = new Set();\n\n\t\t/**\n\t\t * Event loop timeout.\n\t\t *\n\t\t * @private\n\t\t * @member {Number}\n\t\t */\n\t\tthis._nextEventLoopTimeout = null;\n\t}\n\n\t/**\n\t * Starts tracking the specified element.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tadd( element ) {\n\t\tif ( this._elements.has( element ) ) {\n\t\t\tthrow new CKEditorError( 'focusTracker-add-element-already-exist' );\n\t\t}\n\n\t\tthis.listenTo( element, 'focus', () => this._focus( element ), { useCapture: true } );\n\t\tthis.listenTo( element, 'blur', () => this._blur(), { useCapture: true } );\n\t\tthis._elements.add( element );\n\t}\n\n\t/**\n\t * Stops tracking the specified element and stops listening on this element.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tremove( element ) {\n\t\tif ( element === this.focusedElement ) {\n\t\t\tthis._blur( element );\n\t\t}\n\n\t\tif ( this._elements.has( element ) ) {\n\t\t\tthis.stopListening( element );\n\t\t\tthis._elements.delete( element );\n\t\t}\n\t}\n\n\t/**\n\t * Stores currently focused element and set {#isFocused} as `true`.\n\t *\n\t * @private\n\t * @param {HTMLElement} element Element which has been focused.\n\t */\n\t_focus( element ) {\n\t\tclearTimeout( this._nextEventLoopTimeout );\n\n\t\tthis.focusedElement = element;\n\t\tthis.isFocused = true;\n\t}\n\n\t/**\n\t * Clears currently focused element and set {@link #isFocused} as `false`.\n\t * This method uses `setTimeout` to change order of fires `blur` and `focus` events.\n\t *\n\t * @private\n\t * @fires blur\n\t */\n\t_blur() {\n\t\tclearTimeout( this._nextEventLoopTimeout );\n\n\t\tthis._nextEventLoopTimeout = setTimeout( () => {\n\t\t\tthis.focusedElement = null;\n\t\t\tthis.isFocused = false;\n\t\t}, 0 );\n\t}\n\n\t/**\n\t * @event focus\n\t */\n\n\t/**\n\t * @event blur\n\t */\n}\n\nmix( FocusTracker, DomEmitterMixin );\nmix( FocusTracker, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/componentfactory\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * A helper class implementing the UI component ({@link module:ui/view~View view}) factory.\n *\n * It allows functions producing specific UI components to be registered under their unique names\n * in the factory. A registered component can be then instantiated by providing its name.\n * Note that names are case insensitive.\n *\n *\t\t// The editor provides localization tools for the factory.\n *\t\tconst factory = new ComponentFactory( editor );\n *\n *\t\tfactory.add( 'foo', locale => new FooView( locale ) );\n *\t\tfactory.add( 'bar', locale => new BarView( locale ) );\n *\n *\t\t// An instance of FooView.\n *\t\tconst fooInstance = factory.create( 'foo' );\n *\n *\t\t// Names are case insensitive so this is also allowed:\n *\t\tconst barInstance = factory.create( 'Bar' );\n *\n * The {@link module:core/editor/editor~Editor#locale editor locale} is passed to the factory\n * function when {@link module:ui/componentfactory~ComponentFactory#create} is called.\n */\nexport default class ComponentFactory {\n\t/**\n\t * Creates an instance of the factory.\n\t *\n\t * @constructor\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * The editor instance that the factory belongs to.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor}\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * Registered component factories.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._components = new Map();\n\t}\n\n\t/**\n\t * Returns an iterator of registered component names. Names are returned in lower case.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* names() {\n\t\tfor ( const value of this._components.values() ) {\n\t\t\tyield value.originalName;\n\t\t}\n\t}\n\n\t/**\n\t * Registers a component factory function that will be used by the\n\t * {@link #create create} method and called with the\n\t * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,\n\t * allowing localization of the {@link module:ui/view~View view}.\n\t *\n\t * @param {String} name The name of the component.\n\t * @param {Function} callback The callback that returns the component.\n\t */\n\tadd( name, callback ) {\n\t\tif ( this.has( name ) ) {\n\t\t\t/**\n\t\t\t * The item already exists in the component factory.\n\t\t\t *\n\t\t\t * @error componentfactory-item-exists\n\t\t\t * @param {String} name The name of the component.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'componentfactory-item-exists: The item already exists in the component factory.', { name }\n\t\t\t);\n\t\t}\n\n\t\tthis._components.set( getNormalized( name ), { callback, originalName: name } );\n\t}\n\n\t/**\n\t * Creates an instance of a component registered in the factory under a specific name.\n\t *\n\t * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to\n\t * the previously {@link #add added} factory function, allowing localization of the\n\t * {@link module:ui/view~View view}.\n\t *\n\t * @param {String} name The name of the component.\n\t * @returns {module:ui/view~View} The instantiated component view.\n\t */\n\tcreate( name ) {\n\t\tif ( !this.has( name ) ) {\n\t\t\t/**\n\t\t\t * The required component is not registered in the component factory. Please make sure\n\t\t\t * the provided name is correct and the component has been correctly\n\t\t\t * {@link #add added} to the factory.\n\t\t\t *\n\t\t\t * @error componentfactory-item-missing\n\t\t\t * @param {String} name The name of the missing component.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'componentfactory-item-missing: The required component is not registered in the factory.', { name }\n\t\t\t);\n\t\t}\n\n\t\treturn this._components.get( getNormalized( name ) ).callback( this.editor.locale );\n\t}\n\n\t/**\n\t * Checks if a component of a given name is registered in the factory.\n\t *\n\t * @param {String} name The name of the component.\n\t * @returns {Boolean}\n\t */\n\thas( name ) {\n\t\treturn this._components.has( getNormalized( name ) );\n\t}\n}\n\n//\n// Ensures that the component name used as the key in the internal map is in lower case.\n//\n// @private\n// @param {String} name\n// @returns {String}\nfunction getNormalized( name ) {\n\treturn String( name ).toLowerCase();\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/editableui/editableuiview\n */\n\nimport View from '../view';\n\n/**\n * The editable UI view class.\n *\n * @extends module:ui/view~View\n */\nexport default class EditableUIView extends View {\n\t/**\n\t * Creates an instance of EditableUIView class.\n\t *\n\t * @param {module:utils/locale~Locale} [locale] The locale instance.\n\t * @param {HTMLElement} [editableElement] The editable element. If not specified, this view\n\t * should create it. Otherwise, the existing element should be used.\n\t */\n\tconstructor( locale, editableElement ) {\n\t\tsuper( locale );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tif ( editableElement ) {\n\t\t\tthis.element = this.editableElement = editableElement;\n\t\t}\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-content',\n\t\t\t\t\t'ck-editor__editable',\n\t\t\t\t\t'ck-rounded-corners',\n\t\t\t\t\tbind.to( 'isFocused', value => value ? 'ck-focused' : 'ck-blurred' )\n\t\t\t\t],\n\t\t\t\tcontenteditable: bind.to( 'isReadOnly', value => !value ),\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * Controls whether the editable is writable or not.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * Controls whether the editable is focused, i.e. the user is typing in it.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isFocused\n\t\t */\n\t\tthis.set( 'isFocused', false );\n\n\t\t/**\n\t\t * An external {@link #editableElement} passed into the constructor, which also means\n\t\t * the view will not render its {@link #template}.\n\t\t *\n\t\t * @member {HTMLElement} #externalElement\n\t\t */\n\t\tthis.externalElement = editableElement;\n\n\t\t/**\n\t\t * The element which is the main editable element (usually the one with `contentEditable=\"true\"`).\n\t\t *\n\t\t * @readonly\n\t\t * @member {HTMLElement} #editableElement\n\t\t */\n\t}\n\n\t/**\n\t * Renders the view by either applying the {@link #template} to the existing\n\t * {@link #editableElement} or assigning {@link #element} as {@link #editableElement}.\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\tif ( this.externalElement ) {\n\t\t\tthis.template.apply( this.element = this.externalElement );\n\t\t} else {\n\t\t\tthis.editableElement = this.element;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tif ( this.externalElement ) {\n\t\t\tthis.template.revert( this.externalElement );\n\t\t}\n\n\t\tsuper.destroy();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module ui/editableui/inline/inlineeditableuiview\n */\nimport EditableUIView from '../../editableui/editableuiview';\n/**\n * The inline editable UI class implementing an inline {@link module:ui/editableui/editableuiview~EditableUIView}.\n *\n * @extends module:ui/editableui/editableuiview~EditableUIView\n */\nexport default class InlineEditableUIView extends EditableUIView {\n    /**\n\t * Creates an instance of the InlineEditableUIView class.\n\t *\n\t * @param {module:utils/locale~Locale} [locale] The locale instance.\n\t * @param {HTMLElement} [editableElement] The editable element. If not specified, the\n\t * {@link module:ui/editableui/editableuiview~EditableUIView}\n\t * will create it. Otherwise, the existing element will be used.\n\t */\n    constructor(locale, editableElement) {\n        super(locale, editableElement);\n        const bind = this.bindTemplate;\n        const t = this.t;\n        /**\n\t\t * The name of the editable UI view.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #name\n\t\t */\n        this.set('name', null);\n        const getLabel = value => {\n            return t('Rich Text Editor, %0', [value]);\n        };\n        this.extendTemplate({\n            attributes: {\n                role: 'textbox',\n                'aria-label': bind.to('name', getLabel),\n                class: 'ck-editor__editable_inline'\n            }\n        });\n    }\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/dataprocessor/basichtmlwriter\n */\n\n/* globals document */\n\n/**\n * Basic HTML writer. It uses the native `innerHTML` property for basic conversion\n * from a document fragment to an HTML string.\n *\n * @implements module:engine/dataprocessor/htmlwriter~HtmlWriter\n */\nexport default class BasicHtmlWriter {\n\t/**\n\t * Returns an HTML string created from the document fragment.\n\t *\n\t * @param {DocumentFragment} fragment\n\t * @returns {String}\n\t */\n\tgetHtml( fragment ) {\n\t\tconst doc = document.implementation.createHTMLDocument( '' );\n\t\tconst container = doc.createElement( 'div' );\n\t\tcontainer.appendChild( fragment );\n\n\t\treturn container.innerHTML;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/dataprocessor/htmldataprocessor\n */\n\n/* globals document, DOMParser */\n\nimport BasicHtmlWriter from './basichtmlwriter';\nimport DomConverter from '../view/domconverter';\nimport { NBSP_FILLER } from '../view/filler';\n\n/**\n * The HTML data processor class.\n * This data processor implementation uses HTML as input and output data.\n *\n * @implements module:engine/dataprocessor/dataprocessor~DataProcessor\n */\nexport default class HtmlDataProcessor {\n\t/**\n\t * Creates a new instance of the HTML data processor class.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * A DOM parser instance used to parse an HTML string to an HTML document.\n\t\t *\n\t\t * @private\n\t\t * @member {DOMParser}\n\t\t */\n\t\tthis._domParser = new DOMParser();\n\n\t\t/**\n\t\t * A DOM converter used to convert DOM elements to view elements.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis._domConverter = new DomConverter( { blockFiller: NBSP_FILLER } );\n\n\t\t/**\n\t\t * A basic HTML writer instance used to convert DOM elements to an HTML string.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/dataprocessor/basichtmlwriter~BasicHtmlWriter}\n\t\t */\n\t\tthis._htmlWriter = new BasicHtmlWriter();\n\t}\n\n\t/**\n\t * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}\n\t * to data format &mdash; in this case to an HTML string.\n\t *\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment\n\t * @returns {String} HTML string.\n\t */\n\ttoData( viewFragment ) {\n\t\t// Convert view DocumentFragment to DOM DocumentFragment.\n\t\tconst domFragment = this._domConverter.viewToDom( viewFragment, document );\n\n\t\t// Convert DOM DocumentFragment to HTML output.\n\t\treturn this._htmlWriter.getHtml( domFragment );\n\t}\n\n\t/**\n\t * Converts the provided HTML string to a view tree.\n\t *\n\t * @param {String} data An HTML string.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} A converted view element.\n\t */\n\ttoView( data ) {\n\t\t// Convert input HTML data to DOM DocumentFragment.\n\t\tconst domFragment = this._toDom( data );\n\n\t\t// Convert DOM DocumentFragment to view DocumentFragment.\n\t\treturn this._domConverter.domToView( domFragment );\n\t}\n\n\t/**\n\t * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from\n\t * the provided data.\n\t *\n\t * @private\n\t * @param {String} data\n\t * @returns {DocumentFragment}\n\t */\n\t_toDom( data ) {\n\t\tconst document = this._domParser.parseFromString( data, 'text/html' );\n\t\tconst fragment = document.createDocumentFragment();\n\t\tconst nodes = document.body.childNodes;\n\n\t\twhile ( nodes.length > 0 ) {\n\t\t\tfragment.appendChild( nodes[ 0 ] );\n\t\t}\n\n\t\treturn fragment;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/elementreplacer\n */\n\n/**\n * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove\n * the original elements from the DOM.\n */\nexport default class ElementReplacer {\n\tconstructor() {\n\t\t/**\n\t\t * The elements replaced by {@link #replace} and their replacements.\n\t\t *\n\t\t * @private\n\t\t * @member {Array.<Object>}\n\t\t */\n\t\tthis._replacedElements = [];\n\t}\n\n\t/**\n\t * Hides the `element` and, if specified, inserts the the given element next to it.\n\t *\n\t * The effect of this method can be reverted by {@link #restore}.\n\t *\n\t * @param {HTMLElement} element The element to replace.\n\t * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.\n\t */\n\treplace( element, newElement ) {\n\t\tthis._replacedElements.push( { element, newElement } );\n\n\t\telement.style.display = 'none';\n\n\t\tif ( newElement ) {\n\t\t\telement.parentNode.insertBefore( newElement, element.nextSibling );\n\t\t}\n\t}\n\n\t/**\n\t * Restores what {@link #replace} did.\n\t */\n\trestore() {\n\t\tthis._replacedElements.forEach( ( { element, newElement } ) => {\n\t\t\telement.style.display = '';\n\n\t\t\tif ( newElement ) {\n\t\t\t\tnewElement.remove();\n\t\t\t}\n\t\t} );\n\n\t\tthis._replacedElements = [];\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/editor/utils/dataapimixin\n */\n\n/**\n * Implementation of the {@link module:core/editor/utils/dataapimixin~DataApi}.\n *\n * @mixin DataApiMixin\n * @implements module:core/editor/utils/dataapimixin~DataApi\n */\nconst DataApiMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\tsetData( data ) {\n\t\tthis.data.set( data );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tgetData() {\n\t\treturn this.data.get();\n\t}\n};\n\nexport default DataApiMixin;\n\n/**\n * Interface defining editor methods for setting and getting data to and from the editor's main root element\n * using the {@link module:core/editor/editor~Editor#data data pipeline}.\n *\n * This interface is not a part of the {@link module:core/editor/editor~Editor} class because one may want to implement\n * an editor with multiple root elements, in which case the methods for setting and getting data will need to be implemented\n * differently.\n *\n * @interface DataApi\n */\n\n/**\n * Sets the data in the editor.\n *\n *\t\teditor.setData( '<p>This is editor!</p>' );\n *\n * By default the editor accepts HTML. This can be controlled by injecting a different data processor.\n * See the {@glink features/markdown Markdown output} guide for more details.\n *\n * Note: Not only is the format of the data configurable, but the type of the `setData()`'s parameter does not\n * have to be a string either. You can e.g. accept an object or a DOM `DocumentFragment` if you consider this\n * the right format for you.\n *\n * @method #setData\n * @param {String} data Input data.\n */\n\n/**\n * Gets the data from the editor.\n *\n *\t\teditor.getData(); // -> '<p>This is editor!</p>'\n *\n * By default the editor outputs HTML. This can be controlled by injecting a different data processor.\n * See the {@glink features/markdown Markdown output} guide for more details.\n *\n * Note: Not only is the format of the data configurable, but the type of the `getData()`'s return value does not\n * have to be a string either. You can e.g. return an object or a DOM `DocumentFragment`  if you consider this\n * the right format for you.\n *\n * @method #getData\n * @returns {String} Output data.\n */\n","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport setDataInElement from '@ckeditor/ckeditor5-utils/src/dom/setdatainelement';\n\n/**\n * @module core/editor/utils/elementapimixin\n */\n\n/**\n * Implementation of the {@link module:core/editor/utils/elementapimixin~ElementApi}.\n *\n * @mixin ElementApiMixin\n * @implements module:core/editor/utils/elementapimixin~ElementApi\n */\nconst ElementApiMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\tupdateSourceElement() {\n\t\tif ( !this.sourceElement ) {\n\t\t\t/**\n\t\t\t * Cannot update the source element of a detached editor.\n\t\t\t *\n\t\t\t * The {@link ~ElementApi#updateSourceElement `updateSourceElement()`} method cannot be called if you did not\n\t\t\t * pass an element to `Editor.create()`.\n\t\t\t *\n\t\t\t * @error editor-missing-sourceelement\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'editor-missing-sourceelement: Cannot update the source element of a detached editor.' );\n\t\t}\n\n\t\tsetDataInElement( this.sourceElement, this.data.get() );\n\t}\n};\n\nexport default ElementApiMixin;\n\n/**\n * Interface describing an editor that replaced a DOM element (was \"initialized on an element\").\n *\n * Such an editor should provide a method to\n * {@link module:core/editor/utils/elementapimixin~ElementApi#updateSourceElement update the replaced element with the current data}.\n *\n * @interface ElementApi\n */\n\n/**\n * The element on which the editor has been initialized.\n *\n * @readonly\n * @member {HTMLElement} #sourceElement\n */\n\n/**\n * Updates the {@link #sourceElement editor source element}'s content with the data.\n *\n * @method #updateSourceElement\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/setdatainelement\n */\n\n/* globals HTMLTextAreaElement */\n\n/**\n * Sets data in a given element.\n *\n * @param {HTMLElement} el The element in which the data will be set.\n * @param {String} data The data string.\n */\nexport default function setDataInElement( el, data ) {\n\tif ( el instanceof HTMLTextAreaElement ) {\n\t\tel.value = data;\n\t}\n\n\tel.innerHTML = data;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/plugin\n */\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The base class for CKEditor plugin classes.\n *\n * @implements module:core/plugin~PluginInterface\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * The editor instance.\n\t\t *\n\t\t * Note that most editors implement the {@link module:core/editor/editorwithui~EditorWithUI} interface in addition\n\t\t * to the base {@link module:core/editor/editor~Editor} interface. However, editors with an external UI\n\t\t * (i.e. Bootstrap-based) or a headless editor may not implement the {@link module:core/editor/editorwithui~EditorWithUI}\n\t\t * interface.\n\t\t *\n\t\t * Because of above, to make plugins more universal, it is recommended to split features into:\n\t\t *  - The \"editing\" part that only uses the {@link module:core/editor/editor~Editor} interface.\n\t\t *  - The \"UI\" part that uses both the {@link module:core/editor/editor~Editor} interface and\n\t\t *  the {@link module:core/editor/editorwithui~EditorWithUI} interface.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor} #editor\n\t\t */\n\t\tthis.editor = editor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n}\n\nmix( Plugin, ObservableMixin );\n\n/**\n * The base interface for CKEditor plugins.\n *\n * In its minimal form it can be a simple function (it will be used as a constructor) that accepts\n * {@link module:core/editor/editor~Editor the editor} as a parameter.\n * It can also implement a few methods which, when present, will be used to properly initialize and destroy the plugin.\n *\n *\t\t// A simple plugin that enables a data processor.\n *\t\tfunction MyPlugin( editor ) {\n *\t\t\teditor.data.processor = new MyDataProcessor();\n *\t\t}\n *\n * In most cases, however, you will want to inherit from the {@link module:core/plugin~Plugin} class which implements the\n * {@link module:utils/observablemixin~ObservableMixin} and is, therefore, more convenient:\n *\n *\t\tclass MyPlugin extends Plugin {\n *\t\t\tinit() {\n *\t\t\t\t// `listenTo()` and `editor` are available thanks to `Plugin`.\n *\t\t\t\t// By using `listenTo()` you will ensure that the listener is removed when\n *\t\t\t\t// the plugin is destroyed.\n *\t\t\t\tthis.listenTo( this.editor, 'dataReady', () => {\n *\t\t\t\t\t// Do something when the data is ready.\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n *\n * @interface PluginInterface\n */\n\n/**\n * Creates a new plugin instance. This is the first step of the plugin initialization.\n * See also {@link #init} and {@link #afterInit}.\n *\n * A plugin is always instantiated after its {@link module:core/plugin~PluginInterface.requires dependencies} and the\n * {@link #init} and {@link #afterInit} methods are called in the same order.\n *\n * Usually, you will want to put your plugin's initialization code in the {@link #init} method.\n * The constructor can be understood as \"before init\" and used in special cases, just like\n * {@link #afterInit} serves the special \"after init\" scenarios (e.g.the code which depends on other\n * plugins, but which does not {@link module:core/plugin~PluginInterface.requires explicitly require} them).\n *\n * @method #constructor\n * @param {module:core/editor/editor~Editor} editor\n */\n\n/**\n * An array of plugins required by this plugin.\n *\n * To keep the plugin class definition tight it is recommended to define this property as a static getter:\n *\n *\t\timport Image from './image.js';\n *\n *\t\texport default class ImageCaption {\n *\t\t\tstatic get requires() {\n *\t\t\t\treturn [ Image ];\n *\t\t\t}\n *\t\t}\n *\n * @static\n * @readonly\n * @member {Array.<Function>|undefined} module:core/plugin~PluginInterface.requires\n */\n\n/**\n * An optional name of the plugin. If set, the plugin will be available in\n * {@link module:core/plugincollection~PluginCollection#get} by its\n * name and its constructor. If not, then only by its constructor.\n *\n * The name should reflect the constructor name.\n *\n * To keep the plugin class definition tight it is recommended to define this property as a static getter:\n *\n *\t\texport default class ImageCaption {\n *\t\t\tstatic get pluginName() {\n *\t\t\t\treturn 'ImageCaption';\n *\t\t\t}\n *\t\t}\n *\n * Note: The native `Function.name` property could not be used to keep the plugin name because\n * it will be mangled during code minification.\n *\n * Naming a plugin is necessary to enable removing it through the\n * {@link module:core/editor/editorconfig~EditorConfig#removePlugins `config.removePlugins`} option.\n *\n * @static\n * @readonly\n * @member {String|undefined} module:core/plugin~PluginInterface.pluginName\n */\n\n/**\n * The second stage (after plugin {@link #constructor}) of plugin initialization.\n * Unlike the plugin constructor this method can be asynchronous.\n *\n * A plugin's `init()` method is called after its {@link module:core/plugin~PluginInterface.requires dependencies} are initialized,\n * so in the same order as constructors of these plugins.\n *\n * **Note:** This method is optional. A plugin instance does not need to have it defined.\n *\n * @method #init\n * @returns {null|Promise}\n */\n\n/**\n * The third (and last) stage of plugin initialization. See also {@link #constructor} and {@link #init}.\n *\n * **Note:** This method is optional. A plugin instance does not need to have it defined.\n *\n * @method #afterInit\n * @returns {null|Promise}\n */\n\n/**\n * Destroys the plugin.\n *\n * **Note:** This method is optional. A plugin instance does not need to have it defined.\n *\n * @method #destroy\n * @returns {null|Promise}\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/datatransfer\n */\n\n/**\n * Facade over the native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.\n */\nexport default class DataTransfer {\n\tconstructor( nativeDataTransfer ) {\n\t\t/**\n\t\t * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<File>} #files\n\t\t */\n\t\tthis.files = getFiles( nativeDataTransfer );\n\n\t\t/**\n\t\t * The native DataTransfer object.\n\t\t *\n\t\t * @private\n\t\t * @member {DataTransfer} #_native\n\t\t */\n\t\tthis._native = nativeDataTransfer;\n\t}\n\n\t/**\n\t * Returns an array of available native content types.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tget types() {\n\t\treturn this._native.types;\n\t}\n\n\t/**\n\t * Gets data from the data transfer by its mime type.\n\t *\n\t *\t\tdataTransfer.getData( 'text/plain' );\n\t *\n\t * @param {String} type The mime type. E.g. `text/html` or `text/plain`.\n\t * @returns {String}\n\t */\n\tgetData( type ) {\n\t\treturn this._native.getData( type );\n\t}\n\n\t/**\n\t * Sets data in the data transfer.\n\t *\n\t * @param {String} type The mime type. E.g. `text/html` or `text/plain`.\n\t * @param {String} data\n\t */\n\tsetData( type, data ) {\n\t\tthis._native.setData( type, data );\n\t}\n}\n\nfunction getFiles( nativeDataTransfer ) {\n\t// DataTransfer.files and items are Array-like and might not have an iterable interface.\n\tconst files = nativeDataTransfer.files ? Array.from( nativeDataTransfer.files ) : [];\n\tconst items = nativeDataTransfer.items ? Array.from( nativeDataTransfer.items ) : [];\n\n\tif ( files.length ) {\n\t\treturn files;\n\t}\n\t// Chrome have empty DataTransfer.files, but let get files through the items interface.\n\treturn items\n\t\t.filter( item => item.kind === 'file' )\n\t\t.map( item => item.getAsFile() );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/clipboardobserver\n */\n\nimport DomEventObserver from '@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver';\nimport DataTransfer from './datatransfer';\n\n/**\n * Clipboard events observer.\n *\n * Fires the following events:\n *\n * * {@link module:engine/view/document~Document#event:clipboardInput}\n * * {@link module:engine/view/document~Document#event:dragover}\n * * {@link module:engine/view/document~Document#event:drop}\n * * {@link module:engine/view/document~Document#event:paste}\n * * {@link module:engine/view/document~Document#event:copy}\n * * {@link module:engine/view/document~Document#event:cut}\n *\n * Note that this observer is not available by default. To make it available it needs to be added to\n * {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\nexport default class ClipboardObserver extends DomEventObserver {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tconst viewDocument = this.document;\n\n\t\tthis.domEventType = [ 'paste', 'copy', 'cut', 'drop', 'dragover' ];\n\n\t\tthis.listenTo( viewDocument, 'paste', handleInput, { priority: 'low' } );\n\t\tthis.listenTo( viewDocument, 'drop', handleInput, { priority: 'low' } );\n\n\t\tfunction handleInput( evt, data ) {\n\t\t\tdata.preventDefault();\n\n\t\t\tconst targetRanges = data.dropRange ? [ data.dropRange ] : Array.from( viewDocument.selection.getRanges() );\n\n\t\t\tviewDocument.fire( 'clipboardInput', {\n\t\t\t\tdataTransfer: data.dataTransfer,\n\t\t\t\ttargetRanges\n\t\t\t} );\n\t\t}\n\t}\n\n\tonDomEvent( domEvent ) {\n\t\tconst evtData = {\n\t\t\tdataTransfer: new DataTransfer( domEvent.clipboardData ? domEvent.clipboardData : domEvent.dataTransfer )\n\t\t};\n\n\t\tif ( domEvent.type == 'drop' ) {\n\t\t\tevtData.dropRange = getDropViewRange( this.view, domEvent );\n\t\t}\n\n\t\tthis.fire( domEvent.type, domEvent, evtData );\n\t}\n}\n\nfunction getDropViewRange( view, domEvent ) {\n\tconst domDoc = domEvent.target.ownerDocument;\n\tconst x = domEvent.clientX;\n\tconst y = domEvent.clientY;\n\tlet domRange;\n\n\t// Webkit & Blink.\n\tif ( domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint( x, y ) ) {\n\t\tdomRange = domDoc.caretRangeFromPoint( x, y );\n\t}\n\t// FF.\n\telse if ( domEvent.rangeParent ) {\n\t\tdomRange = domDoc.createRange();\n\t\tdomRange.setStart( domEvent.rangeParent, domEvent.rangeOffset );\n\t\tdomRange.collapse( true );\n\t}\n\n\tif ( domRange ) {\n\t\treturn view.domConverter.domRangeToView( domRange );\n\t} else {\n\t\treturn view.document.selection.getFirstRange();\n\t}\n}\n\n/**\n * Fired as a continuation of {@link #event:paste} and {@link #event:drop} events.\n * It's part of the {@link module:clipboard/clipboard~Clipboard \"clipboard pipeline\"}.\n *\n * Fired with a `dataTransfer` which comes from the clipboard and which content should be processed\n * and inserted into the editor.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:engine/view/document~Document#event:clipboardInput\n * @param {Object} data Event data.\n * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.\n * @param {Array.<module:engine/view/range~Range>} data.targetRanges Ranges which are the target of the operation\n * (usually – into which the content should be inserted).\n * If clipboard input was triggered by a paste operation, then these are the selection ranges. If by a drop operation,\n * then it's the drop position (which can be different than the selection at the moment of drop).\n */\n\n/**\n * Fired when user drags content over one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:dragover\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user dropped content into one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:drop\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n * @param {module:engine/view/range~Range} dropRange The position into which the content is dropped.\n */\n\n/**\n * Fired when user pasted content into one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:engine/view/document~Document#event:clipboardInput\n * @event module:engine/view/document~Document#event:paste\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user copied content from one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @event module:engine/view/document~Document#event:copy\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * Fired when user cut content from one of the editables.\n *\n * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}\n * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.\n * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @event module:engine/view/document~Document#event:cut\n * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.\n */\n\n/**\n * The value of the {@link module:engine/view/document~Document#event:paste},\n * {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut} events.\n *\n * In order to access clipboard data use `dataTransfer` property.\n *\n * @class module:clipboard/clipboardobserver~ClipboardEventData\n * @extends module:engine/view/observer/domeventdata~DomEventData\n */\n\n/**\n * Data transfer instance.\n *\n * @readonly\n * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboardobserver~ClipboardEventData#dataTransfer\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/utils/viewtoplaintext\n */\n\n// Elements which should not have empty-line padding.\n// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure\n// together (like `<li>`) so it is better to separate them by only one \"\\n\".\nconst smallPaddingElements = [ 'figcaption', 'li' ];\n\n/**\n * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.\n *\n * @param {module:engine/view/item~Item} viewItem View item to convert.\n * @returns {String} Plain text representation of `viewItem`.\n */\nexport default function viewToPlainText( viewItem ) {\n\tlet text = '';\n\n\tif ( viewItem.is( 'text' ) || viewItem.is( 'textProxy' ) ) {\n\t\t// If item is `Text` or `TextProxy` simple take its text data.\n\t\ttext = viewItem.data;\n\t} else if ( viewItem.is( 'img' ) && viewItem.hasAttribute( 'alt' ) ) {\n\t\t// Special case for images - use alt attribute if it is provided.\n\t\ttext = viewItem.getAttribute( 'alt' );\n\t} else {\n\t\t// Other elements are document fragments, attribute elements or container elements.\n\t\t// They don't have their own text value, so convert their children.\n\t\tlet prev = null;\n\n\t\tfor ( const child of viewItem.getChildren() ) {\n\t\t\tconst childText = viewToPlainText( child );\n\n\t\t\t// Separate container element children with one or more new-line characters.\n\t\t\tif ( prev && ( prev.is( 'containerElement' ) || child.is( 'containerElement' ) ) ) {\n\t\t\t\tif ( smallPaddingElements.includes( prev.name ) || smallPaddingElements.includes( child.name ) ) {\n\t\t\t\t\ttext += '\\n';\n\t\t\t\t} else {\n\t\t\t\t\ttext += '\\n\\n';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext += childText;\n\t\t\tprev = child;\n\t\t}\n\t}\n\n\treturn text;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/command\n */\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The base class for CKEditor commands.\n *\n * Commands are the main way to manipulate editor contents and state. They are mostly used by UI elements (or by other\n * commands) to make changes in the model. Commands are available in every part of code that has access to\n * the {@link module:core/editor/editor~Editor editor} instance.\n *\n * Instances of registered commands can be retrieved from {@link module:core/editor/editor~Editor#commands}.\n * The easiest way to execute a command is through {@link module:core/editor/editor~Editor#execute}.\n *\n * By default commands are disabled when the editor is in {@link module:core/editor/editor~Editor#isReadOnly read-only} mode.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Command {\n\t/**\n\t * Creates a new `Command` instance.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor Editor on which this command will be used.\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * The editor on which this command will be used.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor}\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * The value of a command. Concrete command class should define what it represents.\n\t\t *\n\t\t * For example, the `bold` command's value is whether the selection starts in a bolded text.\n\t\t * And the value of the `link` command may be an object with links details.\n\t\t *\n\t\t * It's possible for a command to have no value (e.g. for stateless actions such as `imageUpload`).\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member #value\n\t\t */\n\t\tthis.set( 'value', undefined );\n\n\t\t/**\n\t\t * Flag indicating whether a command is enabled or disabled.\n\t\t * A disabled command should do nothing when executed.\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member {Boolean} #isEnabled\n\t\t */\n\t\tthis.set( 'isEnabled', false );\n\n\t\tthis.decorate( 'execute' );\n\n\t\t// By default every command is refreshed when changes are applied to the model.\n\t\tthis.listenTo( this.editor.model.document, 'change', () => {\n\t\t\tthis.refresh();\n\t\t} );\n\n\t\tthis.on( 'execute', evt => {\n\t\t\tif ( !this.isEnabled ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// By default commands are disabled when the editor is in read-only mode.\n\t\tthis.listenTo( editor, 'change:isReadOnly', ( evt, name, value ) => {\n\t\t\tif ( value ) {\n\t\t\t\tthis.on( 'set:isEnabled', forceDisable, { priority: 'highest' } );\n\t\t\t\tthis.isEnabled = false;\n\t\t\t} else {\n\t\t\t\tthis.off( 'set:isEnabled', forceDisable );\n\t\t\t\tthis.refresh();\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} property\n\t * in this method.\n\t *\n\t * This method is automatically called when\n\t * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.\n\t */\n\trefresh() {\n\t\tthis.isEnabled = true;\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute}\n\t * to the command.\n\t *\n\t * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).\n\t * This behavior is implemented by a high priority listener to the {@link #event:execute} event.\n\t *\n\t * @fires execute\n\t */\n\texecute() {}\n\n\t/**\n\t * Destroys the command.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Event fired by the {@link #execute} method. The command action is a listener to this event so it's\n\t * possible to change/cancel the behavior of the command by listening to this event.\n\t *\n\t * See {@link module:utils/observablemixin~ObservableMixin.decorate} for more information and samples.\n\t *\n\t * **Note:** This event is fired even if command is disabled. However, it is automatically blocked\n\t * by a high priority listener in order to prevent command execution.\n\t *\n\t * @event execute\n\t */\n}\n\nmix( Command, ObservableMixin );\n\n// Helper function that forces command to be disabled.\nfunction forceDisable( evt ) {\n\tevt.return = false;\n\tevt.stop();\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module enter/entercommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\n/**\n * Enter command. It is used by the {@link module:enter/enter~Enter Enter feature} to handle the <kbd>Enter</kbd> key.\n *\n * @extends module:core/command~Command\n */\nexport default class EnterCommand extends Command {\n\t/**\n\t * @inheritDoc\n\t */\n\texecute() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tmodel.change( writer => {\n\t\t\tenterBlock( this.editor.model, writer, doc.selection, model.schema );\n\t\t\tthis.fire( 'afterExecute', { writer } );\n\t\t} );\n\t}\n}\n\n// Creates a new block in the way that the <kbd>Enter</kbd> key is expected to work.\n//\n// @param {module:engine/model~Model} model\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n// Selection on which the action should be performed.\n// @param {module:engine/model/schema~Schema} schema\nfunction enterBlock( model, writer, selection, schema ) {\n\tconst isSelectionEmpty = selection.isCollapsed;\n\tconst range = selection.getFirstRange();\n\tconst startElement = range.start.parent;\n\tconst endElement = range.end.parent;\n\n\t// Don't touch the roots and other limit elements.\n\tif ( schema.isLimit( startElement ) || schema.isLimit( endElement ) ) {\n\t\t// Delete the selected content but only if inside a single limit element.\n\t\t// Abort, when crossing limit elements boundary (e.g. <limit1>x[x</limit1>donttouchme<limit2>y]y</limit2>).\n\t\t// This is an edge case and it's hard to tell what should actually happen because such a selection\n\t\t// is not entirely valid.\n\t\tif ( !isSelectionEmpty && startElement == endElement ) {\n\t\t\tmodel.deleteContent( selection );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif ( isSelectionEmpty ) {\n\t\tsplitBlock( writer, selection, range.start );\n\t} else {\n\t\tconst leaveUnmerged = !( range.start.isAtStart && range.end.isAtEnd );\n\t\tconst isContainedWithinOneElement = ( startElement == endElement );\n\n\t\tmodel.deleteContent( selection, { leaveUnmerged } );\n\n\t\tif ( leaveUnmerged ) {\n\t\t\t// Partially selected elements.\n\t\t\t//\n\t\t\t// <h>x[xx]x</h>\t\t-> <h>x^x</h>\t\t\t-> <h>x</h><h>^x</h>\n\t\t\tif ( isContainedWithinOneElement ) {\n\t\t\t\tsplitBlock( writer, selection, selection.focus );\n\t\t\t}\n\t\t\t// Selection over multiple elements.\n\t\t\t//\n\t\t\t// <h>x[x</h><p>y]y<p>\t-> <h>x^</h><p>y</p>\t-> <h>x</h><p>^y</p>\n\t\t\telse {\n\t\t\t\twriter.setSelection( endElement, 0 );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction splitBlock( writer, selection, splitPos ) {\n\tconst oldElement = splitPos.parent;\n\tconst newElement = new oldElement.constructor( oldElement.name, oldElement.getAttributes() );\n\n\tif ( splitPos.isAtEnd ) {\n\t\t// If the split is at the end of element, instead of splitting, just create a clone of position's parent\n\t\t// element and insert it after split element. The result is the same but less operations are done\n\t\t// and it's more semantically correct (when it comes to operational transformation).\n\t\twriter.insert( newElement, splitPos.parent, 'after' );\n\t} else if ( splitPos.isAtStart ) {\n\t\t// If the split is at the start of element, instead of splitting, just create a clone of position's parent\n\t\t// element and insert it before split element. The result is the same but less operations are done\n\t\t// and it's more semantically correct (when it comes to operational transformation).\n\t\twriter.insert( newElement, splitPos.parent, 'before' );\n\t} else {\n\t\twriter.split( splitPos );\n\t}\n\n\twriter.setSelection( splitPos.parent.nextSibling, 0 );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module enter/enterobserver\n */\n\nimport Observer from '@ckeditor/ckeditor5-engine/src/view/observer/observer';\nimport DomEventData from '@ckeditor/ckeditor5-engine/src/view/observer/domeventdata';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * Enter observer introduces the {@link module:engine/view/document~Document#event:enter} event.\n *\n * @extends module:engine/view/observer~Observer\n */\nexport default class EnterObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tconst doc = this.document;\n\n\t\tdoc.on( 'keydown', ( evt, data ) => {\n\t\t\tif ( this.isEnabled && data.keyCode == keyCodes.enter ) {\n\t\t\t\t// Save the event object to check later if it was stopped or not.\n\t\t\t\tlet event;\n\t\t\t\tdoc.once( 'enter', evt => ( event = evt ), { priority: 'highest' } );\n\n\t\t\t\tdoc.fire( 'enter', new DomEventData( doc, data.domEvent, {\n\t\t\t\t\tisSoft: data.shiftKey\n\t\t\t\t} ) );\n\n\t\t\t\t// Stop `keydown` event if `enter` event was stopped.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5/issues/753\n\t\t\t\tif ( event && event.stop.called ) {\n\t\t\t\t\tevt.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve() {}\n}\n\n/**\n * Event fired when the user presses the <kbd>Enter</kbd> key.\n *\n * Note: This event is fired by the {@link module:enter/enterobserver~EnterObserver observer}\n * (usually registered by the {@link module:enter/enter~Enter Enter feature} and\n * {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature}).\n *\n * @event module:engine/view/document~Document#event:enter\n * @param {module:engine/view/observer/domeventdata~DomEventData} data\n * @param {Boolean} data.isSoft Whether it's a soft enter (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or hard enter (<kbd>Enter</kbd>).\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\nimport Batch from '@ckeditor/ckeditor5-engine/src/model/batch';\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nexport default class ChangeBuffer {\n\t/**\n\t * Creates a new instance of the change buffer.\n\t *\n\t * @param {module:engine/model/model~Model} model\n\t * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n\t */\n\tconstructor( model, limit = 20 ) {\n\t\t/**\n\t\t * The model instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n\t\t * the {@link #batch batch} is set to a new one.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #size\n\t\t */\n\t\tthis.size = 0;\n\n\t\t/**\n\t\t * The maximum number of atomic changes which can be contained in one batch.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number} #limit\n\t\t */\n\t\tthis.limit = limit;\n\n\t\t/**\n\t\t * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isLocked\n\t\t */\n\t\tthis.isLocked = false;\n\n\t\t// The function to be called in order to notify the buffer about batches which appeared in the document.\n\t\t// The callback will check whether it is a new batch and in that case the buffer will be flushed.\n\t\t//\n\t\t// The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n\t\t// should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,\n\t\t// the characters typed after inserting the image should be added to a different batch than the characters typed before.\n\t\tthis._changeCallback = ( evt, batch ) => {\n\t\t\tif ( batch.type != 'transparent' && batch !== this._batch ) {\n\t\t\t\tthis._reset( true );\n\t\t\t}\n\t\t};\n\n\t\tthis._selectionChangeCallback = () => {\n\t\t\tthis._reset();\n\t\t};\n\n\t\tthis.model.document.on( 'change', this._changeCallback );\n\n\t\tthis.model.document.selection.on( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.on( 'change:attribute', this._selectionChangeCallback );\n\n\t\t/**\n\t\t * The current batch instance.\n\t\t *\n\t\t * @private\n\t\t * @member #_batch\n\t\t */\n\n\t\t/**\n\t\t * The callback to document the change event which later needs to be removed.\n\t\t *\n\t\t * @private\n\t\t * @member #_changeCallback\n\t\t */\n\n\t\t/**\n\t\t * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n\t\t *\n\t\t * @private\n\t\t * @member #_selectionChangeCallback\n\t\t */\n\t}\n\n\t/**\n\t * The current batch to which a feature should add its deltas. Once the {@link #size}\n\t * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @type {module:engine/model/batch~Batch}\n\t */\n\tget batch() {\n\t\tif ( !this._batch ) {\n\t\t\tthis._batch = new Batch();\n\t\t}\n\n\t\treturn this._batch;\n\t}\n\n\t/**\n\t * The input number of changes into the buffer. Once the {@link #size} is\n\t * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n\t *\n\t * @param {Number} changeCount The number of atomic changes to input.\n\t */\n\tinput( changeCount ) {\n\t\tthis.size += changeCount;\n\n\t\tif ( this.size >= this.limit ) {\n\t\t\tthis._reset( true );\n\t\t}\n\t}\n\n\t/**\n\t * Locks the buffer.\n\t */\n\tlock() {\n\t\tthis.isLocked = true;\n\t}\n\n\t/**\n\t * Unlocks the buffer.\n\t */\n\tunlock() {\n\t\tthis.isLocked = false;\n\t}\n\n\t/**\n\t * Destroys the buffer.\n\t */\n\tdestroy() {\n\t\tthis.model.document.off( 'change', this._changeCallback );\n\t\tthis.model.document.selection.off( 'change:range', this._selectionChangeCallback );\n\t\tthis.model.document.selection.off( 'change:attribute', this._selectionChangeCallback );\n\t}\n\n\t/**\n\t * Resets the change buffer.\n\t *\n\t * @private\n\t * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n\t */\n\t_reset( ignoreLock ) {\n\t\tif ( !this.isLocked || ignoreLock ) {\n\t\t\tthis._batch = null;\n\t\t\tthis.size = 0;\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/inputcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n *\n * @extends module:core/command~Command\n */\nexport default class InputCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {Number} undoStepSize The maximum number of atomic changes\n\t * which can be contained in one batch in the command buffer.\n\t */\n\tconstructor( editor, undoStepSize ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Typing's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {module:typing/utils/changebuffer~ChangeBuffer} #_buffer\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, undoStepSize );\n\t}\n\n\t/**\n\t * The current change buffer.\n\t *\n\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t */\n\tget buffer() {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._buffer.destroy();\n\t}\n\n\t/**\n\t * Executes the input command. It replaces the content within the given range with the given text.\n\t * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n\t * at the beginning of the range (which after the removal is a collapsed range).\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {String} [options.text=''] The text to be inserted.\n\t * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults\n\t * to the first range in the current selection.\n\t * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection\n\t * should be placed after the insertion. If not specified, the selection will be placed right after\n\t * the inserted text.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst text = options.text || '';\n\t\tconst textInsertions = text.length;\n\t\tconst range = options.range || doc.selection.getFirstRange();\n\t\tconst resultRange = options.resultRange;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tconst isCollapsedRange = range.isCollapsed;\n\n\t\t\tthis._buffer.lock();\n\n\t\t\tif ( !isCollapsedRange ) {\n\t\t\t\twriter.remove( range );\n\t\t\t}\n\n\t\t\tif ( text ) {\n\t\t\t\twriter.insertText( text, doc.selection.getAttributes(), range.start );\n\t\t\t}\n\n\t\t\tif ( resultRange ) {\n\t\t\t\twriter.setSelection( resultRange );\n\t\t\t} else if ( isCollapsedRange ) {\n\t\t\t\t// If range was collapsed just shift the selection by the number of inserted characters.\n\t\t\t\twriter.setSelection( range.start.getShiftedBy( textInsertions ) );\n\t\t\t}\n\n\t\t\tthis._buffer.unlock();\n\n\t\t\tthis._buffer.input( textInsertions );\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/utils/injectunsafekeystrokeshandling\n */\n\nimport Selection from '@ckeditor/ckeditor5-engine/src/model/selection';\n\nimport { getCode } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\n/**\n * Handles keystrokes which are unsafe for typing. This handler's logic is explained\n * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectUnsafeKeystrokesHandling( editor ) {\n\tlet latestCompositionSelection = null;\n\n\tconst model = editor.model;\n\tconst view = editor.editing.view;\n\tconst inputCommand = editor.commands.get( 'input' );\n\n\tview.document.on( 'keydown', ( evt, evtData ) => handleKeydown( evtData ), { priority: 'lowest' } );\n\n\tview.document.on( 'compositionstart', handleCompositionStart, { priority: 'lowest' } );\n\n\tview.document.on( 'compositionend', () => {\n\t\tlatestCompositionSelection = new Selection( model.document.selection );\n\t}, { priority: 'lowest' } );\n\n\t// Handles the keydown event. We need to guess whether such keystroke is going to result\n\t// in typing. If so, then before character insertion happens, any selected content needs\n\t// to be deleted. Otherwise the default browser deletion mechanism would be\n\t// triggered, resulting in:\n\t//\n\t// * Hundreds of mutations which could not be handled.\n\t// * But most importantly, loss of control over how the content is being deleted.\n\t//\n\t// The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)\n\t// to handle the event.\n\t//\n\t// @param {module:engine/view/observer/keyobserver~KeyEventData} evtData\n\tfunction handleKeydown( evtData ) {\n\t\tconst doc = model.document;\n\t\tconst isComposing = view.document.isComposing;\n\t\tconst isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual( doc.selection );\n\n\t\t// Reset stored composition selection.\n\t\tlatestCompositionSelection = null;\n\n\t\t// By relying on the state of the input command we allow disabling the entire input easily\n\t\t// by just disabling the input command. We could’ve used here the delete command but that\n\t\t// would mean requiring the delete feature which would block loading one without the other.\n\t\t// We could also check the editor.isReadOnly property, but that wouldn't allow to block\n\t\t// the input without blocking other features.\n\t\tif ( !inputCommand.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isSafeKeystroke( evtData ) || doc.selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If during composition, deletion should be prevented as it may remove composed sequence (#83).\n\t\tif ( isComposing && evtData.keyCode === 229 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is a `keydown` event fired with '229' keycode it might be related\n\t\t// to recent composition. Check if selection is the same as upon ending recent composition,\n\t\t// if so do not remove selected content as it will remove composed sequence (#83).\n\t\tif ( !isComposing && evtData.keyCode === 229 && isSelectionUnchanged ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\t// Handles the `compositionstart` event. It is used only in special cases to remove the contents\n\t// of a non-collapsed selection so composition itself does not result in complex mutations.\n\t//\n\t// The special case mentioned above is a situation in which the `keydown` event is fired after\n\t// `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection\n\t// contents (because it is too late and will break the composition) so the composition handler takes care of it.\n\tfunction handleCompositionStart() {\n\t\tconst doc = model.document;\n\t\tconst isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true;\n\n\t\t// If on `compositionstart` there is a non-collapsed selection which start and end have different parents\n\t\t// it means the `handleKeydown()` method did not remove its contents. It happens usually because\n\t\t// of different order of events (`compositionstart` before `keydown` - in Safari). In such cases\n\t\t// we need to remove selection contents on composition start (#83).\n\t\tif ( doc.selection.isCollapsed || isFlatSelection ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeleteSelectionContent();\n\t}\n\n\tfunction deleteSelectionContent() {\n\t\tconst buffer = inputCommand.buffer;\n\n\t\tbuffer.lock();\n\n\t\tmodel.enqueueChange( buffer.batch, () => {\n\t\t\tmodel.deleteContent( model.document.selection );\n\t\t} );\n\n\t\tbuffer.unlock();\n\t}\n}\n\nconst safeKeycodes = [\n\tgetCode( 'arrowUp' ),\n\tgetCode( 'arrowRight' ),\n\tgetCode( 'arrowDown' ),\n\tgetCode( 'arrowLeft' ),\n\t9, // Tab\n\t16, // Shift\n\t17, // Ctrl\n\t18, // Alt\n\t20, // CapsLock\n\t27, // Escape\n\t33, // PageUp\n\t34, // PageDown\n\t35, // Home\n\t36 // End\n];\n\n// Function keys.\nfor ( let code = 112; code <= 135; code++ ) {\n\tsafeKeycodes.push( code );\n}\n\n// Returns `true` if a keystroke should not cause any content change caused by \"typing\".\n//\n// Note: This implementation is very simple and will need to be refined with time.\n//\n// @private\n// @param {engine.view.observer.keyObserver.KeyEventData} keyData\n// @returns {Boolean}\nfunction isSafeKeystroke( keyData ) {\n\t// Keystrokes which contain Ctrl don't represent typing.\n\tif ( keyData.ctrlKey ) {\n\t\treturn true;\n\t}\n\n\treturn safeKeycodes.includes( keyData.keyCode );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/utils/utils\n */\n\nimport ViewText from '@ckeditor/ckeditor5-engine/src/view/text';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport diffToChanges from '@ckeditor/ckeditor5-utils/src/difftochanges';\n\n/**\n * Returns true if container children have mutated or more than a single text node was changed.\n *\n * @private\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n * @returns {Boolean}\n */\nexport function containerChildrenMutated( mutations ) {\n\tif ( mutations.length == 0 ) {\n\t\treturn false;\n\t}\n\n\t// Check if there is any mutation of `children` type or any mutation that changes more than one text node.\n\tfor ( const mutation of mutations ) {\n\t\tif ( mutation.type === 'children' && !getSingleTextNodeChange( mutation ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Returns change made to a single text node.\n *\n * @private\n * @param {module:engine/view/observer/mutationobserver~MutatedText|\n * module:engine/view/observer/mutationobserver~MutatedChildren} mutation\n * @returns {Object|undefined} Change object (see {@link module:utils/difftochanges~diffToChanges} output)\n * or undefined if more than a single text node was changed.\n */\nexport function getSingleTextNodeChange( mutation ) {\n\t// One new node.\n\tif ( mutation.newChildren.length - mutation.oldChildren.length != 1 ) {\n\t\treturn;\n\t}\n\n\t// Which is text.\n\tconst diffResult = diff( mutation.oldChildren, mutation.newChildren, compareChildNodes );\n\tconst changes = diffToChanges( diffResult, mutation.newChildren );\n\n\t// In case of [ delete, insert, insert ] the previous check will not exit.\n\tif ( changes.length > 1 ) {\n\t\treturn;\n\t}\n\n\tconst change = changes[ 0 ];\n\n\t// Which is text.\n\tif ( !( change.values[ 0 ] instanceof ViewText ) ) {\n\t\treturn;\n\t}\n\n\treturn change;\n}\n\n/**\n * Checks whether two view nodes are identical, which means they are the same object\n * or contain exactly same data (in case of text nodes).\n *\n * @private\n * @param {module:engine/view/node~Node} oldChild\n * @param {module:engine/view/node~Node} newChild\n * @returns {Boolean}\n */\nexport function compareChildNodes( oldChild, newChild ) {\n\tif ( oldChild instanceof ViewText && newChild instanceof ViewText ) {\n\t\treturn oldChild.data === newChild.data;\n\t} else {\n\t\treturn oldChild === newChild;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/difftochanges\n */\n\n/**\n * Creates a set of changes which need to be applied to the input in order to transform\n * it into the output. This function can be used with strings or arrays.\n *\n *\t\tconst input = Array.from( 'abc' );\n *\t\tconst output = Array.from( 'xaby' );\n *\t\tconst changes = diffToChanges( diff( input, output ), output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput.splice( change.index, 0, ...change.values );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput.splice( change.index, change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\tinput.join( '' ) == output.join( '' ); // -> true\n *\n * @param {Array.<'equal'|'insert'|'delete'>} diff Result of {@link module:utils/diff~diff}.\n * @param {String|Array} output The string or array which was passed as diff's output.\n * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input\n * in order to transform it into the output.\n */\nexport default function diffToChanges( diff, output ) {\n\tconst changes = [];\n\tlet index = 0;\n\tlet lastOperation;\n\n\tdiff.forEach( change => {\n\t\tif ( change == 'equal' ) {\n\t\t\tpushLast();\n\n\t\t\tindex++;\n\t\t} else if ( change == 'insert' ) {\n\t\t\tif ( isContinuationOf( 'insert' ) ) {\n\t\t\t\tlastOperation.values.push( output[ index ] );\n\t\t\t} else {\n\t\t\t\tpushLast();\n\n\t\t\t\tlastOperation = {\n\t\t\t\t\ttype: 'insert',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalues: [ output[ index ] ]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tindex++;\n\t\t} else /* if ( change == 'delete' ) */ {\n\t\t\tif ( isContinuationOf( 'delete' ) ) {\n\t\t\t\tlastOperation.howMany++;\n\t\t\t} else {\n\t\t\t\tpushLast();\n\n\t\t\t\tlastOperation = {\n\t\t\t\t\ttype: 'delete',\n\t\t\t\t\tindex,\n\t\t\t\t\thowMany: 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} );\n\n\tpushLast();\n\n\treturn changes;\n\n\tfunction pushLast() {\n\t\tif ( lastOperation ) {\n\t\t\tchanges.push( lastOperation );\n\t\t\tlastOperation = null;\n\t\t}\n\t}\n\n\tfunction isContinuationOf( expected ) {\n\t\treturn lastOperation && lastOperation.type == expected;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/utils/injecttypingmutationshandling\n */\n\nimport ModelRange from '@ckeditor/ckeditor5-engine/src/model/range';\nimport ViewPosition from '@ckeditor/ckeditor5-engine/src/view/position';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport DomConverter from '@ckeditor/ckeditor5-engine/src/view/domconverter';\n\nimport { getSingleTextNodeChange, containerChildrenMutated } from './utils';\n\n/**\n * Handles mutations caused by normal typing.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectTypingMutationsHandling( editor ) {\n\teditor.editing.view.document.on( 'mutations', ( evt, mutations, viewSelection ) => {\n\t\tnew MutationHandler( editor ).handle( mutations, viewSelection );\n\t} );\n}\n\n/**\n * Helper class for translating DOM mutations into model changes.\n *\n * @private\n */\nclass MutationHandler {\n\t/**\n\t * Creates an instance of the mutation handler.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t */\n\tconstructor( editor ) {\n\t\t/**\n\t\t * Editor instance for which mutations are handled.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:core/editor/editor~Editor} #editor\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * The editing controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/controller/editingcontroller~EditingController} #editing\n\t\t */\n\t\tthis.editing = this.editor.editing;\n\t}\n\n\t/**\n\t * Handles given mutations.\n\t *\n\t * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n\t * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\t * @param {module:engine/view/selection~Selection|null} viewSelection\n\t */\n\thandle( mutations, viewSelection ) {\n\t\tif ( containerChildrenMutated( mutations ) ) {\n\t\t\tthis._handleContainerChildrenMutations( mutations, viewSelection );\n\t\t} else {\n\t\t\tfor ( const mutation of mutations ) {\n\t\t\t\t// Fortunately it will never be both.\n\t\t\t\tthis._handleTextMutation( mutation, viewSelection );\n\t\t\t\tthis._handleTextNodeInsertion( mutation );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles situations when container's children mutated during input. This can happen when\n\t * the browser is trying to \"fix\" DOM in certain situations. For example, when the user starts to type\n\t * in `<p><a href=\"\"><i>Link{}</i></a></p>`, the browser might change the order of elements\n\t * to `<p><i><a href=\"\">Link</a>x{}</i></p>`. A similar situation happens when the spell checker\n\t * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.\n\t *\n\t * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation\n\t * and then compared with the current model to calculate the proper text change.\n\t *\n\t * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled\n\t * in {@link #_handleTextMutation}).\n\t *\n\t * @private\n\t * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n\t * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\t * @param {module:engine/view/selection~Selection|null} viewSelection\n\t */\n\t_handleContainerChildrenMutations( mutations, viewSelection ) {\n\t\t// Get common ancestor of all mutations.\n\t\tconst mutationsCommonAncestor = getMutationsContainer( mutations );\n\n\t\t// Quit if there is no common ancestor.\n\t\tif ( !mutationsCommonAncestor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domConverter = this.editor.editing.view.domConverter;\n\n\t\t// Get common ancestor in DOM.\n\t\tconst domMutationCommonAncestor = domConverter.mapViewToDom( mutationsCommonAncestor );\n\n\t\t// Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.\n\t\t// This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.\n\t\tconst freshDomConverter = new DomConverter();\n\t\tconst modelFromCurrentDom = this.editor.data.toModel(\n\t\t\tfreshDomConverter.domToView( domMutationCommonAncestor )\n\t\t).getChild( 0 );\n\n\t\t// Current model.\n\t\tconst currentModel = this.editor.editing.mapper.toModelElement( mutationsCommonAncestor );\n\n\t\t// If common ancestor is not mapped, do not do anything. It probably is a parent of another view element.\n\t\t// That means that we would need to diff model elements (see `if` below). Better return early instead of\n\t\t// trying to get a reasonable model ancestor. It will fell into the `if` below anyway.\n\t\t// This situation happens for example for lists. If `<ul>` is a common ancestor, `currentModel` is `undefined`\n\t\t// because `<ul>` is not mapped (`<li>`s are).\n\t\t// See https://github.com/ckeditor/ckeditor5/issues/718.\n\t\tif ( !currentModel ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get children from both ancestors.\n\t\tconst modelFromDomChildren = Array.from( modelFromCurrentDom.getChildren() );\n\t\tconst currentModelChildren = Array.from( currentModel.getChildren() );\n\n\t\t// Remove the last `<softBreak>` from the end of `modelFromDomChildren` if there is no `<softBreak>` in current model.\n\t\t// If the described scenario happened, it means that this is a bogus `<br />` added by a browser.\n\t\tconst lastDomChild = modelFromDomChildren[ modelFromDomChildren.length - 1 ];\n\t\tconst lastCurrentChild = currentModelChildren[ currentModelChildren.length - 1 ];\n\n\t\tif ( lastDomChild && lastDomChild.is( 'softBreak' ) && lastCurrentChild && !lastCurrentChild.is( 'softBreak' ) ) {\n\t\t\tmodelFromDomChildren.pop();\n\t\t}\n\n\t\t// Skip situations when common ancestor has any container elements.\n\t\tif ( !isSafeForTextMutation( modelFromDomChildren ) || !isSafeForTextMutation( currentModelChildren ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replace &nbsp; inserted by the browser with normal space. See comment in `_handleTextMutation`.\n\t\t// Replace non-texts with any character. This is potentially dangerous but passes in manual tests. The thing is\n\t\t// that we need to take care of proper indexes so we cannot simply remove non-text elements from the content.\n\t\t// By inserting a character we keep all the real texts on their indexes.\n\t\tconst newText = modelFromDomChildren.map( item => item.is( 'text' ) ? item.data : '@' ).join( '' ).replace( /\\u00A0/g, ' ' );\n\t\tconst oldText = currentModelChildren.map( item => item.is( 'text' ) ? item.data : '@' ).join( '' );\n\n\t\t// Do nothing if mutations created same text.\n\t\tif ( oldText === newText ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst diffResult = diff( oldText, newText );\n\n\t\tconst { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );\n\n\t\t// Try setting new model selection according to passed view selection.\n\t\tlet modelSelectionRange = null;\n\n\t\tif ( viewSelection ) {\n\t\t\tmodelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );\n\t\t}\n\n\t\tconst insertText = newText.substr( firstChangeAt, insertions );\n\t\tconst removeRange = ModelRange.createFromParentsAndOffsets(\n\t\t\tcurrentModel,\n\t\t\tfirstChangeAt,\n\t\t\tcurrentModel,\n\t\t\tfirstChangeAt + deletions\n\t\t);\n\n\t\tthis.editor.execute( 'input', {\n\t\t\ttext: insertText,\n\t\t\trange: removeRange,\n\t\t\tresultRange: modelSelectionRange\n\t\t} );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTextMutation( mutation, viewSelection ) {\n\t\tif ( mutation.type != 'text' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replace &nbsp; inserted by the browser with normal space.\n\t\t// We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible\n\t\t// for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.\n\t\t// Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).\n\t\t// However then it will be handled outside of mutations, like enter key is.\n\t\t// The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they\n\t\t// take `newText` and compare it to (cleaned up) view.\n\t\t// It could also be done in mutation observer too, however if any outside plugin would like to\n\t\t// introduce additional events for mutations, they would get already cleaned up version (this may be good or not).\n\t\tconst newText = mutation.newText.replace( /\\u00A0/g, ' ' );\n\t\t// To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.\n\t\tconst oldText = mutation.oldText.replace( /\\u00A0/g, ' ' );\n\n\t\tconst diffResult = diff( oldText, newText );\n\n\t\tconst { firstChangeAt, insertions, deletions } = calculateChanges( diffResult );\n\n\t\t// Try setting new model selection according to passed view selection.\n\t\tlet modelSelectionRange = null;\n\n\t\tif ( viewSelection ) {\n\t\t\tmodelSelectionRange = this.editing.mapper.toModelRange( viewSelection.getFirstRange() );\n\t\t}\n\n\t\t// Get the position in view and model where the changes will happen.\n\t\tconst viewPos = new ViewPosition( mutation.node, firstChangeAt );\n\t\tconst modelPos = this.editing.mapper.toModelPosition( viewPos );\n\t\tconst removeRange = ModelRange.createFromPositionAndShift( modelPos, deletions );\n\t\tconst insertText = newText.substr( firstChangeAt, insertions );\n\n\t\tthis.editor.execute( 'input', {\n\t\t\ttext: insertText,\n\t\t\trange: removeRange,\n\t\t\tresultRange: modelSelectionRange\n\t\t} );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTextNodeInsertion( mutation ) {\n\t\tif ( mutation.type != 'children' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst change = getSingleTextNodeChange( mutation );\n\t\tconst viewPos = new ViewPosition( mutation.node, change.index );\n\t\tconst modelPos = this.editing.mapper.toModelPosition( viewPos );\n\t\tconst insertedText = change.values[ 0 ].data;\n\n\t\tthis.editor.execute( 'input', {\n\t\t\t// Replace &nbsp; inserted by the browser with normal space.\n\t\t\t// See comment in `_handleTextMutation`.\n\t\t\t// In this case we don't need to do this before `diff` because we diff whole nodes.\n\t\t\t// Just change &nbsp; in case there are some.\n\t\t\ttext: insertedText.replace( /\\u00A0/g, ' ' ),\n\t\t\trange: new ModelRange( modelPos )\n\t\t} );\n\t}\n}\n\n// Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}\n// or {@link module:engine/view/rootelement~RootElement}.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}\nfunction getMutationsContainer( mutations ) {\n\tconst lca = mutations\n\t\t.map( mutation => mutation.node )\n\t\t.reduce( ( commonAncestor, node ) => {\n\t\t\treturn commonAncestor.getCommonAncestor( node, { includeSelf: true } );\n\t\t} );\n\n\tif ( !lca ) {\n\t\treturn;\n\t}\n\n\t// We need to look for container and root elements only, so check all LCA's\n\t// ancestors (starting from itself).\n\treturn lca.getAncestors( { includeSelf: true, parentFirst: true } )\n\t\t.find( element => element.is( 'containerElement' ) || element.is( 'rootElement' ) );\n}\n\n// Returns true if provided array contains content that won't be problematic during diffing and text mutation handling.\n//\n// @param {Array.<module:engine/model/node~Node>} children\n// @returns {Boolean}\nfunction isSafeForTextMutation( children ) {\n\treturn children.every( child => child.is( 'text' ) || child.is( 'softBreak' ) );\n}\n\n// Calculates first change index and number of characters that should be inserted and deleted starting from that index.\n//\n// @private\n// @param diffResult\n// @returns {{insertions: number, deletions: number, firstChangeAt: *}}\nfunction calculateChanges( diffResult ) {\n\t// Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.\n\tlet firstChangeAt = null;\n\t// Index where the last change happens. Used to properly count how many characters have to be removed and inserted.\n\tlet lastChangeAt = null;\n\n\t// Get `firstChangeAt` and `lastChangeAt`.\n\tfor ( let i = 0; i < diffResult.length; i++ ) {\n\t\tconst change = diffResult[ i ];\n\n\t\tif ( change != 'equal' ) {\n\t\t\tfirstChangeAt = firstChangeAt === null ? i : firstChangeAt;\n\t\t\tlastChangeAt = i;\n\t\t}\n\t}\n\n\t// How many characters, starting from `firstChangeAt`, should be removed.\n\tlet deletions = 0;\n\t// How many characters, starting from `firstChangeAt`, should be inserted.\n\tlet insertions = 0;\n\n\tfor ( let i = firstChangeAt; i <= lastChangeAt; i++ ) {\n\t\t// If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.\n\t\tif ( diffResult[ i ] != 'insert' ) {\n\t\t\tdeletions++;\n\t\t}\n\n\t\t// If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.\n\t\tif ( diffResult[ i ] != 'delete' ) {\n\t\t\tinsertions++;\n\t\t}\n\t}\n\n\treturn { insertions, deletions, firstChangeAt };\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/input\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport InputCommand from './inputcommand';\n\nimport injectUnsafeKeystrokesHandling from './utils/injectunsafekeystrokeshandling';\nimport injectTypingMutationsHandling from './utils/injecttypingmutationshandling';\n\n/**\n * Handles text input coming from the keyboard or other input methods.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Input extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Input';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// TODO The above default configuration value should be defined using editor.config.define() once it's fixed.\n\t\tconst inputCommand = new InputCommand( editor, editor.config.get( 'typing.undoStep' ) || 20 );\n\n\t\teditor.commands.add( 'input', inputCommand );\n\n\t\tinjectUnsafeKeystrokesHandling( editor );\n\t\tinjectTypingMutationsHandling( editor );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/deletecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport Selection from '@ckeditor/ckeditor5-engine/src/model/selection';\nimport Element from '@ckeditor/ckeditor5-engine/src/model/element';\nimport Range from '@ckeditor/ckeditor5-engine/src/model/range';\nimport ChangeBuffer from './utils/changebuffer';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\n\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\nexport default class DeleteCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n\t * should consume the content when the selection is collapsed.\n\t */\n\tconstructor( editor, direction ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The directionality of the delete describing in what direction it should\n\t\t * consume the content when the selection is collapsed.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'forward'|'backward'} #direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Delete's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {typing.ChangeBuffer} #buffer\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, editor.config.get( 'typing.undoStep' ) );\n\t}\n\n\t/**\n\t * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n\t * or a piece of content in the {@link #direction defined direction}.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n\t * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n\t * See the {@link module:engine/view/document~Document#event:delete} event data.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tthis._buffer.lock();\n\n\t\t\tconst selection = new Selection( doc.selection );\n\n\t\t\t// Do not replace the whole selected content if selection was collapsed.\n\t\t\t// This prevents such situation:\n\t\t\t//\n\t\t\t// <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n\t\t\t// starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\t\t\tconst doNotResetEntireContent = selection.isCollapsed;\n\n\t\t\t// Try to extend the selection in the specified direction.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tmodel.modifySelection( selection, { direction: this.direction, unit: options.unit } );\n\t\t\t}\n\n\t\t\t// Check if deleting in an empty editor. See #61.\n\t\t\tif ( this._shouldEntireContentBeReplacedWithParagraph( options.sequence || 1 ) ) {\n\t\t\t\tthis._replaceEntireContentWithParagraph( writer );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If selection is still collapsed, then there's nothing to delete.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet changeCount = 0;\n\n\t\t\tselection.getFirstRange().getMinimalFlatRanges().forEach( range => {\n\t\t\t\tchangeCount += count(\n\t\t\t\t\trange.getWalker( { singleCharacters: true, ignoreElementEnd: true, shallow: true } )\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tmodel.deleteContent( selection, { doNotResetEntireContent } );\n\t\t\tthis._buffer.input( changeCount );\n\n\t\t\twriter.setSelection( selection );\n\n\t\t\tthis._buffer.unlock();\n\t\t} );\n\t}\n\n\t/**\n\t * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n\t * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n\t * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n\t *\n\t * But, if the user pressed the key in an empty editable for the first time,\n\t * we want to replace the entire content with a paragraph if:\n\t *\n\t * * the current limit element is empty,\n\t * * the paragraph is allowed in the limit element,\n\t * * the limit doesn't already have a paragraph inside.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n\t *\n\t * @private\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldEntireContentBeReplacedWithParagraph( sequence ) {\n\t\t// Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n\t\tif ( sequence > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\n\t\t// If a collapsed selection contains the whole content it means that the content is empty\n\t\t// (from the user perspective).\n\t\tconst limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent( limitElement );\n\n\t\tif ( !limitElementIsEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\t// We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n\t\t// because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\t\tif ( limitElementFirstChild && limitElementFirstChild.name === 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n\t *\n\t * @private\n\t */\n\t_replaceEntireContentWithParagraph( writer ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\t\tconst paragraph = new Element( 'paragraph' );\n\n\t\twriter.remove( Range.createIn( limitElement ) );\n\t\twriter.insert( paragraph, limitElement );\n\n\t\twriter.setSelection( paragraph, 0 );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/deleteobserver\n */\n\nimport Observer from '@ckeditor/ckeditor5-engine/src/view/observer/observer';\nimport DomEventData from '@ckeditor/ckeditor5-engine/src/view/observer/domeventdata';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\n/**\n * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class DeleteObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tconst document = view.document;\n\t\tlet sequence = 0;\n\n\t\tdocument.on( 'keyup', ( evt, data ) => {\n\t\t\tif ( data.keyCode == keyCodes.delete || data.keyCode == keyCodes.backspace ) {\n\t\t\t\tsequence = 0;\n\t\t\t}\n\t\t} );\n\n\t\tdocument.on( 'keydown', ( evt, data ) => {\n\t\t\tconst deleteData = {};\n\n\t\t\tif ( data.keyCode == keyCodes.delete ) {\n\t\t\t\tdeleteData.direction = 'forward';\n\t\t\t\tdeleteData.unit = 'character';\n\t\t\t} else if ( data.keyCode == keyCodes.backspace ) {\n\t\t\t\tdeleteData.direction = 'backward';\n\t\t\t\tdeleteData.unit = 'codePoint';\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst hasWordModifier = env.isMac ? data.altKey : data.ctrlKey;\n\t\t\tdeleteData.unit = hasWordModifier ? 'word' : deleteData.unit;\n\t\t\tdeleteData.sequence = ++sequence;\n\n\t\t\t// Save the event object to check later if it was stopped or not.\n\t\t\tlet event;\n\t\t\tdocument.once( 'delete', evt => ( event = evt ), { priority: 'highest' } );\n\n\t\t\tdocument.fire( 'delete', new DomEventData( document, data.domEvent, deleteData ) );\n\n\t\t\t// Stop `keydown` event if `delete` event was stopped.\n\t\t\t// https://github.com/ckeditor/ckeditor5/issues/753\n\t\t\tif ( event && event.stop.called ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve() {}\n}\n\n/**\n * Event fired when the user tries to delete content (e.g. presses <kbd>Delete</kbd> or <kbd>Backspace</kbd>).\n *\n * Note: This event is fired by the {@link module:typing/deleteobserver~DeleteObserver observer}\n * (usually registered by the {@link module:typing/delete~Delete delete feature}).\n *\n * @event module:engine/view/document~Document#event:delete\n * @param {module:engine/view/observer/domeventdata~DomEventData} data\n * @param {'forward'|'delete'} data.direction The direction in which the deletion should happen.\n * @param {'character'|'word'} data.unit The \"amount\" of content that should be deleted.\n * @param {Number} data.sequence A number describing which subsequent delete event it is without the key being released.\n * If it's 2 or more it means that the key was pressed and hold.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/utils/injectandroidbackspacenutationshandling\n */\n\nimport Selection from '@ckeditor/ckeditor5-engine/src/model/selection';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\n\nimport { containerChildrenMutated } from './utils';\n\n/**\n * Handles mutations triggered by <kbd>Backspace</kbd> on Android.\n * Due to the fact that on Android `keydown` events don't have the `keyCode` set, we are not able\n * to handle backspacing directly. We need to guess that from mutations which the IME\n * on Android caused.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport default function injectAndroidBackspaceMutationsHandling( editor ) {\n\tconst model = editor.model;\n\tconst view = editor.editing.view;\n\tconst selectionChangeToleranceMs = 200;\n\n\tlet previousSelection = null;\n\tlet currentSelection = new Selection( model.document.selection );\n\tlet latestSelectionChangeMs = Date.now();\n\n\tmodel.document.selection.on( 'change', handleSelectionChange );\n\n\tview.document.on( 'mutations', handleMutations, { priority: 'highest' } );\n\n\t// Saves current and previous selection when it changes. Saved selections are used\n\t// to remove correct piece of content when `Backspace` mutations are detected.\n\t//\n\t// @param {Object} evt\n\tfunction handleSelectionChange( evt ) {\n\t\tconst newSelection = new Selection( evt.source );\n\t\tif ( !currentSelection.isEqual( newSelection ) ) {\n\t\t\tpreviousSelection = currentSelection;\n\t\t\tcurrentSelection = newSelection;\n\t\t\tlatestSelectionChangeMs = Date.now();\n\t\t}\n\t}\n\n\t// Handles DOM mutations and checks if they should be processed as block elements removal mutations.\n\t//\n\t// @param {Object} evt\n\t// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n\t// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n\tfunction handleMutations( evt, mutations ) {\n\t\tif ( containerChildrenMutated( mutations ) && containsContainersRemoval( mutations ) ) {\n\t\t\thandleContainerRemovalMutations();\n\n\t\t\t// Stop mutations event propagation so other mutation handlers are not triggered.\n\t\t\tevt.stop();\n\t\t}\n\t}\n\n\t// Handles situations when mutations were generated by container removal.\n\t// It happens on Android devices where every typing input has `229` key code\n\t// and delete observer will not be triggered. In such cases we need to handle\n\t// container removal mutations manually.\n\tfunction handleContainerRemovalMutations() {\n\t\tif ( shouldUsePreviousSelection() ) {\n\t\t\t// If previous selection is used, update model selection in order\n\t\t\t// to use `delete` command and to make `undo` work correctly.\n\t\t\tmodel.enqueueChange( writer => {\n\t\t\t\twriter.setSelection( previousSelection );\n\t\t\t} );\n\t\t}\n\n\t\teditor.execute( 'delete' );\n\t}\n\n\t// Whether previously saved selection should be used instead of the current one to remove content.\n\t//\n\t// On Android devices when pressing backspace on non-collapsed selection, selection like:\n\t//\n\t//\t\t`<h1>[Foo</h1><p>Bar]</p>`\n\t//\n\t// is changed to:\n\t//\n\t//\t\t`<h1>Foo</h1><p>Bar[]</p>`\n\t//\n\t// even before `keypress` event, so in such cases we have to rely on previous selection to correctly process selected content.\n\t//\n\t// Previous selection will be used if:\n\t//\n\t//\t\t* current selection is collapsed (see example above),\n\t//\t\t* previous selection exists, is non-collapsed and has same ending (last position) as the current one,\n\t//\t\t* change of the selection happened not earlier than X milliseconds ago (see `selectionChangeToleranceMs`).\n\t//\n\t// The last check is needed, because user can manually collapse the selection on its current end and then press `Backspace`.\n\t// In such situations timing determines if the selection change was caused by the user or browser native behaviour.\n\t// However, this happens only if selection was collapsed by the user on the beginning of the paragraph (so mutations\n\t// still will show container removal).\n\t//\n\t// @returns {Boolean}\n\tfunction shouldUsePreviousSelection() {\n\t\treturn Date.now() - latestSelectionChangeMs < selectionChangeToleranceMs &&\n\t\t\tpreviousSelection && !previousSelection.isCollapsed && currentSelection.isCollapsed &&\n\t\t\tcurrentSelection.getLastPosition().isEqual( previousSelection.getLastPosition() );\n\t}\n}\n\n// Checks whether mutations array contains mutation generated by container/containers removal.\n// For example mutations generated on Android when pressing `backspace` on the beginning of the line:\n//\n//\t\t<h1>Header1</h1>\n//\t\t<p>{}Paragraph</p>\n//\n// are:\n//\n//\t\t[\n//\t\t\t{ newChildren: [], oldChildren: [ 'Paragraph' ], node: P, type: 'children' },\n//\t\t\t{ newChildren: [ ContainerElement ], oldChildren: [ ContainerElement, ContainerElement ], node: Root, type: 'children' },\n//\t\t\t{ newChildren: [ 'Heading 1Paragraph' ], oldChildren: [ 'Heading 1' ], node: H1, type: 'children' }\n//\t\t]\n//\n// The 1st and 3rd mutations are just changes in a text (1st - text in `p` element was removed, 3rd - text in `h2` was changed)\n// and the 2nd one shows that one `ContainerElement` was removed. We have to recognize if mutations like 2nd one are present.\n// Based on that heuristic mutations are treated as the one removing container element.\n//\n// @private\n// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|\n// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations\n// @returns {Boolean}\nfunction containsContainersRemoval( mutations ) {\n\tfor ( const mutation of mutations ) {\n\t\tif ( mutation.type !== 'children' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst childrenBefore = mutation.oldChildren;\n\t\tconst childrenAfter = mutation.newChildren;\n\n\t\t// Check if only containers were present before the mutation.\n\t\tif ( !hasOnlyContainers( childrenBefore ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst diffResult = diff( childrenBefore, childrenAfter );\n\n\t\t// Check if there was only removing in that mutation without any insertions.\n\t\tconst hasDelete = diffResult.some( item => item === 'delete' );\n\t\tconst hasInsert = diffResult.some( item => item === 'insert' );\n\n\t\tif ( hasDelete && !hasInsert ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// Whether provided array contains only nodes of `containerElement` type.\n//\n// @private\n// @param {Array.<module:engine/view/node~Node>} children\n// @returns {Boolean}\nfunction hasOnlyContainers( children ) {\n\treturn children.every( child => child.is( 'containerElement' ) );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/delete\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport DeleteCommand from './deletecommand';\nimport DeleteObserver from './deleteobserver';\n\nimport injectAndroidBackspaceMutationsHandling from './utils/injectandroidbackspacemutationshandling';\n\n/**\n * The delete and backspace feature. Handles the <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Delete extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Delete';\n\t}\n\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\tview.addObserver( DeleteObserver );\n\n\t\teditor.commands.add( 'forwardDelete', new DeleteCommand( editor, 'forward' ) );\n\t\teditor.commands.add( 'delete', new DeleteCommand( editor, 'backward' ) );\n\n\t\tthis.listenTo( viewDocument, 'delete', ( evt, data ) => {\n\t\t\teditor.execute( data.direction == 'forward' ? 'forwardDelete' : 'delete', { unit: data.unit, sequence: data.sequence } );\n\t\t\tdata.preventDefault();\n\t\t\tview.scrollToTheSelection();\n\t\t} );\n\n\t\tinjectAndroidBackspaceMutationsHandling( editor );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/first\n */\n\n/**\n * Returns first item of the given `iterable`.\n *\n * @param {Iterable.<*>} iterable\n * @returns {*}\n */\nexport default function first( iterable ) {\n\tconst iteratorItem = iterable.next();\n\n\tif ( iteratorItem.done ) {\n\t\treturn null;\n\t}\n\n\treturn iteratorItem.value;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module paragraph/paragraphcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n\n/**\n * The paragraph command.\n *\n * @extends module:core/command~Command\n */\nexport default class ParagraphCommand extends Command {\n\t/**\n\t * The value of the command. Indicates whether the selection start is placed in a paragraph.\n\t *\n\t * @readonly\n\t * @observable\n\t * @member {Boolean} #value\n\t */\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\t\tconst block = first( document.selection.getSelectedBlocks() );\n\n\t\tthis.value = !!block && block.is( 'paragraph' );\n\t\tthis.isEnabled = !!block && checkCanBecomeParagraph( block, model.schema );\n\t}\n\n\t/**\n\t * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection\n\t * will be turned to paragraphs.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] Options for the executed command.\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} [options.selection]\n\t * The selection that the command should be applied to.\n\t * By default, if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\tmodel.change( writer => {\n\t\t\tconst blocks = ( options.selection || document.selection ).getSelectedBlocks();\n\n\t\t\tfor ( const block of blocks ) {\n\t\t\t\tif ( !block.is( 'paragraph' ) && checkCanBecomeParagraph( block, model.schema ) ) {\n\t\t\t\t\twriter.rename( block, 'paragraph' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n}\n\n// Checks whether the given block can be replaced by a paragraph.\n//\n// @private\n// @param {module:engine/model/element~Element} block A block to be tested.\n// @param {module:engine/model/schema~Schema} schema The schema of the document.\n// @returns {Boolean}\nfunction checkCanBecomeParagraph( block, schema ) {\n\treturn schema.checkChild( block.parent, 'paragraph' ) && !schema.isObject( block );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module paragraph/paragraph\n */\n\nimport ParagraphCommand from './paragraphcommand';\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport { SchemaContext } from '@ckeditor/ckeditor5-engine/src/model/schema';\nimport Position from '@ckeditor/ckeditor5-engine/src/model/position';\nimport Range from '@ckeditor/ckeditor5-engine/src/model/range';\n\n/**\n * The paragraph feature for the editor.\n * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Paragraph extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Paragraph';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst data = editor.data;\n\n\t\teditor.commands.add( 'paragraph', new ParagraphCommand( editor ) );\n\n\t\t// Schema.\n\t\tmodel.schema.register( 'paragraph', { inheritAllFrom: '$block' } );\n\n\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\n\t\t// Content autoparagraphing. --------------------------------------------------\n\n\t\t// Handles elements not converted by plugins and checks if would be converted if\n\t\t// we wraps them by a paragraph or changes them to a paragraph.\n\t\tdata.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n\t\t\t// When element is already consumed by higher priority converters then do nothing.\n\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When element is paragraph-like lets try to change it into a paragraph.\n\t\t\tif ( Paragraph.paragraphLikeElements.has( data.viewItem.name ) ) {\n\t\t\t\tif ( data.viewItem.isEmpty ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n\n\t\t\t\t// Find allowed parent for paragraph that we are going to insert.\n\t\t\t\t// If current parent does not allow to insert paragraph but one of the ancestors does\n\t\t\t\t// then split nodes to allowed parent.\n\t\t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n\n\t\t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n\t\t\t\tif ( !splitResult ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Insert paragraph in allowed position.\n\t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n\n\t\t\t\t// Convert children to paragraph.\n\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, Position.createAt( paragraph ) );\n\n\t\t\t\t// Output range starts before paragraph but ends inside it after last child.\n\t\t\t\t// This is because we want to keep siblings inside the same paragraph as long as it is possible.\n\t\t\t\t// When next node won't be allowed in a paragraph it will split this paragraph anyway.\n\t\t\t\tdata.modelRange = new Range( Position.createBefore( paragraph ), modelRange.end );\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\n\t\t\t// When element is not paragraph-like lets try to wrap it by a paragraph.\n\t\t\t} else if ( isParagraphable( data.viewItem, data.modelCursor, conversionApi.schema ) ) {\n\t\t\t\tdata = Object.assign( data, wrapInParagraph( data.viewItem, data.modelCursor, conversionApi ) );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Handles not converted text nodes and checks if would be converted if we wraps then by a paragraph.\n\t\tdata.upcastDispatcher.on( 'text', ( evt, data, conversionApi ) => {\n\t\t\t// When node is already converted then do nothing.\n\t\t\tif ( data.modelRange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isParagraphable( data.viewItem, data.modelCursor, conversionApi.schema ) ) {\n\t\t\t\tdata = Object.assign( data, wrapInParagraph( data.viewItem, data.modelCursor, conversionApi ) );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Empty roots autoparagraphing. -----------------------------------------------\n\n\t\t// Post-fixer which takes care of adding empty paragraph elements to empty roots.\n\t\t// Besides fixing content on #changesDone we also need to handle #dataReady because\n\t\t// if initial data is empty or setData() wasn't even called there will be no #change fired.\n\t\tmodel.document.registerPostFixer( writer => this._autoparagraphEmptyRoots( writer ) );\n\n\t\teditor.on( 'dataReady', () => {\n\t\t\tmodel.enqueueChange( 'transparent', writer => this._autoparagraphEmptyRoots( writer ) );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Fixes all empty roots.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n\t */\n\t_autoparagraphEmptyRoots( writer ) {\n\t\tconst model = this.editor.model;\n\n\t\tfor ( const rootName of model.document.getRootNames() ) {\n\t\t\tconst root = model.document.getRoot( rootName );\n\n\t\t\tif ( root.isEmpty && root.rootName != '$graveyard' ) {\n\t\t\t\t// If paragraph element is allowed in the root, create paragraph element.\n\t\t\t\tif ( model.schema.checkChild( root, 'paragraph' ) ) {\n\t\t\t\t\twriter.insertElement( 'paragraph', root );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A list of element names which should be treated by the autoparagraphing algorithms as\n * paragraph-like. This means that e.g. the following content:\n *\n *\t\t<h1>Foo</h1>\n *\t\t<table>\n *\t\t\t<tr>\n *\t\t\t\t<td>X</td>\n *\t\t\t\t<td>\n *\t\t\t\t\t<ul>\n *\t\t\t\t\t\t<li>Y</li>\n *\t\t\t\t\t\t<li>Z</li>\n *\t\t\t\t\t</ul>\n *\t\t\t\t</td>\n *\t\t\t</tr>\n *\t\t</table>\n *\n * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.\n * Hence, if none of the features is going to convert those elements the above content will be automatically handled\n * by the paragraph feature and converted to:\n *\n *\t\t<p>Foo</p>\n *\t\t<p>X</p>\n *\t\t<p>Y</p>\n *\t\t<p>Z</p>\n *\n * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements\n * have a priority upon conversion.\n *\n * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements\n */\nParagraph.paragraphLikeElements = new Set( [\n\t'blockquote',\n\t'dd',\n\t'div',\n\t'dt',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'li',\n\t'p',\n\t'td'\n] );\n\nfunction wrapInParagraph( input, position, conversionApi ) {\n\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n\n\tconversionApi.writer.insert( paragraph, position );\n\treturn conversionApi.convertItem( input, Position.createAt( paragraph ) );\n}\n\nfunction isParagraphable( node, position, schema ) {\n\tconst context = new SchemaContext( position );\n\n\t// When paragraph is allowed in this context...\n\tif ( !schema.checkChild( context, 'paragraph' ) ) {\n\t\treturn false;\n\t}\n\n\t// And a node would be allowed in this paragraph...\n\tif ( !schema.checkChild( context.push( 'paragraph' ), node ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module undo/basecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\nexport default class BaseCommand extends Command {\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Stack of items stored by the command. These are pairs of:\n\t\t *\n\t\t * * {@link module:engine/model/batch~Batch batch} saved by the command,\n\t\t * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array} #_stack\n\t\t */\n\t\tthis._stack = [];\n\n\t\t/**\n\t\t * Stores all batches that were created by this command.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n\t\t */\n\t\tthis._createdBatches = new WeakSet();\n\n\t\t// Refresh state, so the command is inactive right after initialization.\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tthis.isEnabled = this._stack.length > 0;\n\t}\n\n\t/**\n\t * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n\t * created by the editor which this command is registered to.\n\t *\n\t * @param {module:engine/model/batch~Batch} batch The batch to add.\n\t */\n\taddBatch( batch ) {\n\t\tconst docSelection = this.editor.model.document.selection;\n\n\t\tconst selection = {\n\t\t\tranges: docSelection.hasOwnRange ? Array.from( docSelection.getRanges() ) : [],\n\t\t\tisBackward: docSelection.isBackward\n\t\t};\n\n\t\tthis._stack.push( { batch, selection } );\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Removes all items from the stack.\n\t */\n\tclearStack() {\n\t\tthis._stack = [];\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n\t *\n\t * @protected\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n\t * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n\t * @param {Array.<module:engine/model/delta/delta~Delta>} deltas Deltas which has been applied since selection has been stored.\n\t */\n\t_restoreSelection( ranges, isBackward, deltas ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// This will keep the transformed selection ranges.\n\t\tconst selectionRanges = [];\n\n\t\t// Transform all ranges from the restored selection.\n\t\tfor ( const range of ranges ) {\n\t\t\tconst transformedRanges = transformSelectionRange( range, deltas );\n\n\t\t\t// For each `range` from `ranges`, we take only one transformed range.\n\t\t\t// This is because we want to prevent situation where single-range selection\n\t\t\t// got transformed to multi-range selection. We will take the first range that\n\t\t\t// is not in the graveyard.\n\t\t\tconst transformedRange = transformedRanges.find(\n\t\t\t\trange => range.start.root != document.graveyard\n\t\t\t);\n\n\t\t\t// `transformedRange` might be `undefined` if transformed range ended up in graveyard.\n\t\t\tif ( transformedRange ) {\n\t\t\t\tselectionRanges.push( transformedRange );\n\t\t\t}\n\t\t}\n\n\t\t// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\t\tif ( selectionRanges.length ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( selectionRanges, { backward: isBackward } );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n\t * This is a helper method for {@link #execute}.\n\t *\n\t * @protected\n\t * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n\t * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n\t */\n\t_undo( batchToUndo, undoingBatch ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// All changes done by the command execution will be saved as one batch.\n\t\tthis._createdBatches.add( undoingBatch );\n\n\t\tconst deltasToUndo = batchToUndo.deltas.slice();\n\t\tdeltasToUndo.reverse();\n\n\t\t// We will process each delta from `batchToUndo`, in reverse order. If there were deltas A, B and C in undone batch,\n\t\t// we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\t\tfor ( const deltaToUndo of deltasToUndo ) {\n\t\t\t// For now let's skip deltas with operation applied on detached document.\n\t\t\t// We assumed that there is no deltas with mixed (document and document fragment) operations\n\t\t\t// so we can skip entire delta.\n\t\t\tif ( deltaToUndo.operations.some( op => op.isDocumentOperation ) ) {\n\t\t\t\t// Keep in mind that transformation algorithms return arrays. That's because the transformation might result in multiple\n\t\t\t\t// deltas, so we need arrays to handle them. To simplify algorithms, it is better to always operate on arrays.\n\t\t\t\tconst nextBaseVersion = deltaToUndo.baseVersion + deltaToUndo.operations.length;\n\n\t\t\t\t// Reverse delta from the history.\n\t\t\t\tconst historyDeltas = Array.from( document.history.getDeltas( nextBaseVersion ) );\n\t\t\t\tconst transformedSets = model.transformDeltas( [ deltaToUndo.getReversed() ], historyDeltas, true );\n\t\t\t\tconst reversedDeltas = transformedSets.deltasA;\n\n\t\t\t\t// After reversed delta has been transformed by all history deltas, apply it.\n\t\t\t\tfor ( const delta of reversedDeltas ) {\n\t\t\t\t\t// Fix base version.\n\t\t\t\t\tdelta.baseVersion = document.version;\n\n\t\t\t\t\t// Before applying, add the delta to the `undoingBatch`.\n\t\t\t\t\tundoingBatch.addDelta( delta );\n\n\t\t\t\t\t// Now, apply all operations of the delta.\n\t\t\t\t\tfor ( const operation of delta.operations ) {\n\t\t\t\t\t\tmodel.applyOperation( operation );\n\t\t\t\t\t}\n\n\t\t\t\t\tdocument.history.setDeltaAsUndone( deltaToUndo, delta );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Transforms given range `range` by given `deltas`.\n// Returns an array containing one or more ranges, which are result of the transformation.\nfunction transformSelectionRange( range, deltas ) {\n\tconst transformed = transformRangesByDeltas( [ range ], deltas );\n\n\t// After `range` got transformed, we have an array of ranges. Some of those\n\t// ranges may be \"touching\" -- they can be next to each other and could be merged.\n\t// First, we have to sort those ranges to assure that they are in order.\n\ttransformed.sort( ( a, b ) => a.start.isBefore( b.start ) ? -1 : 1 );\n\n\t// Then, we check if two consecutive ranges are touching.\n\tfor ( let i = 1; i < transformed.length; i++ ) {\n\t\tconst a = transformed[ i - 1 ];\n\t\tconst b = transformed[ i ];\n\n\t\tif ( a.end.isTouching( b.start ) ) {\n\t\t\t// And join them together if they are.\n\t\t\ta.end = b.end;\n\t\t\ttransformed.splice( i, 1 );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn transformed;\n}\n\n// Transforms given set of `ranges` by given set of `deltas`. Returns transformed `ranges`.\nexport function transformRangesByDeltas( ranges, deltas ) {\n\tfor ( const delta of deltas ) {\n\t\tfor ( const operation of delta.operations ) {\n\t\t\t// We look through all operations from all deltas.\n\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\t// We transform every range by every operation.\n\t\t\t\tlet result;\n\n\t\t\t\tswitch ( operation.type ) {\n\t\t\t\t\tcase 'insert':\n\t\t\t\t\t\tresult = ranges[ i ]._getTransformedByInsertion(\n\t\t\t\t\t\t\toperation.position,\n\t\t\t\t\t\t\toperation.nodes.maxOffset,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'move':\n\t\t\t\t\tcase 'remove':\n\t\t\t\t\tcase 'reinsert':\n\t\t\t\t\t\tresult = ranges[ i ]._getTransformedByMove(\n\t\t\t\t\t\t\toperation.sourcePosition,\n\t\t\t\t\t\t\toperation.targetPosition,\n\t\t\t\t\t\t\toperation.howMany,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// If we have a transformation result, we substitute transformed range with it in `transformed` array.\n\t\t\t\t// Keep in mind that the result is an array and may contain multiple ranges.\n\t\t\t\tif ( result ) {\n\t\t\t\t\tranges.splice( i, 1, ...result );\n\n\t\t\t\t\t// Fix iterator.\n\t\t\t\t\ti = i + result.length - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ranges;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module undo/undocommand\n */\n\nimport BaseCommand from './basecommand';\nimport Batch from '@ckeditor/ckeditor5-engine/src/model/batch';\n\n/**\n * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the\n * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by\n * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.\n *\n * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.\n *\n * @extends module:undo/basecommand~BaseCommand\n */\nexport default class UndoCommand extends BaseCommand {\n\t/**\n\t * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms\n\t * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.\n\t * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.\n\t *\n\t * @fires execute\n\t * @fires revert\n\t * @param {module:engine/model/batch~Batch} [batch] A batch that should be undone. If not set, the last added batch will be undone.\n\t */\n\texecute( batch = null ) {\n\t\t// If batch is not given, set `batchIndex` to the last index in command stack.\n\t\tconst batchIndex = batch ? this._stack.findIndex( a => a.batch == batch ) : this._stack.length - 1;\n\n\t\tconst item = this._stack.splice( batchIndex, 1 )[ 0 ];\n\t\tconst undoingBatch = new Batch();\n\n\t\t// All changes has to be done in one `enqueueChange` callback so other listeners will not\n\t\t// step between consecutive deltas, or won't do changes to the document before selection is properly restored.\n\t\tthis.editor.model.enqueueChange( undoingBatch, () => {\n\t\t\tthis._undo( item.batch, undoingBatch );\n\n\t\t\tconst deltas = this.editor.model.document.history.getDeltas( item.batch.baseVersion );\n\t\t\tthis._restoreSelection( item.selection.ranges, item.selection.isBackward, deltas );\n\n\t\t\tthis.fire( 'revert', item.batch, undoingBatch );\n\t\t} );\n\n\t\tthis.refresh();\n\t}\n}\n\n/**\n * Fired when execution of the command reverts some batch.\n *\n * @event revert\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module undo/redocommand\n */\n\nimport BaseCommand from './basecommand';\nimport Batch from '@ckeditor/ckeditor5-engine/src/model/batch';\n\n/**\n * The redo command stores {@link module:engine/model/batch~Batch batches} that were used to undo a batch by\n * {@link module:undo/undocommand~UndoCommand}. It is able to redo a previously undone batch by reversing the undoing\n * batches created by `UndoCommand`. The reversed batch is transformed by all the batches from\n * {@link module:engine/model/document~Document#history history} that happened after the reversed undo batch.\n *\n * The redo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.\n *\n * @extends module:undo/basecommand~BaseCommand\n */\nexport default class RedoCommand extends BaseCommand {\n\t/**\n\t * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to\n\t * the command's stack, applies the reverted and transformed version on the\n\t * {@link module:engine/model/document~Document document} and removes the batch from the stack.\n\t * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.\n\t *\n\t * @fires execute\n\t */\n\texecute() {\n\t\tconst item = this._stack.pop();\n\t\tconst redoingBatch = new Batch();\n\n\t\t// All changes have to be done in one `enqueueChange` callback so other listeners will not\n\t\t// step between consecutive deltas, or won't do changes to the document before selection is properly restored.\n\t\tthis.editor.model.enqueueChange( redoingBatch, () => {\n\t\t\tconst lastDelta = item.batch.deltas[ item.batch.deltas.length - 1 ];\n\t\t\tconst nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;\n\t\t\tconst deltas = this.editor.model.document.history.getDeltas( nextBaseVersion );\n\n\t\t\tthis._restoreSelection( item.selection.ranges, item.selection.isBackward, deltas );\n\t\t\tthis._undo( item.batch, redoingBatch );\n\t\t} );\n\n\t\tthis.refresh();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module basic-styles/attributecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\n/**\n * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command\n * that toggles a single attribute on a text or an element.\n *\n * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}\n * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.\n *\n * The command checks the {@link module:engine/model/model~Model#schema} to decide if it can be enabled\n * for the current selection and to which nodes the attribute can be applied.\n *\n * @extends module:core/command~Command\n */\nexport default class AttributeCommand extends Command {\n\t/**\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {String} attributeKey Attribute that will be set by the command.\n\t */\n\tconstructor( editor, attributeKey ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The attribute that will be set by the command.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.attributeKey = attributeKey;\n\n\t\t/**\n\t\t * Flag indicating whether the command is active. The command is active when the\n\t\t * {@link module:engine/model/selection~Selection#hasAttribute selection has the attribute} which means that:\n\t\t *\n\t\t * * If the selection is not empty &ndash; That the attribute is set on the first node in the selection that allows this attribute.\n\t\t * * If the selection is empty &ndash; That the selection has the attribute itself (which means that newly typed\n\t\t * text will have this attribute, too).\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member {Boolean} #value\n\t\t */\n\t}\n\n\t/**\n\t * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.\n\t */\n\trefresh() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tthis.value = this._getValueFromFirstAllowedNode();\n\t\tthis.isEnabled = model.schema.checkAttributeInSelection( doc.selection, this.attributeKey );\n\t}\n\n\t/**\n\t * Executes the command &mdash; applies the attribute to the selection or removes it from the selection.\n\t *\n\t * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.\n\t *\n\t * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:\n\t *\n\t * * If the selection is on a range, the command applies the attribute to all nodes in that range\n\t * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).\n\t * * If the selection is collapsed in a non-empty node, the command applies the attribute to the\n\t * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).\n\t * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note\n\t * that the selection inherits all attributes from a node if it is in an empty node).\n\t *\n\t * @fires execute\n\t * @param {Object} [options] Command options.\n\t * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply the attribute,\n\t * otherwise the command will remove the attribute.\n\t * If not set, the command will look for its current value to decide what it should do.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst value = ( options.forceValue === undefined ) ? !this.value : options.forceValue;\n\n\t\tmodel.change( writer => {\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tif ( value ) {\n\t\t\t\t\twriter.setSelectionAttribute( this.attributeKey, true );\n\t\t\t\t} else {\n\t\t\t\t\twriter.removeSelectionAttribute( this.attributeKey );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ranges = model.schema.getValidRanges( selection.getRanges(), this.attributeKey );\n\n\t\t\t\tfor ( const range of ranges ) {\n\t\t\t\t\tif ( value ) {\n\t\t\t\t\t\twriter.setAttribute( this.attributeKey, value, range );\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.removeAttribute( this.attributeKey, range );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Checks the attribute value of the first node in the selection that allows the attribute.\n\t * For the collapsed selection returns the selection attribute.\n\t *\n\t * @private\n\t * @returns {Boolean} The attribute value.\n\t */\n\t_getValueFromFirstAllowedNode() {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst selection = model.document.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn selection.hasAttribute( this.attributeKey );\n\t\t}\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tfor ( const item of range.getItems() ) {\n\t\t\t\tif ( schema.checkAttribute( item, this.attributeKey ) ) {\n\t\t\t\t\treturn item.hasAttribute( this.attributeKey );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module basic-styles/bold/boldediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport AttributeCommand from '../attributecommand';\n\nconst BOLD = 'bold';\n\n/**\n * The bold editing feature.\n *\n * It registers the `bold` command and introduces the `bold` attribute in the model which renders to the view\n * as a `<strong>` element.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class BoldEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\t// Allow bold attribute on text nodes.\n\t\teditor.model.schema.extend( '$text', { allowAttributes: BOLD } );\n\n\t\t// Build converter from model to view for data and editing pipelines.\n\n\t\teditor.conversion.attributeToElement( {\n\t\t\tmodel: BOLD,\n\t\t\tview: 'strong',\n\t\t\tupcastAlso: [\n\t\t\t\t'b',\n\t\t\t\t{\n\t\t\t\t\tstyles: {\n\t\t\t\t\t\t'font-weight': 'bold'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\n\t\t// Create bold command.\n\t\teditor.commands.add( BOLD, new AttributeCommand( editor, BOLD ) );\n\n\t\t// Set the Ctrl+B keystroke.\n\t\teditor.keystrokes.set( 'CTRL+B', BOLD );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module basic-styles/italic/italicediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport AttributeCommand from '../attributecommand';\n\nconst ITALIC = 'italic';\n\n/**\n * The italic editing feature.\n *\n * It registers the `italic` command, the <kbd>Ctrl+I</kbd> keystroke and introduces the `italic` attribute in the model\n * which renders to the view as an `<em>` element.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ItalicEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Allow italic attribute on text nodes.\n\t\teditor.model.schema.extend( '$text', { allowAttributes: ITALIC } );\n\n\t\teditor.conversion.attributeToElement( {\n\t\t\tmodel: ITALIC,\n\t\t\tview: 'i',\n\t\t\tupcastAlso: [\n\t\t\t\t'em',\n\t\t\t\t{\n\t\t\t\t\tstyles: {\n\t\t\t\t\t\t'font-style': 'italic'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\n\t\t// Create italic command.\n\t\teditor.commands.add( ITALIC, new AttributeCommand( editor, ITALIC ) );\n\n\t\t// Set the Ctrl+I keystroke.\n\t\teditor.keystrokes.set( 'CTRL+I', ITALIC );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module basic-styles/underline/underlineediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport AttributeCommand from '../attributecommand';\n\nconst UNDERLINE = 'underline';\n\n/**\n * The underline editing feature.\n *\n * It registers the `underline` command, the <kbd>Ctrl+U</kbd> keystroke\n * and introduces the `underline` attribute in the model which renders to the view as an `<u>` element.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class UnderlineEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Allow strikethrough attribute on text nodes.\n\t\teditor.model.schema.extend( '$text', { allowAttributes: UNDERLINE } );\n\n\t\teditor.conversion.attributeToElement( {\n\t\t\tmodel: UNDERLINE,\n\t\t\tview: 'u',\n\t\t\tupcastAlso: {\n\t\t\t\tstyles: {\n\t\t\t\t\t'text-decoration': 'underline'\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Create underline command.\n\t\teditor.commands.add( UNDERLINE, new AttributeCommand( editor, UNDERLINE ) );\n\n\t\t// Set the Ctrl+U keystroke.\n\t\teditor.keystrokes.set( 'CTRL+U', 'underline' );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module heading/headingcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n\n/**\n * The heading command. It is used by the {@link module:heading/heading~Heading heading feature} to apply headings.\n *\n * @extends module:core/command~Command\n */\nexport default class HeadingCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor Editor instance.\n\t * @param {Array.<String>} modelElements Names of the element which this command can apply in the model.\n\t */\n\tconstructor( editor, modelElements ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * If the selection starts in a heading (which {@link #modelElements is supported by this command})\n\t\t * the value is set to the name of that heading model element.\n\t\t * It is  set to `false` otherwise.\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member {Boolean|String} #value\n\t\t */\n\n\t\t/**\n\t\t * Set of defined model's elements names that this command support.\n\t\t * See {@link module:heading/heading~HeadingOption}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>}\n\t\t */\n\t\tthis.modelElements = modelElements;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst block = first( this.editor.model.document.selection.getSelectedBlocks() );\n\n\t\tthis.value = !!block && this.modelElements.includes( block.name ) && block.name;\n\t\tthis.isEnabled = !!block && this.modelElements.some( heading => checkCanBecomeHeading( block, heading, this.editor.model.schema ) );\n\t}\n\n\t/**\n\t * Executes the command. Applies the heading to the selected blocks or, if the first selected\n\t * block is a heading already, turns selected headings (of this level only) to paragraphs.\n\t *\n\t * @param {Object} options\n\t * @param {String} options.value Name of the element which this command will apply in the model.\n\t * @fires execute\n\t */\n\texecute( options ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\tconst modelElement = options.value;\n\n\t\tmodel.change( writer => {\n\t\t\tconst blocks = Array.from( document.selection.getSelectedBlocks() )\n\t\t\t\t.filter( block => {\n\t\t\t\t\treturn checkCanBecomeHeading( block, modelElement, model.schema );\n\t\t\t\t} );\n\n\t\t\tfor ( const block of blocks ) {\n\t\t\t\tif ( !block.is( modelElement ) ) {\n\t\t\t\t\twriter.rename( block, modelElement );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n}\n\n// Checks whether the given block can be replaced by a specific heading.\n//\n// @private\n// @param {module:engine/model/element~Element} block A block to be tested.\n// @param {module:heading/headingcommand~HeadingCommand#modelElement} heading Command element name in the model.\n// @param {module:engine/model/schema~Schema} schema The schema of the document.\n// @returns {Boolean}\nfunction checkCanBecomeHeading( block, heading, schema ) {\n\treturn schema.checkChild( block.parent, heading ) && !schema.isObject( block );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module heading/headingediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';\nimport HeadingCommand from './headingcommand';\n\nconst defaultModelElement = 'paragraph';\n\n/**\n * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.\n * This class represents the engine part of the heading feature. See also {@link module:heading/heading~Heading}.\n * It introduces `heading1`-`headingN` commands which allow to convert paragraphs into headings.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class HeadingEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\teditor.config.define( 'heading', {\n\t\t\toptions: [\n\t\t\t\t{ model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },\n\t\t\t\t{ model: 'heading1', view: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },\n\t\t\t\t{ model: 'heading2', view: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },\n\t\t\t\t{ model: 'heading3', view: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' }\n\t\t\t]\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ Paragraph ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst options = editor.config.get( 'heading.options' );\n\n\t\tconst modelElements = [];\n\n\t\tfor ( const option of options ) {\n\t\t\t// Skip paragraph - it is defined in required Paragraph feature.\n\t\t\tif ( option.model !== defaultModelElement ) {\n\t\t\t\t// Schema.\n\t\t\t\teditor.model.schema.register( option.model, {\n\t\t\t\t\tinheritAllFrom: '$block'\n\t\t\t\t} );\n\n\t\t\t\teditor.conversion.elementToElement( option );\n\n\t\t\t\tmodelElements.push( option.model );\n\t\t\t}\n\t\t}\n\n\t\t// Register the heading command for this option.\n\t\teditor.commands.add( 'heading', new HeadingCommand( editor, modelElements ) );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tafterInit() {\n\t\t// If the enter command is added to the editor, alter its behavior.\n\t\t// Enter at the end of a heading element should create a paragraph.\n\t\tconst editor = this.editor;\n\t\tconst enterCommand = editor.commands.get( 'enter' );\n\t\tconst options = editor.config.get( 'heading.options' );\n\n\t\tif ( enterCommand ) {\n\t\t\tthis.listenTo( enterCommand, 'afterExecute', ( evt, data ) => {\n\t\t\t\tconst positionParent = editor.model.document.selection.getFirstPosition().parent;\n\t\t\t\tconst isHeading = options.some( option => positionParent.is( option.model ) );\n\n\t\t\t\tif ( isHeading && !positionParent.is( defaultModelElement ) && positionParent.childCount === 0 ) {\n\t\t\t\t\tdata.writer.rename( positionParent, defaultModelElement );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module core/pendingactions\n */\n\nimport Plugin from './plugin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * The list of pending editor actions.\n *\n * This plugin should be used to synchronise plugins that execute long-lasting actions\n * (e.g. file upload) with the editor integration. It gives the developer who integrates the editor\n * an easy way to check if there are any actions pending whenever such information is needed.\n * All plugins that register a pending action also provide a message about the action that is ongoing\n * which can be displayed to the user. This lets them decide if they want to interrupt the action or wait.\n *\n * Adding and updating a pending action:\n *\n * \t\tconst pendingActions = editor.plugins.get( 'PendingActions' );\n * \t\tconst action = pendingActions.add( 'Upload in progress: 0%.' );\n *\n *\t\t// You can update the message:\n * \t\taction.message = 'Upload in progress: 10%.';\n *\n * Removing a pending action:\n *\n * \t\tconst pendingActions = editor.plugins.get( 'PendingActions' );\n * \t\tconst action = pendingActions.add( 'Unsaved changes.' );\n *\n * \t\tpendingActions.remove( action );\n *\n * Getting pending actions:\n *\n * \t\tconst pendingActions = editor.plugins.get( 'PendingActions' );\n *\n * \t\tconst action1 = pendingActions.add( 'Action 1' );\n * \t\tconst action2 = pendingActions.add( 'Action 2' );\n *\n * \t\tpendingActions.first; // Returns action1\n * \t\tArray.from( pendingActions ); // Returns [ action1, action2 ]\n *\n * This plugin is used by features like {@link module:upload/filerepository~FileRepository} to register their ongoing actions\n * and by features like {@link module:autosave/autosave~Autosave} to detect whether there are any ongoing actions.\n * Read more about saving the data in the {@glink builds/guides/integration/saving-data Saving and getting data} guide.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class PendingActions extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'PendingActions';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\t/**\n\t\t * Defines whether there is any registered pending action.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Boolean} #hasAny\n\t\t */\n\t\tthis.set( 'hasAny', false );\n\n\t\t/**\n\t\t * A list of pending actions.\n\t\t *\n\t\t * @private\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis._actions = new Collection( { idProperty: '_id' } );\n\t\tthis._actions.delegate( 'add', 'remove' ).to( this );\n\t}\n\n\t/**\n\t * Adds an action to the list of pending actions.\n\t *\n\t * This method returns an action object with an observable message property.\n\t * The action object can be later used in the {@link #remove} method. It also allows you to change the message.\n\t *\n\t * @param {String} message The action message.\n\t * @returns {Object} An observable object that represents a pending action.\n\t */\n\tadd( message ) {\n\t\tif ( typeof message !== 'string' ) {\n\t\t\t/**\n\t\t\t * The message must be a string.\n\t\t\t *\n\t\t\t * @error pendingactions-add-invalid-message\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'pendingactions-add-invalid-message: The message must be a string.' );\n\t\t}\n\n\t\tconst action = Object.create( ObservableMixin );\n\n\t\taction.set( 'message', message );\n\t\tthis._actions.add( action );\n\t\tthis.hasAny = true;\n\n\t\treturn action;\n\t}\n\n\t/**\n\t * Removes an action from the list of pending actions.\n\t *\n\t * @param {Object} action An action object.\n\t */\n\tremove( action ) {\n\t\tthis._actions.remove( action );\n\t\tthis.hasAny = !!this._actions.length;\n\t}\n\n\t/**\n\t * Returns the first action from the list.\n\t *\n\t * returns {Object} The pending action object.\n\t */\n\tget first() {\n\t\treturn this._actions.get( 0 );\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._actions[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Fired when an action is added to the list.\n\t *\n\t * @event add\n\t * @param {Object} action The added action.\n\t */\n\n\t/**\n\t * Fired when an action is removed from the list.\n\t *\n\t * @event remove\n\t * @param {Object} action The removed action.\n\t */\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module upload/filereader\n */\n\n/* globals window */\n\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * FileReader class - wrapper over native FileReader.\n */\nexport default class FileReader {\n\t/**\n\t * Creates an instance of the FileReader.\n\t */\n\tconstructor() {\n\t\tconst reader = new window.FileReader();\n\n\t\t/**\n\t\t * Instance of native FileReader.\n\t\t *\n\t\t * @private\n\t\t * @member {FileReader} #_reader\n\t\t */\n\t\tthis._reader = reader;\n\n\t\t/**\n\t\t * Number of bytes loaded.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number} #loaded\n\t\t */\n\t\tthis.set( 'loaded', 0 );\n\n\t\treader.onprogress = evt => {\n\t\t\tthis.loaded = evt.loaded;\n\t\t};\n\t}\n\n\t/**\n\t * Returns error that occurred during file reading.\n\t *\n\t * @returns {Error}\n\t */\n\tget error() {\n\t\treturn this._reader.error;\n\t}\n\n\t/**\n\t * Reads provided file.\n\t *\n\t * @param {File} file Native File object.\n\t * @returns {Promise} Returns a promise that will resolve with file's contents. Promise can be rejected in case of\n\t * error or when reading process is aborted.\n\t */\n\tread( file ) {\n\t\tconst reader = this._reader;\n\t\tthis.total = file.size;\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\t\t\treader.onload = () => {\n\t\t\t\tresolve( reader.result );\n\t\t\t};\n\n\t\t\treader.onerror = () => {\n\t\t\t\treject( 'error' );\n\t\t\t};\n\n\t\t\treader.onabort = () => {\n\t\t\t\treject( 'aborted' );\n\t\t\t};\n\n\t\t\tthis._reader.readAsDataURL( file );\n\t\t} );\n\t}\n\n\t/**\n\t * Aborts file reader.\n\t */\n\tabort() {\n\t\tthis._reader.abort();\n\t}\n}\n\nmix( FileReader, ObservableMixin );\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module upload/filerepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport PendingActions from '@ckeditor/ckeditor5-core/src/pendingactions';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport log from '@ckeditor/ckeditor5-utils/src/log';\nimport FileReader from './filereader.js';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid.js';\n/**\n * File repository plugin. A central point for managing file upload.\n *\n * To use it, first you need an upload adapter. Upload adapter's job is to handle communication with the server\n * (sending the file and handling server's response). You can use one of the existing plugins introducing upload adapters\n * (e.g. {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter} or\n * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}) or write your own one\n * (which boils down to setting the {@link ~FileRepository#createUploadAdapter} factory function – see\n * {@link module:upload/filerepository~UploadAdapter `UploadAdapter` interface} documentation).\n *\n * Then, you can use {@link module:upload/filerepository~FileRepository#createLoader `createLoader()`} and the returned\n * {@link module:upload/filerepository~FileLoader} instance to load and upload files.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class FileRepository extends Plugin {\n    /**\n\t * @inheritDoc\n\t */\n    static get pluginName() {\n        return 'FileRepository';\n    }\n    /**\n\t * @inheritDoc\n\t */\n    static get requires() {\n        return [PendingActions];\n    }\n    /**\n\t * @inheritDoc\n\t */\n    init() {\n        /**\n\t\t * Collection of loaders associated with this repository.\n\t\t *\n\t\t * @member {module:utils/collection~Collection} #loaders\n\t\t */\n        this.loaders = new Collection();\n        // Keeps upload in a sync with pending actions.\n        this.loaders.on('add', () => this._updatePendingAction());\n        this.loaders.on('remove', () => this._updatePendingAction());\n        /**\n\t\t * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin\n\t\t * while upload is in progress. When there is no upload then value is `null`.\n\t\t *\n\t\t * @private\n\t\t * @member {Object} #_pendingAction\n\t\t */\n        this._pendingAction = null;\n        /**\n\t\t * A factory function which should be defined before using `FileRepository`.\n\t\t *\n\t\t * It should return a new instance of {@link module:upload/filerepository~UploadAdapter} that will be used to upload files.\n\t\t * {@link module:upload/filerepository~FileLoader} instance associated with the adapter\n\t\t * will be passed to that function.\n\t\t *\n\t\t * For more information and example see {@link module:upload/filerepository~UploadAdapter}.\n\t\t *\n\t\t * @member {Function} #createUploadAdapter\n\t\t */\n        /**\n\t\t * Number of bytes uploaded.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number} #uploaded\n\t\t */\n        this.set('uploaded', 0);\n        /**\n\t\t * Number of total bytes to upload.\n\t\t *\n\t\t * It might be different than the file size because of headers and additional data.\n\t\t * It contains `null` if value is not available yet, so it's better to use {@link #uploadedPercent} to monitor\n\t\t * the progress.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number|null} #uploadTotal\n\t\t */\n        this.set('uploadTotal', null);\n        /**\n\t\t * Upload progress in percents.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number} #uploadedPercent\n\t\t */\n        this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (uploaded, total) => {\n            return total ? uploaded / total * 100 : 0;\n        });\n    }\n    /**\n\t * Returns the loader associated with specified file.\n\t *\n\t * To get loader by id use `fileRepository.loaders.get( id )`.\n\t *\n\t * @param {File} file Native file handle.\n\t * @returns {module:upload/filerepository~FileLoader|null}\n\t */\n    getLoader(file) {\n        for (const loader of this.loaders) {\n            if (loader.file == file) {\n                return loader;\n            }\n        }\n        return null;\n    }\n    /**\n\t * Creates a loader instance for the given file.\n\t *\n\t * Requires {@link #createUploadAdapter} factory to be defined.\n\t *\n\t * @param {File} file Native File object.\n\t * @returns {module:upload/filerepository~FileLoader|null}\n\t */\n    createLoader(file) {\n        if (!this.createUploadAdapter) {\n            /**\n\t\t\t * You need to enable an upload adapter in order to be able to upload files.\n\t\t\t *\n\t\t\t * This warning shows up when {@link module:upload/filerepository~FileRepository} is being used\n\t\t\t * without {@link #createUploadAdapter definining an upload adapter}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**\n\t\t\t * it means that you did not configure any of the upload adapters available by default in those builds.\n\t\t\t * See:\n\t\t\t *\n\t\t\t * * {@link module:core/editor/editorconfig~EditorConfig#cloudServices `config.cloudServices`} for\n\t\t\t * Easy Image with Cloud Services integration,\n\t\t\t * * {@link module:core/editor/editorconfig~EditorConfig#ckfinder `config.ckfinder`} for CKFinder\n\t\t\t * file upload integration.\n\t\t\t *\n\t\t\t * **If you see this warning when using a custom build** there is a chance that you enabled\n\t\t\t * a feature like {@link module:image/imageupload~ImageUpload},\n\t\t\t * or {@link module:image/imageupload/imageuploadui~ImageUploadUI} but you did not enable any upload adapter.\n\t\t\t * You can choose one of the existing upload adapters:\n\t\t\t *\n\t\t\t * * {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter}\n\t\t\t * (remember to {@link module:core/editor/editorconfig~EditorConfig#cloudServices configure it})\n\t\t\t * * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}\n\t\t\t * (remember to {@link module:core/editor/editorconfig~EditorConfig#ckfinder configure it})\n\t\t\t *\n\t\t\t * You can also implement your own upload adapter (in which case, please refer\n\t\t\t * to the {@link module:upload/filerepository~UploadAdapter `UploadAdapter` interface} documentation).\n\t\t\t *\n\t\t\t * @error filerepository-no-upload-adapter\n\t\t\t */\n            log.error('filerepository-no-upload-adapter: Upload adapter is not defined.');\n            return null;\n        }\n        const loader = new FileLoader(file);\n        loader._adapter = this.createUploadAdapter(loader);\n        this.loaders.add(loader);\n        loader.on('change:uploaded', () => {\n            let aggregatedUploaded = 0;\n            for (const loader of this.loaders) {\n                aggregatedUploaded += loader.uploaded;\n            }\n            this.uploaded = aggregatedUploaded;\n        });\n        loader.on('change:uploadTotal', () => {\n            let aggregatedTotal = 0;\n            for (const loader of this.loaders) {\n                if (loader.uploadTotal) {\n                    aggregatedTotal += loader.uploadTotal;\n                }\n            }\n            this.uploadTotal = aggregatedTotal;\n        });\n        return loader;\n    }\n    /**\n\t * Destroys the given loader.\n\t *\n\t * @param {File|module:upload/filerepository~FileLoader} fileOrLoader File associated with that loader or loader\n\t * itself.\n\t */\n    destroyLoader(fileOrLoader) {\n        const loader = fileOrLoader instanceof FileLoader ? fileOrLoader : this.getLoader(fileOrLoader);\n        loader._destroy();\n        this.loaders.remove(loader);\n    }\n    /**\n\t * Registers or deregisters pending action bound with upload progress.\n\t *\n\t * @private\n\t */\n    _updatePendingAction() {\n        const pendingActions = this.editor.plugins.get(PendingActions);\n        if (this.loaders.length) {\n            if (!this._pendingAction) {\n                const t = this.editor.t;\n                const getMessage = value => `${ t('Upload in progress') } ${ parseInt(value) }%.`;\n                this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));\n                this._pendingAction.bind('message').to(this, 'uploadedPercent', getMessage);\n            }\n        } else {\n            pendingActions.remove(this._pendingAction);\n            this._pendingAction = null;\n        }\n    }\n}\nmix(FileRepository, ObservableMixin);\n/**\n * File loader class.\n * It is used to control the process of file reading and uploading using specified adapter.\n */\nclass FileLoader {\n    /**\n\t * Creates a new instance of `FileLoader`.\n\t *\n\t * @param {File} file A native file instance.\n\t * @param {module:upload/filerepository~UploadAdapter} adapter\n\t */\n    constructor(file, adapter) {\n        /**\n\t\t * Unique id of FileLoader instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n        this.id = uid();\n        /**\n\t\t * A `File` instance associated with this file loader.\n\t\t *\n\t\t * @readonly\n\t\t * @member {File}\n\t\t */\n        this.file = file;\n        /**\n\t\t * Adapter instance associated with this file loader.\n\t\t *\n\t\t * @private\n\t\t * @member {module:upload/filerepository~UploadAdapter}\n\t\t */\n        this._adapter = adapter;\n        /**\n\t\t * FileReader used by FileLoader.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:upload/filereader~FileReader}\n\t\t */\n        this._reader = new FileReader();\n        /**\n\t\t * Current status of FileLoader. It can be one of the following:\n\t\t *\n\t\t * * 'idle',\n\t\t * * 'reading',\n\t\t * * 'uploading',\n\t\t * * 'aborted',\n\t\t * * 'error'.\n\t\t *\n\t\t * When reading status can change in a following way:\n\t\t *\n\t\t * `idle` -> `reading` -> `idle`\n\t\t * `idle` -> `reading -> `aborted`\n\t\t * `idle` -> `reading -> `error`\n\t\t *\n\t\t * When uploading status can change in a following way:\n\t\t *\n\t\t * `idle` -> `uploading` -> `idle`\n\t\t * `idle` -> `uploading` -> `aborted`\n\t\t * `idle` -> `uploading` -> `error`\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {String} #status\n\t\t */\n        this.set('status', 'idle');\n        /**\n\t\t * Number of bytes uploaded.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number} #uploaded\n\t\t */\n        this.set('uploaded', 0);\n        /**\n\t\t * Number of total bytes to upload.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number|null} #uploadTotal\n\t\t */\n        this.set('uploadTotal', null);\n        /**\n\t\t * Upload progress in percents.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Number} #uploadedPercent\n\t\t */\n        this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (uploaded, total) => {\n            return total ? uploaded / total * 100 : 0;\n        });\n        /**\n\t\t * Response of the upload.\n\t\t *\n\t\t * @readonly\n\t\t * @observable\n\t\t * @member {Object|null} #uploadResponse\n\t\t */\n        this.set('uploadResponse', null);\n    }\n    /**\n\t * Reads file using {@link module:upload/filereader~FileReader}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status\n\t * is different than `idle`.\n\t *\n\t * Example usage:\n\t *\n\t *\tfileLoader.read()\n\t *\t\t.then( data => { ... } )\n\t *\t\t.catch( err => {\n\t *\t\t\tif ( err === 'aborted' ) {\n\t *\t\t\t\tconsole.log( 'Reading aborted.' );\n\t *\t\t\t} else {\n\t *\t\t\t\tconsole.log( 'Reading error.', err );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @returns {Promise} Returns promise that will be resolved with read data. Promise will be rejected if error\n\t * occurs or if read process is aborted.\n\t */\n    read() {\n        if (this.status != 'idle') {\n            throw new CKEditorError('filerepository-read-wrong-status: You cannot call read if the status is different than idle.');\n        }\n        this.status = 'reading';\n        return this._reader.read(this.file).then(data => {\n            this.status = 'idle';\n            return data;\n        }).catch(err => {\n            if (err === 'aborted') {\n                this.status = 'aborted';\n                throw 'aborted';\n            }\n            this.status = 'error';\n            throw this._reader.error;\n        });\n    }\n    /**\n\t * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status\n\t * is different than `idle`.\n\t * Example usage:\n\t *\n\t *\tfileLoader.upload()\n\t *\t\t.then( data => { ... } )\n\t *\t\t.catch( e => {\n\t *\t\t\tif ( e === 'aborted' ) {\n\t *\t\t\t\tconsole.log( 'Uploading aborted.' );\n\t *\t\t\t} else {\n\t *\t\t\t\tconsole.log( 'Uploading error.', e );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @returns {Promise} Returns promise that will be resolved with response data. Promise will be rejected if error\n\t * occurs or if read process is aborted.\n\t */\n    upload() {\n        if (this.status != 'idle') {\n            throw new CKEditorError('filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.');\n        }\n        this.status = 'uploading';\n        return this._adapter.upload().then(data => {\n            this.uploadResponse = data;\n            this.status = 'idle';\n            return data;\n        }).catch(err => {\n            if (this.status === 'aborted') {\n                throw 'aborted';\n            }\n            this.status = 'error';\n            throw err;\n        });\n    }\n    /**\n\t * Aborts loading process.\n\t */\n    abort() {\n        const status = this.status;\n        this.status = 'aborted';\n        if (status == 'reading') {\n            this._reader.abort();\n        }\n        if (status == 'uploading' && this._adapter.abort) {\n            this._adapter.abort();\n        }\n        this._destroy();\n    }\n    /**\n\t * Performs cleanup.\n\t *\n\t * @private\n\t */\n    _destroy() {\n        this._reader = undefined;\n        this._adapter = undefined;\n        this.data = undefined;\n        this.uploadResponse = undefined;\n        this.file = undefined;\n    }\n}\nmix(FileLoader, ObservableMixin);    /**\n * Upload adapter interface used by FileRepository to handle file upload. Upload adapter is a bridge between the editor and server that\n * handles file uploads. It should contain logic necessary to initiate upload process and monitor its progress.\n *\n * It should implement two methods:\n *\n * * {@link module:upload/filerepository~UploadAdapter#upload `upload()`},\n * * {@link module:upload/filerepository~UploadAdapter#abort `abort()`}.\n *\n * Example upload adapter implementation:\n *\n *\t\tclass UploadAdapter {\n *\t\t\tconstructor( loader ) {\n *\t\t\t\t// Save Loader instance to update upload progress.\n *\t\t\t\tthis.loader = loader;\n *\t\t\t}\n *\n *\t\t\tupload() {\n *\t\t\t\t// Update loader's progress.\n *\t\t\t\tserver.onUploadProgress( data => {\n *\t\t\t\t\tloader.uploadTotal = data.total;\n *\t\t\t\t\tloader.uploaded = data.uploaded;\n *\t\t\t\t} ):\n *\n *\t\t\t\t// Return promise that will be resolved when file is uploaded.\n *\t\t\t\treturn server.upload( loader.file );\n *\t\t\t}\n *\n *\t\t\tabort() {\n *\t\t\t\t// Reject promise returned from upload() method.\n *\t\t\t\tserver.abortUpload();\n *\t\t\t}\n *\t\t}\n *\n * Then upload adapter can be set to be used by {@link module:upload/filerepository~FileRepository FileRepository}:\n *\n *\t\teditor.plugins.get( 'FileRepository' ).createUploadAdapter = function( loader ) {\n *\t\t\treturn new UploadAdapter( loader );\n *\t\t};\n *\n * @interface UploadAdapter\n */\n                                     /**\n * Executes the upload process.\n * This method should return a promise that will resolve when data will be uploaded to server. Promise should be\n * resolved with an object containing information about uploaded file:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png'\n *\t\t}\n *\n * Additionally, other image sizes can be provided:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png',\n *\t\t\t'160': 'http://server/size-160.image.png',\n *\t\t\t'500': 'http://server/size-500.image.png',\n *\t\t\t'1000': 'http://server/size-1000.image.png',\n *\t\t\t'1052': 'http://server/default-size.image.png'\n *\t\t}\n *\n * NOTE: When returning multiple images, the widest returned one should equal the default one. It is essential to\n * correctly set `width` attribute of the image. See this discussion:\n * https://github.com/ckeditor/ckeditor5-easy-image/issues/4 for more information.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#upload\n * @returns {Promise} Promise that should be resolved when data is uploaded.\n */\n                                     /**\n * Aborts the upload process.\n * After aborting it should reject promise returned from {@link #upload upload()}.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#abort\n */","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* eslint-env browser */\n\n'use strict';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\nconst BASE64_HEADER_REG_EXP = /^data:(\\S*?);base64,/;\n\n/**\n * FileUploader class used to upload single file.\n */\nclass FileUploader {\n\t/**\n\t * Creates `FileUploader` instance.\n\t *\n\t * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.\n\t * @param {Token} token Token used for authentication.\n\t * @param {String} apiAddress API address.\n\t */\n\tconstructor( fileOrData, token, apiAddress ) {\n\t\tif ( !fileOrData ) {\n\t\t\tthrow new Error( 'File must be provided' );\n\t\t}\n\n\t\tif ( !token ) {\n\t\t\tthrow new Error( 'Token must be provided' );\n\t\t}\n\n\t\tif ( !apiAddress ) {\n\t\t\tthrow new Error( 'Api address must be provided' );\n\t\t}\n\n\t\t/**\n\t\t * A file that is being uploaded.\n\t\t *\n\t\t * @type {Blob}\n\t\t */\n\t\tthis.file = _isBase64( fileOrData ) ? _base64ToBlob( fileOrData ) : fileOrData;\n\n\t\t/**\n\t\t * CKEditor Cloud Services access token.\n\t\t *\n\t\t * @type {Token}\n\t\t * @private\n\t\t */\n\t\tthis._token = token;\n\n\t\t/**\n\t\t * CKEditor Cloud Services API address.\n\t\t *\n\t\t * @type {String}\n\t\t * @private\n\t\t */\n\t\tthis._apiAddress = apiAddress;\n\t}\n\n\t/**\n\t * Registers callback on `progress` event.\n\t *\n\t * @chainable\n\t * @param {Function} callback\n\t * @returns {FileUploader}\n\t */\n\tonProgress( callback ) {\n\t\tthis.on( 'progress', ( event, data ) => callback( data ) );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Registers callback on `error` event. Event is called once when error occurs.\n\t *\n\t * @chainable\n\t * @param {Function} callback\n\t * @returns {FileUploader}\n\t */\n\tonError( callback ) {\n\t\tthis.once( 'error', ( event, data ) => callback( data ) );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Aborts upload process.\n\t */\n\tabort() {\n\t\tthis.xhr.abort();\n\t}\n\n\t/**\n\t * Sends XHR request to API.\n\t *\n\t * @chainable\n\t * @returns {Promise.<Object>}\n\t */\n\tsend() {\n\t\tthis._prepareRequest();\n\t\tthis._attachXHRListeners();\n\n\t\treturn this._sendRequest();\n\t}\n\n\t/**\n\t * Prepares XHR request.\n\t *\n\t * @private\n\t */\n\t_prepareRequest() {\n\t\tconst xhr = new XMLHttpRequest();\n\n\t\txhr.open( 'POST', this._apiAddress );\n\t\txhr.setRequestHeader( 'Authorization', this._token.value );\n\t\txhr.responseType = 'json';\n\n\t\tthis.xhr = xhr;\n\t}\n\n\t/**\n\t * Attaches listeners to the XHR.\n\t *\n\t * @private\n\t */\n\t_attachXHRListeners() {\n\t\tconst that = this;\n\t\tconst xhr = this.xhr;\n\n\t\txhr.addEventListener( 'error', onError( 'Network Error' ) );\n\t\txhr.addEventListener( 'abort', onError( 'Abort' ) );\n\n\t\t/* istanbul ignore else */\n\t\tif ( xhr.upload ) {\n\t\t\txhr.upload.addEventListener( 'progress', event => {\n\t\t\t\tif ( event.lengthComputable ) {\n\t\t\t\t\tthis.fire( 'progress', {\n\t\t\t\t\t\ttotal: event.total,\n\t\t\t\t\t\tuploaded: event.loaded\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\txhr.addEventListener( 'load', () => {\n\t\t\tconst statusCode = xhr.status;\n\t\t\tconst xhrResponse = xhr.response;\n\n\t\t\tif ( statusCode < 200 || statusCode > 299 ) {\n\t\t\t\treturn this.fire( 'error', xhrResponse.message || xhrResponse.error );\n\t\t\t}\n\t\t} );\n\n\t\tfunction onError( message ) {\n\t\t\treturn () => that.fire( 'error', message );\n\t\t}\n\t}\n\n\t/**\n\t * Sends XHR request.\n\t *\n\t * @private\n\t */\n\t_sendRequest() {\n\t\tconst formData = new FormData();\n\t\tconst xhr = this.xhr;\n\n\t\tformData.append( 'file', this.file );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\t\t\txhr.addEventListener( 'load', () => {\n\t\t\t\tconst statusCode = xhr.status;\n\t\t\t\tconst xhrResponse = xhr.response;\n\n\t\t\t\tif ( statusCode < 200 || statusCode > 299 ) {\n\t\t\t\t\treturn reject( xhrResponse.message || xhrResponse.error );\n\t\t\t\t}\n\n\t\t\t\treturn resolve( xhrResponse );\n\t\t\t} );\n\n\t\t\txhr.addEventListener( 'error', () => reject( 'Network Error' ) );\n\t\t\txhr.addEventListener( 'abort', () => reject( 'Abort' ) );\n\n\t\t\txhr.send( formData );\n\t\t} );\n\t}\n\n\t/**\n\t * Fired when error occurs.\n\t *\n\t * @event error\n\t * @param {String} error Error message\n\t */\n\n\t/**\n\t * Fired on upload progress.\n\t *\n\t * @event progress\n\t * @param {Object} status Total and uploaded status\n\t */\n}\n\nmix( FileUploader, EmitterMixin );\n\n/**\n * Transforms Base64 string data into file.\n *\n * @param {String} base64 String data.\n * @param {Number} [sliceSize=512]\n * @returns {Blob}\n * @private\n */\nfunction _base64ToBlob( base64, sliceSize = 512 ) {\n\ttry {\n\t\tconst contentType = base64.match( BASE64_HEADER_REG_EXP )[ 1 ];\n\t\tconst base64Data = atob( base64.replace( BASE64_HEADER_REG_EXP, '' ) );\n\n\t\tconst byteArrays = [];\n\n\t\tfor ( let offset = 0; offset < base64Data.length; offset += sliceSize ) {\n\t\t\tconst slice = base64Data.slice( offset, offset + sliceSize );\n\t\t\tconst byteNumbers = new Array( slice.length );\n\n\t\t\tfor ( let i = 0; i < slice.length; i++ ) {\n\t\t\t\tbyteNumbers[ i ] = slice.charCodeAt( i );\n\t\t\t}\n\n\t\t\tbyteArrays.push( new Uint8Array( byteNumbers ) );\n\t\t}\n\n\t\treturn new Blob( byteArrays, { type: contentType } );\n\t} catch ( error ) {\n\t\tthrow new Error( 'Problem with decoding Base64 image data.' );\n\t}\n}\n\n/**\n * Checks that string is Base64.\n *\n * @param {String} string\n * @returns {Boolean}\n * @private\n */\nfunction _isBase64( string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn false;\n\t}\n\n\tconst match = string.match( BASE64_HEADER_REG_EXP );\n\treturn !!( match && match.length );\n}\n\nexport default FileUploader;\n","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* eslint-env browser */\n\n'use strict';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n\nconst DEFAULT_OPTIONS = { refreshInterval: 3600000, autoRefresh: true };\n\n/**\n * Class representing the token used for communication with CKEditor Cloud Services.\n * Value of the token is retrieving from the specified URL and is refreshed every 1 hour by default.\n *\n * @mixes ObservableMixin\n */\nclass Token {\n\t/**\n\t * Creates `Token` instance.\n\t * Method `init` should be called after using the constructor or use `create` method instead.\n\t *\n\t * @param {String} tokenUrl Endpoint address to download the token.\n\t * @param {Object} options\n\t * @param {String} [options.initValue] Initial value of the token.\n\t * @param {Number} [options.refreshInterval=3600000] Delay between refreshes. Default 1 hour.\n\t * @param {Boolean} [options.autoRefresh=true] Specifies whether to start the refresh automatically.\n\t */\n\tconstructor( tokenUrl, options = DEFAULT_OPTIONS ) {\n\t\tif ( !tokenUrl ) {\n\t\t\tthrow new Error( '`tokenUrl` must be provided' );\n\t\t}\n\n\t\t/**\n\t\t * Value of the token.\n\t\t * The value of the token is null if `initValue` is not provided or `init` method was not called.\n\t\t * `create` method creates token with initialized value from url.\n\t\t *\n\t\t * @name value\n\t\t * @type {String}\n\t\t * @observable\n\t\t * @readonly\n\t\t * @memberOf Token#\n\t\t */\n\t\tthis.set( 'value', options.initValue );\n\n\t\t/**\n\t\t * @type {String}\n\t\t * @private\n\t\t */\n\t\tthis._tokenUrl = tokenUrl;\n\n\t\t/**\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._options = Object.assign( {}, DEFAULT_OPTIONS, options );\n\t}\n\n\t/**\n\t * Initializes the token.\n\t *\n\t * @returns {Promise.<Token>}\n\t */\n\tinit() {\n\t\treturn new Promise( ( resolve, reject ) => {\n\t\t\tif ( this._options.autoRefresh ) {\n\t\t\t\tthis._startRefreshing();\n\t\t\t}\n\n\t\t\tif ( !this.value ) {\n\t\t\t\tthis._refreshToken()\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve( this );\n\t\t} );\n\t}\n\n\t/**\n\t * Gets the new token.\n\t *\n\t * @protected\n\t * @returns {Promise.<Token>}\n\t */\n\t_refreshToken() {\n\t\treturn new Promise( ( resolve, reject ) => {\n\t\t\tconst xhr = new XMLHttpRequest();\n\n\t\t\txhr.open( 'GET', this._tokenUrl );\n\n\t\t\txhr.addEventListener( 'load', () => {\n\t\t\t\tconst statusCode = xhr.status;\n\t\t\t\tconst xhrResponse = xhr.response;\n\n\t\t\t\tif ( statusCode < 200 || statusCode > 299 ) {\n\t\t\t\t\treturn reject( 'Cannot download new token!' );\n\t\t\t\t}\n\n\t\t\t\tthis.set( 'value', xhrResponse );\n\n\t\t\t\treturn resolve( this );\n\t\t\t} );\n\n\t\t\txhr.addEventListener( 'error', () => reject( 'Network Error' ) );\n\t\t\txhr.addEventListener( 'abort', () => reject( 'Abort' ) );\n\n\t\t\txhr.send();\n\t\t} );\n\t}\n\n\t/**\n\t * Starts value refreshing every `refreshInterval` time.\n\t *\n\t * @protected\n\t */\n\t_startRefreshing() {\n\t\tthis._refreshInterval = setInterval( this._refreshToken.bind( this ), this._options.refreshInterval );\n\t}\n\n\t/**\n\t * Stops value refreshing.\n\t *\n\t * @protected\n\t */\n\t_stopRefreshing() {\n\t\tclearInterval( this._refreshInterval );\n\t}\n\n\t/**\n\t * Creates a initialized {@link Token} instance.\n\t *\n\t * @param {String} tokenUrl Endpoint address to download the token.\n\t * @param {Object} options\n\t * @param {String} [options.initValue] Initial value of the token.\n\t * @param {Number} [options.refreshInterval=3600000] Delay between refreshes. Default 1 hour.\n\t * @param {Boolean} [options.autoRefresh=true] Specifies whether to start the refresh automatically.\n\t * @returns {Promise.<Token>}\n\t */\n\tstatic create( tokenUrl, options = DEFAULT_OPTIONS ) {\n\t\tconst token = new Token( tokenUrl, options );\n\n\t\treturn token.init();\n\t}\n}\n\nmix( Token, ObservableMixin );\n\nexport default Token;\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module cloud-services/cloudservices\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Token from '@ckeditor/ckeditor-cloud-services-core/src/token/token';\n\n/**\n * Plugin introducing CKEditor 5's Cloud Services integration.\n * It takes care of the {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudService`}\n * configuration options and initializes the token provider.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class CloudServices extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst config = editor.config;\n\n\t\tconst options = config.get( 'cloudServices' ) || {};\n\n\t\tfor ( const optionName in options ) {\n\t\t\tthis[ optionName ] = options[ optionName ];\n\t\t}\n\n\t\t/**\n\t\t * The authentication token URL for CKEditor Cloud Services.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String|undefined} #tokenUrl\n\t\t */\n\n\t\t/**\n\t\t * The URL to which the files should be uploaded.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} #uploadUrl\n\t\t */\n\n\t\t/**\n\t\t * Other plugins use this token for the authorization process. It handles token requesting and refreshing.\n\t\t * Its value is `null` when {@link module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl} is not provided.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object|null} #token\n\t\t */\n\n\t\tif ( !this.tokenUrl ) {\n\t\t\tthis.token = null;\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.token = new CloudServices.Token( this.tokenUrl );\n\n\t\treturn this.token.init();\n\t}\n}\n\nCloudServices.Token = Token;\n\n/**\n * The configuration of CKEditor Cloud Services. Introduced by the {@link module:cloud-services/cloudservices~CloudServices} plugin.\n *\n * Read more in {@link module:cloud-services/cloudservices~CloudServicesConfig}.\n *\n * @member {module:cloud-services/cloudservices~CloudServicesConfig} module:core/editor/editorconfig~EditorConfig#cloudServices\n */\n\n/**\n * The configuration for all plugins using CKEditor Cloud Services.\n *\n *\t\tClassicEditor\n *\t\t\t.create( document.querySelector( '#editor' ), {\n *\t\t\t\tcloudServices: {\n *\t\t\t\t\ttokenUrl: 'https://example.com/cs-token-endpoint',\n *\t\t\t\t\tuploadUrl: 'https://your-organization-id.cke-cs.com/easyimage/upload/'\n *\t\t\t\t}\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.\n *\n * @interface CloudServicesConfig\n */\n\n/**\n * The URL to the security token endpoint in your application. The role of this endpoint is to securely authorize the\n * end users of your application to use [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services), only\n * if they should have access e.g. to upload files with Easy Image or to access the Collaboraation service.\n *\n * You can find more information about token endpoints in the\n * {@glink @cs guides/quick-start#create-token-endpoint Cloud Services - Quick start}\n * and {@glink @cs guides/token-endpoints/tokenendpoint Cloud Services - Creating token endpoint} documentation.\n *\n * Without a properly working token endpoint (token URL) CKEditor plugins will not be able to connect to CKEditor Cloud Services.\n *\n * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl\n */\n\n/**\n * The endpoint URL for [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services) uploads.\n * This option must be set for Easy Image to work correctly.\n *\n * The upload URL is unique for each customer and can be found in the [CKEditor Ecosystem dashboard](https://dashboard.ckeditor.com)\n * after subscribing to Easy Image service.\n * To learn how to start using Easy Image check {@glink @cs guides/easy-image/quick-start Easy Image - Quick start} documentation.\n *\n * Note: Make sure to also set the {@link module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl} configuration option.\n *\n * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#uploadUrl\n */\n\n/**\n * The URL for web socket communication, used by `CollaborativeEditing` plugin. Every customer (organization in the CKEditor\n * Ecosystem dashboard) has its own, unique URLs to communicate with CKEditor Cloud Services. The URL can be found in the\n * CKEditor Ecosystem dashboard.\n *\n * Note: unlike most plugins, `CollaborativeEditing` is not included in any CKEditor 5 build and has to be installed manually.\n * Check [Collaboration overview](https://docs.ckeditor.com/ckeditor5/latest/features/collaboration/overview.html) for more details.\n *\n * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#webSocketUrl\n */\n\n/**\n * Document ID, used by `CollaborativeEditing` plugin. All editor instances created with the same document ID will collaborate.\n * It means that each document needs a different document ID if you do not want to start collaboration between these documents.\n * The ID is usually a primary key of the document in the database, but you are free to provide whatever identifier fits your scenario.\n *\n * Note: unlike most plugins, `CollaborativeEditing` is not included in any CKEditor 5 build and has to be installed manually.\n * Check [Collaboration overview](https://docs.ckeditor.com/ckeditor5/latest/features/collaboration/overview.html) for more details.\n *\n * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#documentId\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n* @module easy-image/cloudservicesuploadadapter\n*/\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport UploadGateway from '@ckeditor/ckeditor-cloud-services-core/src/uploadgateway/uploadgateway';\nimport CloudServices from '@ckeditor/ckeditor5-cloud-services/src/cloudservices';\n\n/**\n * A plugin that enables upload to [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/).\n *\n * It is mainly used by the {@link module:easy-image/easyimage~EasyImage} feature.\n *\n * After enabling this adapter you need to configure the CKEditor Cloud Services integration through\n * {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudServices`}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class CloudServicesUploadAdapter extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ FileRepository, CloudServices ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\tconst cloudServices = editor.plugins.get( CloudServices );\n\n\t\tconst token = cloudServices.token;\n\t\tconst uploadUrl = cloudServices.uploadUrl;\n\n\t\tif ( !token ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._uploadGateway = new CloudServicesUploadAdapter._UploadGateway( token, uploadUrl );\n\n\t\teditor.plugins.get( FileRepository ).createUploadAdapter = loader => {\n\t\t\treturn new Adapter( this._uploadGateway, loader );\n\t\t};\n\t}\n}\n\n/**\n * @private\n */\nclass Adapter {\n\tconstructor( uploadGateway, loader ) {\n\t\tthis.uploadGateway = uploadGateway;\n\n\t\tthis.loader = loader;\n\t}\n\n\tupload() {\n\t\tthis.fileUploader = this.uploadGateway.upload( this.loader.file );\n\n\t\tthis.fileUploader.on( 'progress', ( evt, data ) => {\n\t\t\tthis.loader.uploadTotal = data.total;\n\t\t\tthis.loader.uploaded = data.uploaded;\n\t\t} );\n\n\t\treturn this.fileUploader.send();\n\t}\n\n\tabort() {\n\t\tthis.fileUploader.abort();\n\t}\n}\n\n// Store the API in static property to easily overwrite it in tests.\n// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.\nCloudServicesUploadAdapter._UploadGateway = UploadGateway;\n","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n'use strict';\n\nimport FileUploader from './fileuploader';\n\n/**\n * UploadGateway abstracts file uploads to CKEditor Cloud Services.\n */\nexport default class UploadGateway {\n\t/**\n\t * Creates `UploadGateway` instance.\n\t *\n\t * @param {Token} token Token used for authentication.\n\t * @param {String} apiAddress API address.\n\t */\n\tconstructor( token, apiAddress ) {\n\t\tif ( !token ) {\n\t\t\tthrow new Error( 'Token must be provided' );\n\t\t}\n\n\t\tif ( !apiAddress ) {\n\t\t\tthrow new Error( 'Api address must be provided' );\n\t\t}\n\n\t\t/**\n\t\t * CKEditor Cloud Services access token.\n\t\t *\n\t\t * @type {Token}\n\t\t * @private\n\t\t */\n\t\tthis._token = token;\n\n\t\t/**\n\t\t * CKEditor Cloud Services API address.\n\t\t *\n\t\t * @type {String}\n\t\t * @private\n\t\t */\n\t\tthis._apiAddress = apiAddress;\n\t}\n\n\t/**\n\t * Creates a {@link FileUploader} instance that wraps file upload process.\n\t * The file is being sent at a time when the method {@link FileUploader#then then} is called\n\t * or when {@link FileUploader#send send} method is called.\n\t *\n\t *     const token = await Token.create( 'https://token-endpoint' );\n\t *     new UploadGateway( token, 'https://example.org' )\n\t *        .upload( 'FILE' )\n\t *        .onProgress( ( data ) => console.log( data ) )\n\t *        .send()\n\t *        .then( ( response ) => console.log( response ) );\n\t *\n\t *     // OR\n\t *\n\t *     const token = await Token.create( 'https://token-endpoint' );\n\t *     new UploadGateway( token, 'https://example.org' )\n\t *         .upload( 'FILE' )\n\t *         .onProgress( ( data ) => console.log( data ) )\n\t *         .send()\n\t *         .then( ( response ) => console.log( response ) );\n\t *\n\t * @param {Blob/String} fileOrData A blob object or a data string encoded with Base64.\n\t * @returns {FileUploader} Returns `FileUploader` instance.\n\t */\n\tupload( fileOrData ) {\n\t\treturn new FileUploader( fileOrData, this._token, this._apiAddress );\n\t}\n}\n\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/image/imageloadobserver\n */\n\nimport Observer from '@ckeditor/ckeditor5-engine/src/view/observer/observer';\n\n/**\n * Observes all new images added to the {@link module:engine/view/document~Document},\n * fires {@link module:engine/view/document~Document#event:imageLoaded} and\n * {@link module:engine/view/document~Document#event:layoutChanged} event every time when the new image\n * has been loaded.\n *\n * **Note:** This event is not fired for images that has been added to the document and rendered as `complete` (already loaded).\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class ImageLoadObserver extends Observer {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * List of img DOM elements that are observed by this observer.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<HTMLElement>}\n\t\t */\n\t\tthis._observedElements = new Set();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve( domRoot, name ) {\n\t\tconst viewRoot = this.document.getRoot( name );\n\n\t\t// When there is a change in one of the view element\n\t\t// we need to check if there are any new `<img/>` elements to observe.\n\t\tviewRoot.on( 'change:children', ( evt, node ) => {\n\t\t\t// Wait for the render to be sure that `<img/>` elements are rendered in the DOM root.\n\t\t\tthis.view.once( 'render', () => this._updateObservedElements( domRoot, node ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Updates the list of observed `<img/>` elements.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot DOM root element.\n\t * @param {module:engine/view/element~Element} viewNode View element where children have changed.\n\t */\n\t_updateObservedElements( domRoot, viewNode ) {\n\t\tif ( !viewNode.is( 'element' ) || viewNode.is( 'attributeElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst domNode = this.view.domConverter.mapViewToDom( viewNode );\n\n\t\t// If there is no `domNode` it means that it was removed from the DOM in the meanwhile.\n\t\tif ( !domNode ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const domElement of domNode.querySelectorAll( 'img' ) ) {\n\t\t\tif ( !this._observedElements.has( domElement ) ) {\n\t\t\t\tthis.listenTo( domElement, 'load', ( evt, domEvt ) => this._fireEvents( domEvt ) );\n\t\t\t\tthis._observedElements.add( domElement );\n\t\t\t}\n\t\t}\n\n\t\t// Clean up the list of observed elements from elements that has been removed from the root.\n\t\tfor ( const domElement of this._observedElements ) {\n\t\t\tif ( !domRoot.contains( domElement ) ) {\n\t\t\t\tthis.stopListening( domElement );\n\t\t\t\tthis._observedElements.delete( domElement );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fires {@link module:engine/view/document~Document#event:layoutChanged} and\n\t * {@link module:engine/view/document~Document#event:imageLoaded}\n\t * if observer {@link #isEnabled is enabled}.\n\t *\n\t * @protected\n\t * @param {Event} domEvent The DOM event.\n\t */\n\t_fireEvents( domEvent ) {\n\t\tif ( this.isEnabled ) {\n\t\t\tthis.document.fire( 'layoutChanged' );\n\t\t\tthis.document.fire( 'imageLoaded', domEvent );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis._observedElements.clear();\n\t\tsuper.destroy();\n\t}\n}\n\n/**\n * Fired when an <img/> DOM element has been loaded in the DOM root.\n *\n * Introduced by {@link module:image/image/imageloadobserver~ImageLoadObserver}.\n *\n * @see module:image/image/imageloadobserver~ImageLoadObserver\n * @event module:engine/view/document~Document#event:imageLoaded\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/image/converters\n */\n\nimport ModelPosition from '@ckeditor/ckeditor5-engine/src/model/position';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n\n/**\n * Returns a function that converts the image view representation:\n *\n *\t\t<figure class=\"image\"><img src=\"...\" alt=\"...\"></img></figure>\n *\n * to the model representation:\n *\n *\t\t<image src=\"...\" alt=\"...\"></image>\n *\n * The entire content of the `<figure>` element except the first `<img>` is being converted as children\n * of the `<image>` model element.\n *\n * @returns {Function}\n */\nexport function viewFigureToModel() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:figure', converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\t// Do not convert if this is not an \"image figure\".\n\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: true, classes: 'image' } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find an image element inside the figure element.\n\t\tconst viewImage = Array.from( data.viewItem.getChildren() ).find( viewChild => viewChild.is( 'img' ) );\n\n\t\t// Do not convert if image element is absent, is missing src attribute or was already converted.\n\t\tif ( !viewImage || !viewImage.hasAttribute( 'src' ) || !conversionApi.consumable.test( viewImage, { name: true } ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Convert view image to model image.\n\t\tconst conversionResult = conversionApi.convertItem( viewImage, data.modelCursor );\n\n\t\t// Get image element from conversion result.\n\t\tconst modelImage = first( conversionResult.modelRange.getItems() );\n\n\t\t// When image wasn't successfully converted then finish conversion.\n\t\tif ( !modelImage ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Convert rest of the figure element's children as an image children.\n\t\tconversionApi.convertChildren( data.viewItem, ModelPosition.createAt( modelImage ) );\n\n\t\t// Set image range as conversion result.\n\t\tdata.modelRange = conversionResult.modelRange;\n\n\t\t// Continue conversion where image conversion ends.\n\t\tdata.modelCursor = conversionResult.modelCursor;\n\t}\n}\n\n/**\n * Converter used to convert the `srcset` model image attribute to the `srcset`, `sizes` and `width` attributes in the view.\n *\n * @returns {Function}\n */\nexport function srcsetAttributeConverter() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'attribute:srcset:image', converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst writer = conversionApi.writer;\n\t\tconst figure = conversionApi.mapper.toViewElement( data.item );\n\t\tconst img = figure.getChild( 0 );\n\n\t\tif ( data.attributeNewValue === null ) {\n\t\t\tconst srcset = data.attributeOldValue;\n\n\t\t\tif ( srcset.data ) {\n\t\t\t\twriter.removeAttribute( 'srcset', img );\n\t\t\t\twriter.removeAttribute( 'sizes', img );\n\n\t\t\t\tif ( srcset.width ) {\n\t\t\t\t\twriter.removeAttribute( 'width', img );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst srcset = data.attributeNewValue;\n\n\t\t\tif ( srcset.data ) {\n\t\t\t\twriter.setAttribute( 'srcset', srcset.data, img );\n\t\t\t\t// Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.\n\t\t\t\twriter.setAttribute( 'sizes', '100vw', img );\n\n\t\t\t\tif ( srcset.width ) {\n\t\t\t\t\twriter.setAttribute( 'width', srcset.width, img );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function modelToViewAttributeConverter( attributeKey ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `attribute:${ attributeKey }:image`, converter );\n\t};\n\n\tfunction converter( evt, data, conversionApi ) {\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst figure = conversionApi.mapper.toViewElement( data.item );\n\t\tconst img = figure.getChild( 0 );\n\n\t\tif ( data.attributeNewValue !== null ) {\n\t\t\tviewWriter.setAttribute( data.attributeKey, data.attributeNewValue, img );\n\t\t} else {\n\t\t\tviewWriter.removeAttribute( data.attributeKey, img );\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module widget/highlightstack\n */\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Class used to handle correct order of highlights on elements.\n *\n * When different highlights are applied to same element correct order should be preserved:\n *\n * * highlight with highest priority should be applied,\n * * if two highlights have same priority - sort by CSS class provided in\n * {@link module:engine/conversion/downcast-converters~HighlightDescriptor}.\n *\n * This way, highlight will be applied with the same rules it is applied on texts.\n */\nexport default class HighlightStack {\n\t/**\n\t * Creates class instance.\n\t */\n\tconstructor() {\n\t\tthis._stack = [];\n\t}\n\n\t/**\n\t * Adds highlight descriptor to the stack.\n\t *\n\t * @fires change:top\n\t * @param {module:engine/conversion/downcast-converters~HighlightDescriptor} descriptor\n\t * @param {module:engine/view/writer~Writer} writer\n\t */\n\tadd( descriptor, writer ) {\n\t\tconst stack = this._stack;\n\n\t\t// Save top descriptor and insert new one. If top is changed - fire event.\n\t\tconst oldTop = stack[ 0 ];\n\t\tthis._insertDescriptor( descriptor );\n\t\tconst newTop = stack[ 0 ];\n\n\t\t// When new object is at the top and stores different information.\n\t\tif ( oldTop !== newTop && !compareDescriptors( oldTop, newTop ) ) {\n\t\t\tthis.fire( 'change:top', {\n\t\t\t\toldDescriptor: oldTop,\n\t\t\t\tnewDescriptor: newTop,\n\t\t\t\twriter\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Removes highlight descriptor from the stack.\n\t *\n\t * @fires change:top\n\t * @param {String} id Id of the descriptor to remove.\n\t * @param {module:engine/view/writer~Writer} writer\n\t */\n\tremove( id, writer ) {\n\t\tconst stack = this._stack;\n\n\t\tconst oldTop = stack[ 0 ];\n\t\tthis._removeDescriptor( id );\n\t\tconst newTop = stack[ 0 ];\n\n\t\t// When new object is at the top and stores different information.\n\t\tif ( oldTop !== newTop && !compareDescriptors( oldTop, newTop ) ) {\n\t\t\tthis.fire( 'change:top', {\n\t\t\t\toldDescriptor: oldTop,\n\t\t\t\tnewDescriptor: newTop,\n\t\t\t\twriter\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Inserts given descriptor in correct place in the stack. It also takes care about updating information when\n\t * descriptor with same id is already present.\n\t *\n\t * @private\n\t * @param {module:engine/conversion/downcast-converters~HighlightDescriptor} descriptor\n\t */\n\t_insertDescriptor( descriptor ) {\n\t\tconst stack = this._stack;\n\t\tconst index = stack.findIndex( item => item.id === descriptor.id );\n\n\t\t// Inserting exact same descriptor - do nothing.\n\t\tif ( compareDescriptors( descriptor, stack[ index ] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If descriptor with same id but with different information is on the stack - remove it.\n\t\tif ( index > -1 ) {\n\t\t\tstack.splice( index, 1 );\n\t\t}\n\n\t\t// Find correct place to insert descriptor in the stack.\n\t\t// It have different information (for example priority) so it must be re-inserted in correct place.\n\t\tlet i = 0;\n\n\t\twhile ( stack[ i ] && shouldABeBeforeB( stack[ i ], descriptor ) ) {\n\t\t\ti++;\n\t\t}\n\n\t\tstack.splice( i, 0, descriptor );\n\t}\n\n\t/**\n\t * Removes descriptor with given id from the stack.\n\t *\n\t * @private\n\t * @param {String} id Descriptor's id.\n\t */\n\t_removeDescriptor( id ) {\n\t\tconst stack = this._stack;\n\t\tconst index = stack.findIndex( item => item.id === id );\n\n\t\t// If descriptor with same id is on the list - remove it.\n\t\tif ( index > -1 ) {\n\t\t\tstack.splice( index, 1 );\n\t\t}\n\t}\n}\n\nmix( HighlightStack, EmitterMixin );\n\n// Compares two descriptors by checking their priority and class list.\n//\n// @param {module:engine/conversion/downcast-converters~HighlightDescriptor} a\n// @param {module:engine/conversion/downcast-converters~HighlightDescriptor} b\n// @returns {Boolean} Returns true if both descriptors are defined and have same priority and classes.\nfunction compareDescriptors( a, b ) {\n\treturn a && b && a.priority == b.priority && classesToString( a.classes ) == classesToString( b.classes );\n}\n\n// Checks whenever first descriptor should be placed in the stack before second one.\n//\n// @param {module:engine/conversion/downcast-converters~HighlightDescriptor} a\n// @param {module:engine/conversion/downcast-converters~HighlightDescriptor} b\n// @returns {Boolean}\nfunction shouldABeBeforeB( a, b ) {\n\tif ( a.priority > b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority < b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use classes to compare.\n\treturn classesToString( a.classes ) > classesToString( b.classes );\n}\n\n// Converts CSS classes passed with {@link module:engine/conversion/downcast-converters~HighlightDescriptor} to\n// sorted string.\n//\n// @param {String|Array<String>} descriptor\n// @returns {String}\nfunction classesToString( classes ) {\n\treturn Array.isArray( classes ) ? classes.sort().join( ',' ) : classes;\n}\n\n/**\n * Fired when top element on {@link module:widget/highlightstack~HighlightStack} has been changed\n *\n * @event change:top\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor} [data.newDescriptor] New highlight\n * descriptor. It will be `undefined` when last descriptor is removed from the stack.\n * @param {module:engine/conversion/downcast-converters~HighlightDescriptor} [data.oldDescriptor] Old highlight\n * descriptor. It will be `undefined` when first descriptor is added to the stack.\n * @param {module:engine/view/writer~Writer} writer View writer that can be used to modify element.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* global DOMParser */\n\n/**\n * @module ui/icon/iconview\n */\n\nimport View from '../view';\n\nimport '../../theme/components/icon/icon.css';\n\n/**\n * The icon view class.\n *\n * @extends module:ui/view~View\n */\nexport default class IconView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst bind = this.bindTemplate;\n\n\t\t/**\n\t\t * The SVG source of the icon.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #content\n\t\t */\n\t\tthis.set( 'content', '' );\n\n\t\t/**\n\t\t * This attribute specifies the boundaries to which the\n\t\t * icon content should stretch.\n\t\t *\n\t\t * @observable\n\t\t * @default '0 0 20 20'\n\t\t * @member {String} #viewBox\n\t\t */\n\t\tthis.set( 'viewBox', '0 0 20 20' );\n\n\t\t/**\n\t\t * The fill color of the child `path.ck-icon__fill`.\n\t\t *\n\t\t * @observable\n\t\t * @default ''\n\t\t * @member {String} #fillColor\n\t\t */\n\t\tthis.set( 'fillColor', '' );\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'svg',\n\t\t\tns: 'http://www.w3.org/2000/svg',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-icon'\n\t\t\t\t],\n\t\t\t\tviewBox: bind.to( 'viewBox' )\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\tthis._updateXMLContent();\n\t\tthis._colorFillPaths();\n\n\t\t// This is a hack for lack of innerHTML binding.\n\t\t// See: https://github.com/ckeditor/ckeditor5-ui/issues/99.\n\t\tthis.on( 'change:content', () => {\n\t\t\tthis._updateXMLContent();\n\t\t\tthis._colorFillPaths();\n\t\t} );\n\n\t\tthis.on( 'change:fillColor', () => {\n\t\t\tthis._colorFillPaths();\n\t\t} );\n\t}\n\n\t/**\n\t * Updates the {@link #element} with the value of {@link #content}.\n\t *\n\t * @private\n\t */\n\t_updateXMLContent() {\n\t\tif ( this.content ) {\n\t\t\tconst parsed = new DOMParser().parseFromString( this.content.trim(), 'image/svg+xml' );\n\t\t\tconst svg = parsed.querySelector( 'svg' );\n\t\t\tconst viewBox = svg.getAttribute( 'viewBox' );\n\n\t\t\tif ( viewBox ) {\n\t\t\t\tthis.viewBox = viewBox;\n\t\t\t}\n\n\t\t\tthis.element.innerHTML = '';\n\n\t\t\twhile ( svg.childNodes.length > 0 ) {\n\t\t\t\tthis.element.appendChild( svg.childNodes[ 0 ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fills all child `path.ck-icon__fill` with the `#fillColor`.\n\t *\n\t * @private\n\t */\n\t_colorFillPaths() {\n\t\tif ( this.fillColor ) {\n\t\t\tthis.element.querySelectorAll( '.ck-icon__fill' ).forEach( path => {\n\t\t\t\tpath.style.fill = this.fillColor;\n\t\t\t} );\n\t\t}\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module widget/utils\n */\n\nimport HighlightStack from './highlightstack';\nimport Position from '@ckeditor/ckeditor5-engine/src/view/position';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport dragHandlerIcon from '../theme/icons/drag-handler.svg';\n\nconst widgetSymbol = Symbol( 'isWidget' );\nconst labelSymbol = Symbol( 'label' );\n\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n\n/**\n * Returns `true` if given {@link module:engine/view/element~Element} is a widget.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {Boolean}\n */\nexport function isWidget( element ) {\n\treturn !!element.getCustomProperty( widgetSymbol );\n}\n\n/**\n * Converts given {@link module:engine/view/element~Element} to widget in following way:\n * * sets `contenteditable` attribute to `\"true\"`,\n * * adds custom `getFillerOffset` method returning `null`,\n * * adds `ck-widget` CSS class,\n * * adds custom property allowing to recognize widget elements by using {@link ~isWidget},\n * * implements `addHighlight` and `removeHighlight` custom properties to handle view highlight on widgets.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/writer~Writer} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string.\n * @param {Boolean} [options.hasSelectionHandler=false] If `true`, the widget will have a selection handler added.\n * @returns {module:engine/view/element~Element} Returns same element.\n */\nexport function toWidget( element, writer, options = {} ) {\n\t// The selection on Edge behaves better when the whole editor contents is in a single contentedible element.\n\t// https://github.com/ckeditor/ckeditor5/issues/1079\n\tif ( !env.isEdge ) {\n\t\twriter.setAttribute( 'contenteditable', 'false', element );\n\t}\n\n\twriter.addClass( WIDGET_CLASS_NAME, element );\n\twriter.setCustomProperty( widgetSymbol, true, element );\n\telement.getFillerOffset = getFillerOffset;\n\n\tif ( options.label ) {\n\t\tsetLabel( element, options.label, writer );\n\t}\n\n\tif ( options.hasSelectionHandler ) {\n\t\taddSelectionHandler( element, writer );\n\t}\n\n\tsetHighlightHandling(\n\t\telement,\n\t\twriter,\n\t\t( element, descriptor, writer ) => writer.addClass( normalizeToArray( descriptor.classes ), element ),\n\t\t( element, descriptor, writer ) => writer.removeClass( normalizeToArray( descriptor.classes ), element )\n\t);\n\n\treturn element;\n\n\t// Normalizes CSS class in descriptor that can be provided in form of an array or a string.\n\tfunction normalizeToArray( classes ) {\n\t\treturn Array.isArray( classes ) ? classes : [ classes ];\n\t}\n}\n\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/writer~Writer} writer\n * @param {Function} add\n * @param {Function} remove\n */\nexport function setHighlightHandling( element, writer, add, remove ) {\n\tconst stack = new HighlightStack();\n\n\tstack.on( 'change:top', ( evt, data ) => {\n\t\tif ( data.oldDescriptor ) {\n\t\t\tremove( element, data.oldDescriptor, data.writer );\n\t\t}\n\n\t\tif ( data.newDescriptor ) {\n\t\t\tadd( element, data.newDescriptor, data.writer );\n\t\t}\n\t} );\n\n\twriter.setCustomProperty( 'addHighlight', ( element, descriptor, writer ) => stack.add( descriptor, writer ), element );\n\twriter.setCustomProperty( 'removeHighlight', ( element, id, writer ) => stack.remove( id, writer ), element );\n}\n\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/writer~Writer} writer\n */\nexport function setLabel( element, labelOrCreator, writer ) {\n\twriter.setCustomProperty( labelSymbol, labelOrCreator, element );\n}\n\n/**\n * Returns label for provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\nexport function getLabel( element ) {\n\tconst labelCreator = element.getCustomProperty( labelSymbol );\n\n\tif ( !labelCreator ) {\n\t\treturn '';\n\t}\n\n\treturn typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n\n/**\n * Adds functionality to provided {module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n * * adds `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * sets `contenteditable` as `true` when {module:engine/view/editableelement~EditableElement#isReadOnly} is `false`\n * otherwise set `false`,\n * * adds `ck-editor__nested-editable_focused` CSS class when editable is focused and removes it when it's blurred.\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/writer~Writer} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns same element that was provided in `editable` param.\n */\nexport function toWidgetEditable( editable, writer ) {\n\twriter.addClass( [ 'ck-editor__editable', 'ck-editor__nested-editable' ], editable );\n\n\t// The selection on Edge behaves better when the whole editor contents is in a single contentedible element.\n\t// https://github.com/ckeditor/ckeditor5/issues/1079\n\tif ( !env.isEdge ) {\n\t\t// Set initial contenteditable value.\n\t\twriter.setAttribute( 'contenteditable', editable.isReadOnly ? 'false' : 'true', editable );\n\n\t\t// Bind the contenteditable property to element#isReadOnly.\n\t\teditable.on( 'change:isReadOnly', ( evt, property, is ) => {\n\t\t\twriter.setAttribute( 'contenteditable', is ? 'false' : 'true', editable );\n\t\t} );\n\t}\n\n\teditable.on( 'change:isFocused', ( evt, property, is ) => {\n\t\tif ( is ) {\n\t\t\twriter.addClass( 'ck-editor__nested-editable_focused', editable );\n\t\t} else {\n\t\t\twriter.removeClass( 'ck-editor__nested-editable_focused', editable );\n\t\t}\n\t} );\n\n\treturn editable;\n}\n\n// Default filler offset function applied to all widget elements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Adds a drag handler to the editable element.\n//\n// @param {module:engine/view/editableelement~EditableElement}\n// @param {module:engine/view/writer~Writer} writer\nfunction addSelectionHandler( editable, writer ) {\n\tconst selectionHandler = writer.createUIElement( 'div', { class: 'ck ck-widget__selection-handler' }, function( domDocument ) {\n\t\tconst domElement = this.toDomElement( domDocument );\n\n\t\t// Use the IconView from the ui library.\n\t\tconst icon = new IconView();\n\t\ticon.set( 'content', dragHandlerIcon );\n\n\t\t// Render the icon view right away to append its #element to the selectionHandler DOM element.\n\t\ticon.render();\n\n\t\tdomElement.appendChild( icon.element );\n\n\t\treturn domElement;\n\t} );\n\n\t// Append the selection handler into the widget wrapper.\n\twriter.insert( Position.createAt( editable ), selectionHandler );\n\twriter.addClass( [ 'ck-widget_selectable' ], editable );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/image/utils\n */\n\nimport { toWidget, isWidget } from '@ckeditor/ckeditor5-widget/src/utils';\nimport ModelElement from '@ckeditor/ckeditor5-engine/src/model/element';\n\nconst imageSymbol = Symbol( 'isImage' );\n\n/**\n * Converts a given {@link module:engine/view/element~Element} to an image widget:\n * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget element.\n * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @param {module:engine/view/writer~Writer} writer An instance of the view writer.\n * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.\n * @returns {module:engine/view/element~Element}\n */\nexport function toImageWidget( viewElement, writer, label ) {\n\twriter.setCustomProperty( imageSymbol, true, viewElement );\n\n\treturn toWidget( viewElement, writer, { label: labelCreator } );\n\n\tfunction labelCreator() {\n\t\tconst imgElement = viewElement.getChild( 0 );\n\t\tconst altText = imgElement.getAttribute( 'alt' );\n\n\t\treturn altText ? `${ altText } ${ label }` : label;\n\t}\n}\n\n/**\n * Checks if a given view element is an image widget.\n *\n * @param {module:engine/view/element~Element} viewElement\n * @returns {Boolean}\n */\nexport function isImageWidget( viewElement ) {\n\treturn !!viewElement.getCustomProperty( imageSymbol ) && isWidget( viewElement );\n}\n\n/**\n * Checks if an image widget is the only selected element.\n *\n * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection\n * @returns {Boolean}\n */\nexport function isImageWidgetSelected( selection ) {\n\tconst viewElement = selection.getSelectedElement();\n\n\treturn !!( viewElement && isImageWidget( viewElement ) );\n}\n\n/**\n * Checks if the provided model element is an instance of {@link module:engine/model/element~Element Element} and its name\n * is `image`.\n *\n * @param {module:engine/model/element~Element} modelElement\n * @returns {Boolean}\n */\nexport function isImage( modelElement ) {\n\treturn modelElement instanceof ModelElement && modelElement.name == 'image';\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module image/image/imageediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageLoadObserver from './imageloadobserver';\nimport {\n    viewFigureToModel,\n    modelToViewAttributeConverter,\n    srcsetAttributeConverter\n} from './converters';\nimport { toImageWidget } from './utils';\nimport { downcastElementToElement } from '@ckeditor/ckeditor5-engine/src/conversion/downcast-converters';\nimport {\n    upcastElementToElement,\n    upcastAttributeToAttribute\n} from '@ckeditor/ckeditor5-engine/src/conversion/upcast-converters';\nimport ViewPosition from '@ckeditor/ckeditor5-engine/src/view/position';\n/**\n * The image engine plugin.\n * It registers `<image>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * It also egisters converters for editing and data pipelines.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageEditing extends Plugin {\n    /**\n\t * @inheritDoc\n\t */\n    init() {\n        const editor = this.editor;\n        const schema = editor.model.schema;\n        const t = editor.t;\n        const conversion = editor.conversion;\n        // See https://github.com/ckeditor/ckeditor5-image/issues/142.\n        editor.editing.view.addObserver(ImageLoadObserver);\n        // Configure schema.\n        schema.register('image', {\n            isObject: true,\n            isBlock: true,\n            allowWhere: '$block',\n            allowAttributes: [\n                'alt',\n                'src',\n                'srcset'\n            ]\n        });\n        conversion.for('dataDowncast').add(downcastElementToElement({\n            model: 'image',\n            view: (modelElement, viewWriter) => createImageViewElement(viewWriter)\n        }));\n        conversion.for('editingDowncast').add(downcastElementToElement({\n            model: 'image',\n            view: (modelElement, viewWriter) => toImageWidget(createImageViewElement(viewWriter), viewWriter, t('image widget'))\n        }));\n        conversion.for('downcast').add(modelToViewAttributeConverter('src')).add(modelToViewAttributeConverter('alt')).add(srcsetAttributeConverter());\n        conversion.for('upcast').add(upcastElementToElement({\n            view: {\n                name: 'img',\n                attributes: { src: true }\n            },\n            model: (viewImage, modelWriter) => modelWriter.createElement('image', { src: viewImage.getAttribute('src') })\n        })).add(upcastAttributeToAttribute({\n            view: {\n                name: 'img',\n                key: 'alt'\n            },\n            model: 'alt'\n        })).add(upcastAttributeToAttribute({\n            view: {\n                name: 'img',\n                key: 'srcset'\n            },\n            model: {\n                key: 'srcset',\n                value: viewImage => {\n                    const value = { data: viewImage.getAttribute('srcset') };\n                    if (viewImage.hasAttribute('width')) {\n                        value.width = viewImage.getAttribute('width');\n                    }\n                    return value;\n                }\n            }\n        })).add(viewFigureToModel());\n    }\n}\n// Creates a view element representing the image.\n//\n//\t\t<figure class=\"image\"><img></img></figure>\n//\n// Note that `alt` and `src` attributes are converted separately, so they are not included.\n//\n// @private\n// @param {module:engine/view/writer~Writer} writer\n// @returns {module:engine/view/containerelement~ContainerElement}\nexport function createImageViewElement(writer) {\n    const emptyElement = writer.createEmptyElement('img');\n    const figure = writer.createContainerElement('figure', { class: 'image' });\n    writer.insert(ViewPosition.createAt(figure), emptyElement);\n    return figure;\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module engine/view/observer/mouseobserver\n */\n\nimport DomEventObserver from './domeventobserver';\n\n/**\n * Mouse events observer.\n *\n * Note that this observer is not available by default. To make it available it needs to be added to\n * {@link module:engine/view/view~View} by {@link module:engine/view/view~View#addObserver} method.\n *\n * @extends module:engine/view/observer/domeventobserver~DomEventObserver\n */\nexport default class MouseObserver extends DomEventObserver {\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\tthis.domEventType = 'mousedown';\n\t}\n\n\tonDomEvent( domEvent ) {\n\t\tthis.fire( domEvent.type, domEvent );\n\t}\n}\n\n/**\n * Fired when mouse button is pressed down on one of the editables.\n *\n * Introduced by {@link module:engine/view/observer/mouseobserver~MouseObserver}.\n *\n * Note that this event is not available by default. To make it available {@link module:engine/view/observer/mouseobserver~MouseObserver}\n * needs to be added to {@link module:engine/view/view~View} by a {@link module:engine/view/view~View#addObserver} method.\n *\n * @see module:engine/view/observer/mouseobserver~MouseObserver\n * @event module:engine/view/document~Document#event:mousedown\n * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module widget/widget\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport ModelRange from '@ckeditor/ckeditor5-engine/src/model/range';\nimport ModelSelection from '@ckeditor/ckeditor5-engine/src/model/selection';\nimport ModelElement from '@ckeditor/ckeditor5-engine/src/model/element';\nimport ViewEditableElement from '@ckeditor/ckeditor5-engine/src/view/editableelement';\nimport RootEditableElement from '@ckeditor/ckeditor5-engine/src/view/rooteditableelement';\nimport { isWidget, WIDGET_SELECTED_CLASS_NAME, getLabel } from './utils';\nimport { keyCodes, getCode, parseKeystroke } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport '../theme/widget.css';\n\nconst selectAllKeystrokeCode = parseKeystroke( 'Ctrl+A' );\n\n/**\n * The widget plugin.\n * Registers model to view selection converter for editing pipeline. It is hooked after default selection conversion.\n * If converted selection is placed around widget element, selection is marked as fake. Additionally, proper CSS class\n * is added to indicate that widget has been selected.\n * Adds default {@link module:engine/view/document~Document#event:mousedown mousedown} handling on widget elements.\n *\n * @extends module:core/plugin~Plugin.\n */\nexport default class Widget extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Widget';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst view = this.editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t/**\n\t\t * Holds previously selected widgets.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/view/element~Element>}\n\t\t */\n\t\tthis._previouslySelected = new Set();\n\n\t\t// Model to view selection converter.\n\t\t// Converts selection placed over widget element to fake selection\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\t// Remove selected class from previously selected widgets.\n\t\t\tthis._clearPreviouslySelectedWidgets( conversionApi.writer );\n\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst viewSelection = viewWriter.document.selection;\n\t\t\tconst selectedElement = viewSelection.getSelectedElement();\n\n\t\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tconst node = value.item;\n\n\t\t\t\t\tif ( node.is( 'element' ) && isWidget( node ) ) {\n\t\t\t\t\t\tviewWriter.addClass( WIDGET_SELECTED_CLASS_NAME, node );\n\t\t\t\t\t\tthis._previouslySelected.add( node );\n\n\t\t\t\t\t\t// Check if widget is a single element selected.\n\t\t\t\t\t\tif ( node == selectedElement ) {\n\t\t\t\t\t\t\tviewWriter.setSelection( viewSelection.getRanges(), { fake: true, label: getLabel( selectedElement ) } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// If mouse down is pressed on widget - create selection over whole widget.\n\t\tview.addObserver( MouseObserver );\n\t\tthis.listenTo( viewDocument, 'mousedown', ( ...args ) => this._onMousedown( ...args ) );\n\n\t\t// Handle custom keydown behaviour.\n\t\tthis.listenTo( viewDocument, 'keydown', ( ...args ) => this._onKeydown( ...args ), { priority: 'high' } );\n\n\t\t// Handle custom delete behaviour.\n\t\tthis.listenTo( viewDocument, 'delete', ( evt, data ) => {\n\t\t\tif ( this._handleDelete( data.direction == 'forward' ) ) {\n\t\t\t\tdata.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onMousedown( eventInfo, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\t\tlet element = domEventData.target;\n\n\t\t// Do nothing if inside nested editable.\n\t\tif ( isInsideNestedEditable( element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If target is not a widget element - check if one of the ancestors is.\n\t\tif ( !isWidget( element ) ) {\n\t\t\telement = element.findAncestor( isWidget );\n\n\t\t\tif ( !element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tdomEventData.preventDefault();\n\n\t\t// Focus editor if is not focused already.\n\t\tif ( !viewDocument.isFocused ) {\n\t\t\tview.focus();\n\t\t}\n\n\t\t// Create model selection over widget.\n\t\tconst modelElement = editor.editing.mapper.toModelElement( element );\n\n\t\tthis._setSelectionOverElement( modelElement );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onKeydown( eventInfo, domEventData ) {\n\t\tconst keyCode = domEventData.keyCode;\n\t\tconst isForward = keyCode == keyCodes.delete || keyCode == keyCodes.arrowdown || keyCode == keyCodes.arrowright;\n\t\tlet wasHandled = false;\n\n\t\t// Checks if the keys were handled and then prevents the default event behaviour and stops\n\t\t// the propagation.\n\t\tif ( isArrowKeyCode( keyCode ) ) {\n\t\t\twasHandled = this._handleArrowKeys( isForward );\n\t\t} else if ( isSelectAllKeyCode( domEventData ) ) {\n\t\t\twasHandled = this._selectAllNestedEditableContent() || this._selectAllContent();\n\t\t} else if ( keyCode === keyCodes.enter ) {\n\t\t\twasHandled = this._handleEnterKey( domEventData.shiftKey );\n\t\t}\n\n\t\tif ( wasHandled ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles delete keys: backspace and delete.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleDelete( isForward ) {\n\t\t// Do nothing when the read only mode is enabled.\n\t\tif ( this.editor.isReadOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelDocument = this.editor.model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\n\t\t// Do nothing on non-collapsed selection.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElement ) {\n\t\t\tthis.editor.model.change( writer => {\n\t\t\t\tlet previousNode = modelSelection.anchor.parent;\n\n\t\t\t\t// Remove previous element if empty.\n\t\t\t\twhile ( previousNode.isEmpty ) {\n\t\t\t\t\tconst nodeToRemove = previousNode;\n\t\t\t\t\tpreviousNode = nodeToRemove.parent;\n\n\t\t\t\t\twriter.remove( nodeToRemove );\n\t\t\t\t}\n\n\t\t\t\tthis._setSelectionOverElement( objectElement );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles arrow keys.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if arrow key should be handled in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleArrowKeys( isForward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelDocument = model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\t\tconst objectElement = modelSelection.getSelectedElement();\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tconst position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n\t\t\tconst newRange = schema.getNearestSelectionRange( position, isForward ? 'forward' : 'backward' );\n\n\t\t\tif ( newRange ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( newRange );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// If selection is next to object element.\n\t\t// Return if not collapsed.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement2 = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElement2 instanceof ModelElement && schema.isObject( objectElement2 ) ) {\n\t\t\tthis._setSelectionOverElement( objectElement2 );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the enter key, giving users and access to positions in the editable directly before\n\t * (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or after (<kbd>Enter</kbd>) the selected widget.\n\t * It improves the UX, mainly when the widget is the first or last child of the root editable\n\t * and there's no other way to type after or before it.\n\t *\n\t * @private\n\t * @param {Boolean} isBackwards Set to true if the new paragraph is to be inserted before\n\t * the selected widget (<kbd>Shift</kbd>+<kbd>Enter</kbd>).\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleEnterKey( isBackwards ) {\n\t\tconst model = this.editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst objectElement = modelSelection.getSelectedElement();\n\n\t\tif ( objectElement && model.schema.isObject( objectElement ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n\n\t\t\t\twriter.insert( paragraph, objectElement, isBackwards ? 'before' : 'after' );\n\t\t\t\twriter.setSelection( paragraph, 'in' );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Extends the {@link module:engine/model/selection~Selection document's selection} to span the entire\n\t * content of the nested editable if already anchored in one.\n\t *\n\t * See: {@link module:engine/model/schema~Schema#getLimitElement}.\n\t *\n\t * @private\n\t */\n\t_selectAllNestedEditableContent() {\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\t\tconst limitElement = model.schema.getLimitElement( documentSelection );\n\n\t\tif ( documentSelection.getFirstRange().root == limitElement ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\twriter.setSelection( ModelRange.createIn( limitElement ) );\n\t\t} );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Handles <kbd>CTRL + A</kbd> when widget is selected.\n\t *\n\t * @private\n\t * @returns {Boolean} Returns true if widget was selected and selecting all was handled by this method.\n\t */\n\t_selectAllContent() {\n\t\tconst model = this.editor.model;\n\t\tconst editing = this.editor.editing;\n\t\tconst view = editing.view;\n\t\tconst viewDocument = view.document;\n\t\tconst viewSelection = viewDocument.selection;\n\n\t\tconst selectedElement = viewSelection.getSelectedElement();\n\n\t\t// Only widget is selected.\n\t\t// https://github.com/ckeditor/ckeditor5-widget/issues/23\n\t\tif ( selectedElement && isWidget( selectedElement ) ) {\n\t\t\tconst widgetParent = editing.mapper.toModelElement( selectedElement.parent );\n\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( ModelRange.createIn( widgetParent ) );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_setSelectionOverElement( element ) {\n\t\tthis.editor.model.change( writer => {\n\t\t\twriter.setSelection( ModelRange.createOn( element ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks if {@link module:engine/model/element~Element element} placed next to the current\n\t * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n\t * {@link module:engine/model/schema~Schema schema} as `object`.\n\t *\n\t * @private\n\t * @param {Boolean} forward Direction of checking.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getObjectElementNextToSelection( forward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\n\t\t// Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n\t\t// to its current state after undo.\n\t\tconst probe = new ModelSelection( modelSelection );\n\t\tmodel.modifySelection( probe, { direction: forward ? 'forward' : 'backward' } );\n\t\tconst objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n\t\tif ( objectElement instanceof ModelElement && schema.isObject( objectElement ) ) {\n\t\t\treturn objectElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes CSS class from previously selected widgets.\n\t *\n\t * @private\n\t * @param {module:engine/view/writer~Writer} writer\n\t */\n\t_clearPreviouslySelectedWidgets( writer ) {\n\t\tfor ( const widget of this._previouslySelected ) {\n\t\t\twriter.removeClass( WIDGET_SELECTED_CLASS_NAME, widget );\n\t\t}\n\n\t\tthis._previouslySelected.clear();\n\t}\n}\n\n// Returns 'true' if provided key code represents one of the arrow keys.\n//\n// @param {Number} keyCode\n// @returns {Boolean}\nfunction isArrowKeyCode( keyCode ) {\n\treturn keyCode == keyCodes.arrowright ||\n\t\tkeyCode == keyCodes.arrowleft ||\n\t\tkeyCode == keyCodes.arrowup ||\n\t\tkeyCode == keyCodes.arrowdown;\n}\n\n// Returns 'true' if provided (DOM) key event data corresponds with the Ctrl+A keystroke.\n//\n// @param {module:engine/view/observer/keyobserver~KeyEventData} domEventData\n// @returns {Boolean}\nfunction isSelectAllKeyCode( domEventData ) {\n\treturn getCode( domEventData ) == selectAllKeystrokeCode;\n}\n\n// Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\nfunction isInsideNestedEditable( element ) {\n\twhile ( element ) {\n\t\tif ( element instanceof ViewEditableElement && !( element instanceof RootEditableElement ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\telement = element.parent;\n\t}\n\n\treturn false;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/imagetextalternative/imagetextalternativecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { isImage } from '../image/utils';\n\n/**\n * The image text alternative command. It is used to change the `alt` attribute of `<image>` elements.\n *\n * @extends module:core/command~Command\n */\nexport default class ImageTextAlternativeCommand extends Command {\n\t/**\n\t * The command value: `false` if there is no `alt` attribute, otherwise the value of the `alt` attribute.\n\t *\n\t * @readonly\n\t * @observable\n\t * @member {String|Boolean} #value\n\t */\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst element = this.editor.model.document.selection.getSelectedElement();\n\n\t\tthis.isEnabled = isImage( element );\n\n\t\tif ( isImage( element ) && element.hasAttribute( 'alt' ) ) {\n\t\t\tthis.value = element.getAttribute( 'alt' );\n\t\t} else {\n\t\t\tthis.value = false;\n\t\t}\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * @fires execute\n\t * @param {Object} options\n\t * @param {String} options.newValue The new value of the `alt` attribute to set.\n\t */\n\texecute( options ) {\n\t\tconst model = this.editor.model;\n\t\tconst imageElement = model.document.selection.getSelectedElement();\n\n\t\tmodel.change( writer => {\n\t\t\twriter.setAttribute( 'alt', options.newValue, imageElement );\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/imagetextalternative/imagetextalternativeediting\n */\n\nimport ImageTextAlternativeCommand from './imagetextalternativecommand';\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\n/**\n * The image text alternative engine plugin.\n * Registers the `imageTextAlternative` command.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageTextAlternativeEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tthis.editor.commands.add( 'imageTextAlternative', new ImageTextAlternativeCommand( this.editor ) );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/tooltip/tooltipview\n */\n\nimport View from '../view';\n\nimport '../../theme/components/tooltip/tooltip.css';\n\n/**\n * The tooltip view class.\n *\n * @extends module:ui/view~View\n */\nexport default class TooltipView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * The text of the tooltip visible to the user.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #text\n\t\t */\n\t\tthis.set( 'text', '' );\n\n\t\t/**\n\t\t * The position of the tooltip (south or north).\n\t\t *\n\t\t *\t\t+-----------+\n\t\t *\t\t|   north   |\n\t\t *\t\t+-----------+\n\t\t *\t\t      V\n\t\t *\t\t  [element]\n\t\t *\n\t\t *\t\t  [element]\n\t\t *\t\t      ^\n\t\t *\t\t+-----------+\n\t\t *\t\t|   south   |\n\t\t *\t\t+-----------+\n\t\t *\n\t\t * @observable\n\t\t * @default 's'\n\t\t * @member {'s'|'n'} #position\n\t\t */\n\t\tthis.set( 'position', 's' );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'span',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-tooltip',\n\t\t\t\t\tbind.to( 'position', position => 'ck-tooltip_' + position ),\n\t\t\t\t\tbind.if( 'text', 'ck-hidden', value => !value.trim() )\n\t\t\t\t]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\t{\n\t\t\t\t\ttag: 'span',\n\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\tclass: [\n\t\t\t\t\t\t\t'ck',\n\t\t\t\t\t\t\t'ck-tooltip__text'\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\n\t\t\t\t\tchildren: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttext: bind.to( 'text' ),\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/button/buttonview\n */\n\nimport View from '../view';\nimport IconView from '../icon/iconview';\nimport TooltipView from '../tooltip/tooltipview';\n\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nimport { getEnvKeystrokeText } from '@ckeditor/ckeditor5-utils/src/keyboard';\n\nimport '../../theme/components/button/button.css';\n\n/**\n * The button view class.\n *\n *\t\tconst view = new ButtonView();\n *\n *\t\tview.set( {\n *\t\t\tlabel: 'A button',\n *\t\t\tkeystroke: 'Ctrl+B',\n *\t\t\ttooltip: true,\n *\t\t\twithText: true\n *\t\t} );\n *\n *\t\tview.render();\n *\n *\t\tdocument.body.append( view.element );\n *\n * @extends module:ui/view~View\n * @implements module:ui/button/button~Button\n */\nexport default class ButtonView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\tconst bind = this.bindTemplate;\n\t\tconst ariaLabelUid = uid();\n\n\t\t// Implement the Button interface.\n\t\tthis.set( 'class' );\n\t\tthis.set( 'labelStyle' );\n\t\tthis.set( 'icon' );\n\t\tthis.set( 'isEnabled', true );\n\t\tthis.set( 'isOn', false );\n\t\tthis.set( 'isVisible', true );\n\t\tthis.set( 'keystroke' );\n\t\tthis.set( 'label' );\n\t\tthis.set( 'tabindex', -1 );\n\t\tthis.set( 'tooltip' );\n\t\tthis.set( 'tooltipPosition', 's' );\n\t\tthis.set( 'type', 'button' );\n\t\tthis.set( 'withText', false );\n\n\t\t/**\n\t\t * Collection of the child views inside of the button {@link #element}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n\t\tthis.children = this.createCollection();\n\n\t\t/**\n\t\t * Tooltip of the button view. It is configurable using the {@link #tooltip tooltip attribute}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/tooltip/tooltipview~TooltipView} #tooltipView\n\t\t */\n\t\tthis.tooltipView = this._createTooltipView();\n\n\t\t/**\n\t\t * Label of the button view. It is configurable using the {@link #label label attribute}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/view~View} #labelView\n\t\t */\n\t\tthis.labelView = this._createLabelView( ariaLabelUid );\n\n\t\t/**\n\t\t * The icon view of the button. Will be added to {@link #children} when the\n\t\t * {@link #icon icon attribute} is defined.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/icon/iconview~IconView} #iconView\n\t\t */\n\t\tthis.iconView = new IconView();\n\n\t\tthis.iconView.extendTemplate( {\n\t\t\tattributes: {\n\t\t\t\tclass: 'ck-button__icon'\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * Tooltip of the button bound to the template.\n\t\t *\n\t\t * @see #tooltip\n\t\t * @see #_getTooltipString\n\t\t * @private\n\t\t * @observable\n\t\t * @member {Boolean} #_tooltipString\n\t\t */\n\t\tthis.bind( '_tooltipString' ).to(\n\t\t\tthis, 'tooltip',\n\t\t\tthis, 'label',\n\t\t\tthis, 'keystroke',\n\t\t\tthis._getTooltipString.bind( this )\n\t\t);\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'button',\n\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-button',\n\t\t\t\t\tbind.to( 'class' ),\n\t\t\t\t\tbind.if( 'isEnabled', 'ck-disabled', value => !value ),\n\t\t\t\t\tbind.if( 'isVisible', 'ck-hidden', value => !value ),\n\t\t\t\t\tbind.to( 'isOn', value => value ? 'ck-on' : 'ck-off' ),\n\t\t\t\t\tbind.if( 'withText', 'ck-button_with-text' )\n\t\t\t\t],\n\t\t\t\ttype: bind.to( 'type', value => value ? value : 'button' ),\n\t\t\t\ttabindex: bind.to( 'tabindex' ),\n\t\t\t\t'aria-labelledby': `ck-editor__aria-label_${ ariaLabelUid }`,\n\t\t\t\t'aria-disabled': bind.if( 'isEnabled', true, value => !value ),\n\t\t\t\t'aria-pressed': bind.if( 'isOn', true )\n\t\t\t},\n\n\t\t\tchildren: this.children,\n\n\t\t\ton: {\n\t\t\t\tmousedown: bind.to( evt => {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t} ),\n\n\t\t\t\tclick: bind.to( evt => {\n\t\t\t\t\t// We can't make the button disabled using the disabled attribute, because it won't be focusable.\n\t\t\t\t\t// Though, shouldn't this condition be moved to the button controller?\n\t\t\t\t\tif ( this.isEnabled ) {\n\t\t\t\t\t\tthis.fire( 'execute' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Prevent the default when button is disabled, to block e.g.\n\t\t\t\t\t\t// automatic form submitting. See ckeditor/ckeditor5-link#74.\n\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t} )\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\tif ( this.icon ) {\n\t\t\tthis.iconView.bind( 'content' ).to( this, 'icon' );\n\t\t\tthis.children.add( this.iconView );\n\t\t}\n\n\t\tthis.children.add( this.tooltipView );\n\t\tthis.children.add( this.labelView );\n\t}\n\n\t/**\n\t * Focuses the {@link #element} of the button.\n\t */\n\tfocus() {\n\t\tthis.element.focus();\n\t}\n\n\t/**\n\t * Creates a {@link module:ui/tooltip/tooltipview~TooltipView} instance and binds it with button\n\t * attributes.\n\t *\n\t * @private\n\t * @returns {module:ui/tooltip/tooltipview~TooltipView}\n\t */\n\t_createTooltipView() {\n\t\tconst tooltipView = new TooltipView();\n\n\t\ttooltipView.bind( 'text' ).to( this, '_tooltipString' );\n\t\ttooltipView.bind( 'position' ).to( this, 'tooltipPosition' );\n\n\t\treturn tooltipView;\n\t}\n\n\t/**\n\t * Creates a label view instance and binds it with button attributes.\n\t *\n\t * @private\n\t * @param {String} ariaLabelUid The aria label UID.\n\t * @returns {module:ui/view~View}\n\t */\n\t_createLabelView( ariaLabelUid ) {\n\t\tconst labelView = new View();\n\t\tconst bind = this.bindTemplate;\n\n\t\tlabelView.setTemplate( {\n\t\t\ttag: 'span',\n\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-button__label'\n\t\t\t\t],\n\t\t\t\tstyle: bind.to( 'labelStyle' ),\n\t\t\t\tid: `ck-editor__aria-label_${ ariaLabelUid }`,\n\t\t\t},\n\n\t\t\tchildren: [\n\t\t\t\t{\n\t\t\t\t\ttext: this.bindTemplate.to( 'label' )\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\n\t\treturn labelView;\n\t}\n\n\t/**\n\t * Gets the text for the {@link #tooltipView} from the combination of\n\t * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.\n\t *\n\t * @private\n\t * @see #tooltip\n\t * @see #_tooltipString\n\t * @param {Boolean|String|Function} tooltip Button tooltip.\n\t * @param {String} label Button label.\n\t * @param {String} keystroke Button keystroke.\n\t * @returns {String}\n\t */\n\t_getTooltipString( tooltip, label, keystroke ) {\n\t\tif ( tooltip ) {\n\t\t\tif ( typeof tooltip == 'string' ) {\n\t\t\t\treturn tooltip;\n\t\t\t} else {\n\t\t\t\tif ( keystroke ) {\n\t\t\t\t\tkeystroke = getEnvKeystrokeText( keystroke );\n\t\t\t\t}\n\n\t\t\t\tif ( tooltip instanceof Function ) {\n\t\t\t\t\treturn tooltip( label, keystroke );\n\t\t\t\t} else {\n\t\t\t\t\treturn `${ label }${ keystroke ? ` (${ keystroke })` : '' }`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/label/labelview\n */\n\nimport View from '../view';\n\nimport '../../theme/components/label/label.css';\n\n/**\n * The label view class.\n *\n * @extends module:ui/view~View\n */\nexport default class LabelView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * The text of the label.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #text\n\t\t */\n\t\tthis.set( 'text' );\n\n\t\t/**\n\t\t * The `for` attribute of the label (i.e. to pair with an `<input>` element).\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #for\n\t\t */\n\t\tthis.set( 'for' );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'label',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-label'\n\t\t\t\t],\n\t\t\t\tfor: bind.to( 'for' )\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\t{\n\t\t\t\t\ttext: bind.to( 'text' )\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/labeledinput/labeledinputview\n */\n\nimport View from '../view';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nimport LabelView from '../label/labelview';\n\n/**\n * The labeled input view class.\n *\n * @extends module:ui/view~View\n */\nexport default class LabeledInputView extends View {\n\t/**\n\t * Creates an instance of the labeled input view class.\n\t *\n\t * @param {module:utils/locale~Locale} locale The locale instance.\n\t * @param {Function} InputView Constructor of the input view.\n\t */\n\tconstructor( locale, InputView ) {\n\t\tsuper( locale );\n\n\t\tconst id = `ck-input-${ uid() }`;\n\n\t\t/**\n\t\t * The text of the label.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #label\n\t\t */\n\t\tthis.set( 'label' );\n\n\t\t/**\n\t\t * The value of the input.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #value\n\t\t */\n\t\tthis.set( 'value' );\n\n\t\t/**\n\t\t * Controls whether the component is in read-only mode.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\t/**\n\t\t * The label view.\n\t\t *\n\t\t * @member {module:ui/label/labelview~LabelView} #labelView\n\t\t */\n\t\tthis.labelView = this._createLabelView( id );\n\n\t\t/**\n\t\t * The input view.\n\t\t *\n\t\t * @member {module:ui/view~View} #inputView\n\t\t */\n\t\tthis.inputView = this._createInputView( InputView, id );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-labeled-input',\n\t\t\t\t\tbind.if( 'isReadOnly', 'ck-disabled' )\n\t\t\t\t]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\tthis.labelView,\n\t\t\t\tthis.inputView\n\t\t\t]\n\t\t} );\n\t}\n\n\t/**\n\t * Creates label view class instance and bind with view.\n\t *\n\t * @private\n\t * @param {String} id Unique id to set as labelView#for attribute.\n\t * @returns {module:ui/label/labelview~LabelView}\n\t */\n\t_createLabelView( id ) {\n\t\tconst labelView = new LabelView( this.locale );\n\n\t\tlabelView.for = id;\n\t\tlabelView.bind( 'text' ).to( this, 'label' );\n\n\t\treturn labelView;\n\t}\n\n\t/**\n\t * Creates input view class instance and bind with view.\n\t *\n\t * @private\n\t * @param {Function} InputView Input view constructor.\n\t * @param {String} id Unique id to set as inputView#id attribute.\n\t * @returns {module:ui/inputtext/inputtextview~InputTextView}\n\t */\n\t_createInputView( InputView, id ) {\n\t\tconst inputView = new InputView( this.locale );\n\n\t\tinputView.id = id;\n\t\tinputView.bind( 'value' ).to( this );\n\t\tinputView.bind( 'isReadOnly' ).to( this );\n\n\t\treturn inputView;\n\t}\n\n\t/**\n\t * Moves the focus to the input and selects the value.\n\t */\n\tselect() {\n\t\tthis.inputView.select();\n\t}\n\n\t/**\n\t * Focuses the input.\n\t */\n\tfocus() {\n\t\tthis.inputView.focus();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/inputtext/inputtextview\n */\n\nimport View from '../view';\n\nimport '../../theme/components/inputtext/inputtext.css';\n\n/**\n * The text input view class.\n *\n * @extends module:ui/view~View\n */\nexport default class InputTextView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * The value of the input.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #value\n\t\t */\n\t\tthis.set( 'value' );\n\n\t\t/**\n\t\t * The `id` attribute of the input (i.e. to pair with a `<label>` element).\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #id\n\t\t */\n\t\tthis.set( 'id' );\n\n\t\t/**\n\t\t * The `placeholder` attribute of the input.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #placeholder\n\t\t */\n\t\tthis.set( 'placeholder' );\n\n\t\t/**\n\t\t * Controls whether the input view is in read-only mode.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #isReadOnly\n\t\t */\n\t\tthis.set( 'isReadOnly', false );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'input',\n\t\t\tattributes: {\n\t\t\t\ttype: 'text',\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-input',\n\t\t\t\t\t'ck-input-text'\n\t\t\t\t],\n\t\t\t\tid: bind.to( 'id' ),\n\t\t\t\tplaceholder: bind.to( 'placeholder' ),\n\t\t\t\treadonly: bind.to( 'isReadOnly' )\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trender() {\n\t\tsuper.render();\n\n\t\tconst setValue = value => {\n\t\t\tthis.element.value = ( !value && value !== 0 ) ? '' : value;\n\t\t};\n\n\t\tsetValue( this.value );\n\n\t\t// Bind `this.value` to the DOM element's value.\n\t\t// We cannot use `value` DOM attribute because removing it on Edge does not clear the DOM element's value property.\n\t\tthis.on( 'change:value', ( evt, name, value ) => {\n\t\t\tsetValue( value );\n\t\t} );\n\t}\n\n\t/**\n\t * Moves the focus to the input and selects the value.\n\t */\n\tselect() {\n\t\tthis.element.select();\n\t}\n\n\t/**\n\t * Focuses the input.\n\t */\n\tfocus() {\n\t\tthis.element.focus();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/focuscycler\n */\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\n\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n */\nexport default class FocusCycler {\n\t/**\n\t * Creates an instance of the focus cycler utility.\n\t *\n\t * @param {Object} options Configuration options.\n\t * @param {module:utils/collection~Collection|Object} options.focusables\n\t * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n\t * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n\t * @param {Object} [options.actions]\n\t */\n\tconstructor( options ) {\n\t\tObject.assign( this, options );\n\n\t\t/**\n\t\t * A {@link module:ui/view~View view} collection that the cycler operates on.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/collection~Collection} #focusables\n\t\t */\n\n\t\t/**\n\t\t * A focus tracker instance that the cycler uses to determine the current focus\n\t\t * state in {@link #focusables}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/focustracker~FocusTracker} #focusTracker\n\t\t */\n\n\t\t/**\n\t\t * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n\t\t * which can respond to certain keystrokes and cycle the focus.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n\t\t */\n\n\t\t/**\n\t\t * Actions that the cycler can take when a keystroke is pressed. Requires\n\t\t * `options.keystrokeHandler` to be passed and working. When an action is\n\t\t * performed, `preventDefault` and `stopPropagation` will be called on the event\n\t\t * the keystroke fired in the DOM.\n\t\t *\n\t\t *\t\tactions: {\n\t\t *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n\t\t *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n\t\t *\n\t\t *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n\t\t *\t\t\tfocusNext: 'arrowdown'\n\t\t *\t\t}\n\t\t *\n\t\t * @readonly\n\t\t * @member {Object} #actions\n\t\t */\n\n\t\tif ( options.actions && options.keystrokeHandler ) {\n\t\t\tfor ( const methodName in options.actions ) {\n\t\t\t\tlet actions = options.actions[ methodName ];\n\n\t\t\t\tif ( typeof actions == 'string' ) {\n\t\t\t\t\tactions = [ actions ];\n\t\t\t\t}\n\n\t\t\t\tfor ( const keystroke of actions ) {\n\t\t\t\t\toptions.keystrokeHandler.set( keystroke, ( data, cancel ) => {\n\t\t\t\t\t\tthis[ methodName ]();\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the first focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #first\n\t */\n\tget first() {\n\t\treturn this.focusables.find( isFocusable ) || null;\n\t}\n\n\t/**\n\t * Returns the last focusable view in {@link #focusables}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #last\n\t */\n\tget last() {\n\t\treturn this.focusables.filter( isFocusable ).slice( -1 )[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #next\n\t */\n\tget next() {\n\t\treturn this._getFocusableItem( 1 );\n\t}\n\n\t/**\n\t * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n\t * Returns `null` if there is none.\n\t *\n\t * @readonly\n\t * @member {module:ui/view~View|null} #previous\n\t */\n\tget previous() {\n\t\treturn this._getFocusableItem( -1 );\n\t}\n\n\t/**\n\t * An index of the view in the {@link #focusables} which is focused according\n\t * to {@link #focusTracker}. Returns `null` when there is no such view.\n\t *\n\t * @readonly\n\t * @member {Number|null} #current\n\t */\n\tget current() {\n\t\tlet index = null;\n\n\t\t// There's no focused view in the focusables.\n\t\tif ( this.focusTracker.focusedElement === null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.focusables.find( ( view, viewIndex ) => {\n\t\t\tconst focused = view.element === this.focusTracker.focusedElement;\n\n\t\t\tif ( focused ) {\n\t\t\t\tindex = viewIndex;\n\t\t\t}\n\n\t\t\treturn focused;\n\t\t} );\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Focuses the {@link #first} item in {@link #focusables}.\n\t */\n\tfocusFirst() {\n\t\tthis._focus( this.first );\n\t}\n\n\t/**\n\t * Focuses the {@link #last} item in {@link #focusables}.\n\t */\n\tfocusLast() {\n\t\tthis._focus( this.last );\n\t}\n\n\t/**\n\t * Focuses the {@link #next} item in {@link #focusables}.\n\t */\n\tfocusNext() {\n\t\tthis._focus( this.next );\n\t}\n\n\t/**\n\t * Focuses the {@link #previous} item in {@link #focusables}.\n\t */\n\tfocusPrevious() {\n\t\tthis._focus( this.previous );\n\t}\n\n\t/**\n\t * Focuses the given view if it exists.\n\t *\n\t * @protected\n\t * @param {module:ui/view~View} view\n\t */\n\t_focus( view ) {\n\t\tif ( view ) {\n\t\t\tview.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the next or previous focusable view in {@link #focusables} with respect\n\t * to {@link #current}.\n\t *\n\t * @protected\n\t * @param {Number} step Either `1` for checking forward from {@link #current} or\n\t * `-1` for checking backwards.\n\t * @returns {module:ui/view~View|null}\n\t */\n\t_getFocusableItem( step ) {\n\t\t// Cache for speed.\n\t\tconst current = this.current;\n\t\tconst collectionLength = this.focusables.length;\n\n\t\tif ( !collectionLength ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Start from the beginning if no view is focused.\n\t\t// https://github.com/ckeditor/ckeditor5-ui/issues/206\n\t\tif ( current === null ) {\n\t\t\treturn this[ step === 1 ? 'first' : 'last' ];\n\t\t}\n\n\t\t// Cycle in both directions.\n\t\tlet index = ( current + collectionLength + step ) % collectionLength;\n\n\t\tdo {\n\t\t\tconst view = this.focusables.get( index );\n\n\t\t\t// TODO: Check if view is visible.\n\t\t\tif ( isFocusable( view ) ) {\n\t\t\t\treturn view;\n\t\t\t}\n\n\t\t\t// Cycle in both directions.\n\t\t\tindex = ( index + collectionLength + step ) % collectionLength;\n\t\t} while ( index !== current );\n\n\t\treturn null;\n\t}\n}\n\n// Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\nfunction isFocusable( view ) {\n\treturn !!( view.focus && global.window.getComputedStyle( view.element ).display != 'none' );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module image/imagetextalternative/ui/textalternativeformview\n */\nimport View from '@ckeditor/ckeditor5-ui/src/view';\nimport ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';\nimport ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';\nimport LabeledInputView from '@ckeditor/ckeditor5-ui/src/labeledinput/labeledinputview';\nimport InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';\nimport submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';\nimport KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';\nimport checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';\nimport cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';\nimport '../../../theme/textalternativeform.css';\n/**\n * The TextAlternativeFormView class.\n *\n * @extends module:ui/view~View\n */\nexport default class TextAlternativeFormView extends View {\n    /**\n\t * @inheritDoc\n\t */\n    constructor(locale) {\n        super(locale);\n        const t = this.locale.t;\n        /**\n\t\t * Tracks information about the DOM focus in the form.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/focustracker~FocusTracker}\n\t\t */\n        this.focusTracker = new FocusTracker();\n        /**\n\t\t * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:utils/keystrokehandler~KeystrokeHandler}\n\t\t */\n        this.keystrokes = new KeystrokeHandler();\n        /**\n\t\t * A textarea with a label.\n\t\t *\n\t\t * @member {module:ui/labeledinput/labeledinputview~LabeledInputView} #labeledTextarea\n\t\t */\n        this.labeledInput = this._createLabeledInputView();\n        /**\n\t\t * A button used to submit the form.\n\t\t *\n\t\t * @member {module:ui/button/buttonview~ButtonView} #saveButtonView\n\t\t */\n        this.saveButtonView = this._createButton(t('Save'), checkIcon, 'ck-button-save');\n        this.saveButtonView.type = 'submit';\n        /**\n\t\t * A button used to cancel the form.\n\t\t *\n\t\t * @member {module:ui/button/buttonview~ButtonView} #cancelButtonView\n\t\t */\n        this.cancelButtonView = this._createButton(t('Cancel'), cancelIcon, 'ck-button-cancel', 'cancel');\n        /**\n\t\t * A collection of views which can be focused in the form.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n        this._focusables = new ViewCollection();\n        /**\n\t\t * Helps cycling over {@link #_focusables} in the form.\n\t\t *\n\t\t * @readonly\n\t\t * @protected\n\t\t * @member {module:ui/focuscycler~FocusCycler}\n\t\t */\n        this._focusCycler = new FocusCycler({\n            focusables: this._focusables,\n            focusTracker: this.focusTracker,\n            keystrokeHandler: this.keystrokes,\n            actions: {\n                // Navigate form fields backwards using the Shift + Tab keystroke.\n                focusPrevious: 'shift + tab',\n                // Navigate form fields forwards using the Tab key.\n                focusNext: 'tab'\n            }\n        });\n        this.setTemplate({\n            tag: 'form',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-text-alternative-form'\n                ],\n                // https://github.com/ckeditor/ckeditor5-image/issues/40\n                tabindex: '-1'\n            },\n            children: [\n                this.labeledInput,\n                this.saveButtonView,\n                this.cancelButtonView\n            ]\n        });\n    }\n    /**\n\t * @inheritDoc\n\t */\n    render() {\n        super.render();\n        this.keystrokes.listenTo(this.element);\n        submitHandler({ view: this });\n        [\n            this.labeledInput,\n            this.saveButtonView,\n            this.cancelButtonView\n        ].forEach(v => {\n            // Register the view as focusable.\n            this._focusables.add(v);\n            // Register the view in the focus tracker.\n            this.focusTracker.add(v.element);\n        });\n    }\n    /**\n\t * Creates the button view.\n\t *\n\t * @private\n\t * @param {String} label The button label\n\t * @param {String} icon The button's icon.\n\t * @param {String} className The additional button CSS class name.\n\t * @param {String} [eventName] The event name that the ButtonView#execute event will be delegated to.\n\t * @returns {module:ui/button/buttonview~ButtonView} The button view instance.\n\t */\n    _createButton(label, icon, className, eventName) {\n        const button = new ButtonView(this.locale);\n        button.set({\n            label,\n            icon,\n            tooltip: true\n        });\n        button.extendTemplate({ attributes: { class: className } });\n        if (eventName) {\n            button.delegate('execute').to(this, eventName);\n        }\n        return button;\n    }\n    /**\n\t * Creates an input with a label.\n\t *\n\t * @private\n\t * @returns {module:ui/labeledinput/labeledinputview~LabeledInputView}\n\t */\n    _createLabeledInputView() {\n        const t = this.locale.t;\n        const labeledInput = new LabeledInputView(this.locale, InputTextView);\n        labeledInput.label = t('Text alternative');\n        labeledInput.inputView.placeholder = t('Text alternative');\n        return labeledInput;\n    }\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/bindings/submithandler\n */\n\n/**\n * A handler useful for {@link module:ui/view~View views} working as HTML forms. It intercepts a native DOM\n * `submit` event, prevents the default web browser behavior (navigation and page reload) and\n * fires the `submit` event on a view instead. Such a custom event can be then used by any\n * {@link module:utils/dom/emittermixin~Emitter emitter}, e.g. to serialize the form data.\n *\n *\t\timport submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';\n *\n *\t\t// ...\n *\n *\t\tclass AnyFormView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tsuper();\n *\n *\t\t\t\t// ...\n *\n *\t\t\t\tsubmitHandler( {\n *\t\t\t\t\tview: this\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n *\n *\t\t// ...\n *\n *\t\tconst view = new AnyFormView();\n *\n *\t\t// A sample listener attached by an emitter working with the view.\n *\t\tthis.listenTo( view, 'submit', () => {\n *\t\t\tsaveTheFormData();\n *\t\t\thideTheForm();\n *\t\t} );\n *\n * @param {Object} [options] Configuration options.\n * @param {module:ui/view~View} options.view The view which DOM `submit` events should be handled.\n */\nexport default function submitHandler( { view } ) {\n\tview.listenTo( view.element, 'submit', ( evt, domEvt ) => {\n\t\tdomEvt.preventDefault();\n\t\tview.fire( 'submit' );\n\t}, { useCapture: true } );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/position\n */\n\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport isFunction from '../lib/lodash/isFunction';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition( { element, target, positions, limiter, fitInViewport } ) {\n\t// If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-utils/issues/157\n\tif ( isFunction( target ) ) {\n\t\ttarget = target();\n\t}\n\n\t// If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-ui/issues/260\n\tif ( isFunction( limiter ) ) {\n\t\tlimiter = limiter();\n\t}\n\n\tconst positionedElementAncestor = getPositionedAncestor( element.parentElement );\n\tconst elementRect = new Rect( element );\n\tconst targetRect = new Rect( target );\n\n\tlet bestPosition;\n\tlet name;\n\n\t// If there are no limits, just grab the very first position and be done with that drama.\n\tif ( !limiter && !fitInViewport ) {\n\t\t[ name, bestPosition ] = getPosition( positions[ 0 ], targetRect, elementRect );\n\t} else {\n\t\tconst limiterRect = limiter && new Rect( limiter ).getVisible();\n\t\tconst viewportRect = fitInViewport && new Rect( global.window );\n\n\t\t[ name, bestPosition ] =\n\t\t\tgetBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) ||\n\t\t\t// If there's no best position found, i.e. when all intersections have no area because\n\t\t\t// rects have no width or height, then just use the first available position.\n\t\t\tgetPosition( positions[ 0 ], targetRect, elementRect );\n\t}\n\n\tlet { left, top } = getAbsoluteRectCoordinates( bestPosition );\n\n\tif ( positionedElementAncestor ) {\n\t\tconst ancestorPosition = getAbsoluteRectCoordinates( new Rect( positionedElementAncestor ) );\n\t\tconst ancestorBorderWidths = getBorderWidths( positionedElementAncestor );\n\n\t\t// (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n\t\t// If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n\t\t// consideration. `Rect` is always relative to the viewport while `position: absolute` works\n\t\t// with respect to that positioned ancestor.\n\t\tleft -= ancestorPosition.left;\n\t\ttop -= ancestorPosition.top;\n\n\t\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t\t// If there's some positioned ancestor of the panel, not only its position must be taken into\n\t\t// consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n\t\t// is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n\t\t// must compensate that scrolling.\n\t\tleft += positionedElementAncestor.scrollLeft;\n\t\ttop += positionedElementAncestor.scrollTop;\n\n\t\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t\t// If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n\t\t// while `position: absolute` positioning does not consider it.\n\t\t// E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n\t\t// not upper-left corner of its border.\n\t\tleft -= ancestorBorderWidths.left;\n\t\ttop -= ancestorBorderWidths.top;\n\t}\n\n\treturn { left, top, name };\n}\n\n// For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array} An array containing position name and its Rect.\nfunction getPosition( position, targetRect, elementRect ) {\n\tconst { left, top, name } = position( targetRect, elementRect );\n\n\treturn [ name, elementRect.clone().moveTo( left, top ) ];\n}\n\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position} to be checked, in the order of preference.\n// @param {utils/dom/rect~Rect} targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} viewportRect A rect of the viewport.\n// @returns {Array} An array containing the name of the position and it's rect.\nfunction getBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) {\n\tlet maxLimiterIntersectArea = 0;\n\tlet maxViewportIntersectArea = 0;\n\tlet bestPositionRect;\n\tlet bestPositionName;\n\n\t// This is when element is fully visible.\n\tconst elementRectArea = elementRect.getArea();\n\n\tpositions.some( position => {\n\t\tconst [ positionName, positionRect ] = getPosition( position, targetRect, elementRect );\n\t\tlet limiterIntersectArea;\n\t\tlet viewportIntersectArea;\n\n\t\tif ( limiterRect ) {\n\t\t\tif ( viewportRect ) {\n\t\t\t\t// Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n\t\t\t\tconst limiterViewportIntersectRect = limiterRect.getIntersection( viewportRect );\n\n\t\t\t\tif ( limiterViewportIntersectRect ) {\n\t\t\t\t\t// If the limiter is within the viewport, then check the intersection between that part of the\n\t\t\t\t\t// limiter and actual position.\n\t\t\t\t\tlimiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea( positionRect );\n\t\t\t\t} else {\n\t\t\t\t\tlimiterIntersectArea = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlimiterIntersectArea = limiterRect.getIntersectionArea( positionRect );\n\t\t\t}\n\t\t}\n\n\t\tif ( viewportRect ) {\n\t\t\tviewportIntersectArea = viewportRect.getIntersectionArea( positionRect );\n\t\t}\n\n\t\t// The only criterion: intersection with the viewport.\n\t\tif ( viewportRect && !limiterRect ) {\n\t\t\tif ( viewportIntersectArea > maxViewportIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\t\t// The only criterion: intersection with the limiter.\n\t\telse if ( !viewportRect && limiterRect ) {\n\t\t\tif ( limiterIntersectArea > maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\t\t// Two criteria: intersection with the viewport and the limiter visible in the viewport.\n\t\telse {\n\t\t\tif ( viewportIntersectArea > maxViewportIntersectArea && limiterIntersectArea >= maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t} else if ( viewportIntersectArea >= maxViewportIntersectArea && limiterIntersectArea > maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\n\t\tfunction setBestPosition() {\n\t\t\tmaxViewportIntersectArea = viewportIntersectArea;\n\t\t\tmaxLimiterIntersectArea = limiterIntersectArea;\n\t\t\tbestPositionRect = positionRect;\n\t\t\tbestPositionName = positionName;\n\t\t}\n\n\t\t// If a such position is found that element is fully container by the limiter then, obviously,\n\t\t// there will be no better one, so finishing.\n\t\treturn limiterIntersectArea === elementRectArea;\n\t} );\n\n\treturn bestPositionRect ? [ bestPositionName, bestPositionRect ] : null;\n}\n\n// DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getAbsoluteRectCoordinates( { left, top } ) {\n\tconst { scrollX, scrollY } = global.window;\n\n\treturn {\n\t\tleft: left + scrollX,\n\t\ttop: top + scrollY,\n\t};\n}\n\n/**\n * The `getOptimalPosition` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/panel/balloon/balloonpanelview\n */\n\nimport View from '../../view';\nimport { getOptimalPosition } from '@ckeditor/ckeditor5-utils/src/dom/position';\nimport isRange from '@ckeditor/ckeditor5-utils/src/dom/isrange';\nimport isElement from '@ckeditor/ckeditor5-utils/src/lib/lodash/isElement';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\n\nimport '../../../theme/components/panel/balloonpanel.css';\n\nconst toPx = toUnit( 'px' );\nconst defaultLimiterElement = global.document.body;\n\n/**\n * The balloon panel view class.\n *\n * A floating container which can\n * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#pin pin} to any\n * {@link module:utils/dom/position~Options#target target} in DOM and remain in that position\n * e.g. when the web page is scrolled.\n *\n * The balloon panel can be used to display contextual, non-blocking UI like forms, toolbars and\n * the like in its {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#content} view\n * collection.\n *\n * There is a number of {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}\n * that the balloon can use, automatically switching from one to another when the viewport space becomes\n * scarce to keep the balloon visible to the user as long as it is possible. The balloon will also\n * accept any custom position set provided by the user compatible with the\n * {@link module:utils/dom/position~Options options}.\n *\n *\t\tconst panel = new BalloonPanelView( locale );\n *\t\tconst childView = new ChildView();\n *\t\tconst positions = BalloonPanelView.defaultPositions;\n *\n *\t\tpanel.render();\n *\n *\t\t// Add a child view to the panel's content collection.\n *\t\tpanel.content.add( childView );\n *\n *\t\t// Start pinning the panel to an element with the \"target\" id DOM.\n *\t\t// The balloon will remain pinned until unpin() is called.\n *\t\tpanel.pin( {\n *\t\t\ttarget: document.querySelector( '#target' ),\n *\t\t\tpositions: [\n *\t\t\t\tpositions.northArrowSouth,\n *\t\t\t\tpositions.southArrowNorth\n *\t\t\t]\n *\t\t} );\n *\n * @extends module:ui/view~View\n */\nexport default class BalloonPanelView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\t/**\n\t\t * The absolute top position of the balloon panel in pixels.\n\t\t *\n\t\t * @observable\n\t\t * @default 0\n\t\t * @member {Number} #top\n\t\t */\n\t\tthis.set( 'top', 0 );\n\n\t\t/**\n\t\t * The absolute left position of the balloon panel in pixels.\n\t\t *\n\t\t * @observable\n\t\t * @default 0\n\t\t * @member {Number} #left\n\t\t */\n\t\tthis.set( 'left', 0 );\n\n\t\t/**\n\t\t * Balloon panel's current position. The position name is reflected in the CSS class set\n\t\t * to the balloon, i.e. `.ck-balloon-panel_arrow_nw` for \"arrow_nw\" position. The class\n\t\t * controls the minor aspects of the balloon's visual appearance like placement\n\t\t * of an {@link #withArrow arrow}. To support a new position, an additional CSS must be created.\n\t\t *\n\t\t * Default position names correspond with\n\t\t * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.\n\t\t *\n\t\t * See the {@link #attachTo} and {@link #pin} methods to learn about custom balloon positions.\n\t\t *\n\t\t * @observable\n\t\t * @default 'arrow_nw'\n\t\t * @member {'arrow_nw'|'arrow_ne'|'arrow_sw'|'arrow_se'} #position\n\t\t */\n\t\tthis.set( 'position', 'arrow_nw' );\n\n\t\t/**\n\t\t * Controls whether the balloon panel is visible or not.\n\t\t *\n\t\t * @observable\n\t\t * @default false\n\t\t * @member {Boolean} #isVisible\n\t\t */\n\t\tthis.set( 'isVisible', false );\n\n\t\t/**\n\t\t * Controls whether the balloon panel has an arrow. The presence of the arrow\n\t\t * is reflected in `ck-balloon-panel_with-arrow` CSS class.\n\t\t *\n\t\t * @observable\n\t\t * @default true\n\t\t * @member {Boolean} #withArrow\n\t\t */\n\t\tthis.set( 'withArrow', true );\n\n\t\t/**\n\t\t * An additional CSS class added to the {@link #element}.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #className\n\t\t */\n\t\tthis.set( 'className' );\n\n\t\t/**\n\t\t * A callback that starts pining the panel when {@link #isVisible} gets\n\t\t * `true`. Used by {@link #pin}.\n\t\t *\n\t\t * @private\n\t\t * @member {Function} #_pinWhenIsVisibleCallback\n\t\t */\n\n\t\t/**\n\t\t * Collection of the child views which creates balloon panel contents.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/viewcollection~ViewCollection}\n\t\t */\n\t\tthis.content = this.createCollection();\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-balloon-panel',\n\t\t\t\t\tbind.to( 'position', value => `ck-balloon-panel_${ value }` ),\n\t\t\t\t\tbind.if( 'isVisible', 'ck-balloon-panel_visible' ),\n\t\t\t\t\tbind.if( 'withArrow', 'ck-balloon-panel_with-arrow' ),\n\t\t\t\t\tbind.to( 'className' )\n\t\t\t\t],\n\n\t\t\t\tstyle: {\n\t\t\t\t\ttop: bind.to( 'top', toPx ),\n\t\t\t\t\tleft: bind.to( 'left', toPx )\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tchildren: this.content\n\t\t} );\n\t}\n\n\t/**\n\t * Shows the panel.\n\t *\n\t * See {@link #isVisible}.\n\t */\n\tshow() {\n\t\tthis.isVisible = true;\n\t}\n\n\t/**\n\t * Hides the panel.\n\t *\n\t * See {@link #isVisible}.\n\t */\n\thide() {\n\t\tthis.isVisible = false;\n\t}\n\n\t/**\n\t * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a\n\t * smart positioning heuristics that choses from available positions to make sure the panel\n\t * is visible to the user i.e. within the limits of the viewport.\n\t *\n\t * This method accepts configuration {@link module:utils/dom/position~Options options}\n\t * to set the `target`, optional `limiter` and `positions` the balloon should chose from.\n\t *\n\t *\t\tconst panel = new BalloonPanelView( locale );\n\t *\t\tconst positions = BalloonPanelView.defaultPositions;\n\t *\n\t *\t\tpanel.render();\n\t *\n\t *\t\t// Attach the panel to an element with the \"target\" id DOM.\n\t *\t\tpanel.attachTo( {\n\t *\t\t\ttarget: document.querySelector( '#target' ),\n\t *\t\t\tpositions: [\n\t *\t\t\t\tpositions.northArrowSouth,\n\t *\t\t\t\tpositions.southArrowNorth\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t * **Note**: Attaching the panel will also automatically {@link #show} it.\n\t *\n\t * **Note**: An attached panel will not follow its target when the window is scrolled or resized.\n\t * See the {@link #pin} method for more permanent positioning strategy.\n\t *\n\t * @param {module:utils/dom/position~Options} options Positioning options compatible with\n\t * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is\n\t * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.\n\t */\n\tattachTo( options ) {\n\t\tthis.show();\n\n\t\tconst defaultPositions = BalloonPanelView.defaultPositions;\n\t\tconst positionOptions = Object.assign( {}, {\n\t\t\telement: this.element,\n\t\t\tpositions: [\n\t\t\t\tdefaultPositions.southArrowNorth,\n\t\t\t\tdefaultPositions.southArrowNorthWest,\n\t\t\t\tdefaultPositions.southArrowNorthEast,\n\t\t\t\tdefaultPositions.northArrowSouth,\n\t\t\t\tdefaultPositions.northArrowSouthWest,\n\t\t\t\tdefaultPositions.northArrowSouthEast\n\t\t\t],\n\t\t\tlimiter: defaultLimiterElement,\n\t\t\tfitInViewport: true\n\t\t}, options );\n\n\t\tconst { top, left, name: position } = BalloonPanelView._getOptimalPosition( positionOptions );\n\n\t\tObject.assign( this, { top, left, position } );\n\t}\n\n\t/**\n\t * Works the same way as the {@link #attachTo} method except that the position of the panel is\n\t * continuously updated when:\n\t *\n\t * * any ancestor of the {@link module:utils/dom/position~Options#target}\n\t * or {@link module:utils/dom/position~Options#limiter} is scrolled,\n\t * * the browser window gets resized or scrolled.\n\t *\n\t * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target},\n\t * immune to the changing environment.\n\t *\n\t *\t\tconst panel = new BalloonPanelView( locale );\n\t *\t\tconst positions = BalloonPanelView.defaultPositions;\n\t *\n\t *\t\tpanel.render();\n\t *\n\t *\t\t// Pin the panel to an element with the \"target\" id DOM.\n\t *\t\tpanel.pin( {\n\t *\t\t\ttarget: document.querySelector( '#target' ),\n\t *\t\t\tpositions: [\n\t *\t\t\t\tpositions.northArrowSouth,\n\t *\t\t\t\tpositions.southArrowNorth\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t * To leave the pinned state, use the {@link #unpin} method.\n\t *\n\t * **Note**: Pinning the panel will also automatically {@link #show} it.\n\t *\n\t * @param {module:utils/dom/position~Options} options Positioning options compatible with\n\t * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is\n\t * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.\n\t */\n\tpin( options ) {\n\t\tthis.unpin();\n\n\t\tthis._pinWhenIsVisibleCallback = () => {\n\t\t\tif ( this.isVisible ) {\n\t\t\t\tthis._startPinning( options );\n\t\t\t} else {\n\t\t\t\tthis._stopPinning();\n\t\t\t}\n\t\t};\n\n\t\tthis._startPinning( options );\n\n\t\t// Control the state of the listeners depending on whether the panel is visible\n\t\t// or not.\n\t\t// TODO: Use on() (https://github.com/ckeditor/ckeditor5-utils/issues/144).\n\t\tthis.listenTo( this, 'change:isVisible', this._pinWhenIsVisibleCallback );\n\t}\n\n\t/**\n\t * Stops pinning the panel, as set up by {@link #pin}.\n\t */\n\tunpin() {\n\t\tif ( this._pinWhenIsVisibleCallback ) {\n\t\t\t// Deactivate listeners attached by pin().\n\t\t\tthis._stopPinning();\n\n\t\t\t// Deactivate the panel pin() control logic.\n\t\t\t// TODO: Use off() (https://github.com/ckeditor/ckeditor5-utils/issues/144).\n\t\t\tthis.stopListening( this, 'change:isVisible', this._pinWhenIsVisibleCallback );\n\n\t\t\tthis._pinWhenIsVisibleCallback = null;\n\n\t\t\tthis.hide();\n\t\t}\n\t}\n\n\t/**\n\t * Starts managing the pinned state of the panel. See {@link #pin}.\n\t *\n\t * @private\n\t * @param {module:utils/dom/position~Options} options Positioning options compatible with\n\t * {@link module:utils/dom/position~getOptimalPosition}.\n\t */\n\t_startPinning( options ) {\n\t\tthis.attachTo( options );\n\n\t\tconst targetElement = getDomElement( options.target );\n\t\tconst limiterElement = options.limiter ? getDomElement( options.limiter ) : defaultLimiterElement;\n\n\t\t// Then we need to listen on scroll event of eny element in the document.\n\t\tthis.listenTo( global.document, 'scroll', ( evt, domEvt ) => {\n\t\t\tconst scrollTarget = domEvt.target;\n\n\t\t\t// The position needs to be updated if the positioning target is within the scrolled element.\n\t\t\tconst isWithinScrollTarget = targetElement && scrollTarget.contains( targetElement );\n\n\t\t\t// The position needs to be updated if the positioning limiter is within the scrolled element.\n\t\t\tconst isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains( limiterElement );\n\n\t\t\t// The positioning target and/or limiter can be a Rect, object etc..\n\t\t\t// There's no way to optimize the listener then.\n\t\t\tif ( isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement ) {\n\t\t\t\tthis.attachTo( options );\n\t\t\t}\n\t\t}, { useCapture: true } );\n\n\t\t// We need to listen on window resize event and update position.\n\t\tthis.listenTo( global.window, 'resize', () => {\n\t\t\tthis.attachTo( options );\n\t\t} );\n\t}\n\n\t/**\n\t * Stops managing the pinned state of the panel. See {@link #pin}.\n\t *\n\t * @private\n\t */\n\t_stopPinning() {\n\t\tthis.stopListening( global.document, 'scroll' );\n\t\tthis.stopListening( global.window, 'resize' );\n\t}\n}\n\n// Returns the DOM element for given object or null, if there's none,\n// e.g. when passed object is a Rect instance or so.\n//\n// @private\n// @param {*} object\n// @returns {HTMLElement|null}\nfunction getDomElement( object ) {\n\tif ( isElement( object ) ) {\n\t\treturn object;\n\t}\n\n\tif ( isRange( object ) ) {\n\t\treturn object.commonAncestorContainer;\n\t}\n\n\tif ( typeof object == 'function' ) {\n\t\treturn getDomElement( object() );\n\t}\n\n\treturn null;\n}\n\n/**\n * A horizontal offset of the arrow tip from the edge of the balloon. Controlled by CSS.\n *\n *\t\t +-----|---------...\n *\t\t |     |\n *\t\t |     |\n *\t\t |     |\n *\t\t |     |\n *\t\t +--+  |  +------...\n *\t\t     \\ | /\n *\t\t      \\|/\n *\t    >|-----|<---------------- horizontal offset\n *\n * @default 30\n * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHorizontalOffset\n */\nBalloonPanelView.arrowHorizontalOffset = 25;\n\n/**\n * A vertical offset of the arrow from the edge of the balloon. Controlled by CSS.\n *\n *\t\t +-------------...\n *\t\t |\n *\t\t |\n *\t\t |                      /-- vertical offset\n *\t\t |                     V\n *\t\t +--+    +-----...    ---------\n *\t\t     \\  /              |\n *\t\t      \\/               |\n *\t\t-------------------------------\n *\t\t                       ^\n *\n * @default 15\n * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowVerticalOffset\n */\nBalloonPanelView.arrowVerticalOffset = 10;\n\n/**\n * Function used to calculate the optimal position for the balloon.\n *\n * @protected\n * @member {Function} module:ui/panel/balloon/balloonpanelview~BalloonPanelView._getOptimalPosition\n */\nBalloonPanelView._getOptimalPosition = getOptimalPosition;\n\n/**\n * A default set of positioning functions used by the balloon panel view\n * when attaching using {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.\n *\n * The available positioning functions are as follow:\n *\n * **North**\n *\n * * `northArrowSouth`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t         V\n * \t\t    [ Target ]\n *\n * * `northArrowSouthEast`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t               V\n * \t\t          [ Target ]\n *\n * * `northArrowSouthWest`\n *\n * \t\t  +-----------------+\n * \t\t  |     Balloon     |\n * \t\t  +-----------------+\n * \t\t     V\n * \t\t[ Target ]\n *\n * **North west**\n *\n * * `northWestArrowSouth`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t         V\n * \t\t         [ Target ]\n *\n * * `northWestArrowSouthWest`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t   V\n * \t\t   [ Target ]\n *\n * * `northWestArrowSouthEast`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t               V\n * \t\t               [ Target ]\n *\n * **North east**\n *\n * * `northEastArrowSouth`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t         V\n * \t\t[ Target ]\n *\n * * `northEastArrowSouthEast`\n *\n * \t\t+-----------------+\n * \t\t|     Balloon     |\n * \t\t+-----------------+\n * \t\t               V\n * \t\t      [ Target ]\n *\n * * `northEastArrowSouthWest`\n *\n * \t\t      +-----------------+\n * \t\t      |     Balloon     |\n * \t\t      +-----------------+\n * \t\t         V\n * \t\t[ Target ]\n *\n * **South**\n *\n * * `southArrowNorth`\n *\n *\t\t    [ Target ]\n *\t\t         ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southArrowNorthEast`\n *\n *\t\t          [ Target ]\n *\t\t               ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southArrowNorthWest`\n *\n *\t\t[ Target ]\n *\t\t     ^\n *\t\t   +-----------------+\n *\t\t   |     Balloon     |\n *\t\t   +-----------------+\n *\n * **South west**\n *\n * * `southWestArrowNorth`\n *\n *\t\t         [ Target ]\n *\t\t         ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southWestArrowNorthWest`\n *\n *\t\t  [ Target ]\n *\t\t  ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southWestArrowNorthEast`\n *\n *\t\t               [ Target ]\n *\t\t               ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * **South east**\n *\n * * `southEastArrowNorth`\n *\n *\t\t[ Target ]\n *\t\t         ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southEastArrowNorthEast`\n *\n *\t\t       [ Target ]\n *\t\t                ^\n *\t\t+-----------------+\n *\t\t|     Balloon     |\n *\t\t+-----------------+\n *\n * * `southEastArrowNorthWest`\n *\n *\t\t[ Target ]\n *\t\t         ^\n *\t\t       +-----------------+\n *\t\t       |     Balloon     |\n *\t\t       +-----------------+\n *\n * See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.\n *\n * Positioning functions must be compatible with {@link module:utils/dom/position~Position}.\n *\n * The name that position function returns will be reflected in balloon panel's class that\n * controls the placement of the \"arrow\". See {@link #position} to learn more.\n *\n * @member {Object} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions\n */\nBalloonPanelView.defaultPositions = {\n\t// ------- North\n\n\tnorthArrowSouth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,\n\t\tname: 'arrow_s'\n\t} ),\n\n\tnorthArrowSouthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_se'\n\t} ),\n\n\tnorthArrowSouthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_sw'\n\t} ),\n\n\t// ------- North west\n\n\tnorthWestArrowSouth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - balloonRect.width / 2,\n\t\tname: 'arrow_s'\n\t} ),\n\n\tnorthWestArrowSouthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_sw'\n\t} ),\n\n\tnorthWestArrowSouthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_se'\n\t} ),\n\n\t// ------- North east\n\n\tnorthEastArrowSouth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - balloonRect.width / 2,\n\t\tname: 'arrow_s'\n\t} ),\n\n\tnorthEastArrowSouthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_se'\n\t} ),\n\n\tnorthEastArrowSouthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getNorthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_sw'\n\t} ),\n\n\t// ------- South\n\n\tsouthArrowNorth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,\n\t\tname: 'arrow_n'\n\t} ),\n\n\tsouthArrowNorthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_ne'\n\t} ),\n\n\tsouthArrowNorthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left + targetRect.width / 2 - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_nw'\n\t} ),\n\n\t// ------- South west\n\n\tsouthWestArrowNorth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - balloonRect.width / 2,\n\t\tname: 'arrow_n'\n\t} ),\n\n\tsouthWestArrowNorthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_nw'\n\t} ),\n\n\tsouthWestArrowNorthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.left - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_ne'\n\t} ),\n\n\t// ------- South east\n\n\tsouthEastArrowNorth: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - balloonRect.width / 2,\n\t\tname: 'arrow_n'\n\t} ),\n\n\tsouthEastArrowNorthEast: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - balloonRect.width + BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_ne'\n\t} ),\n\n\tsouthEastArrowNorthWest: ( targetRect, balloonRect ) => ( {\n\t\ttop: getSouthTop( targetRect, balloonRect ),\n\t\tleft: targetRect.right - BalloonPanelView.arrowHorizontalOffset,\n\t\tname: 'arrow_nw'\n\t} ),\n};\n\n// Returns the top coordinate for positions starting with `north*`.\n//\n// @private\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.\n// @returns {Number}\nfunction getNorthTop( targetRect, balloonRect ) {\n\treturn targetRect.top - balloonRect.height - BalloonPanelView.arrowVerticalOffset;\n}\n\n// Returns the top coordinate for positions starting with `south*`.\n//\n// @private\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.\n// @returns {Number}\nfunction getSouthTop( targetRect ) {\n\treturn targetRect.bottom + BalloonPanelView.arrowVerticalOffset;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/tounit\n */\n\n/**\n * Returns a helper function, which adds a desired trailing\n * `unit` to the passed value.\n *\n * @param {String} unit An unit like \"px\" or \"em\".\n * @returns {module:utils/dom/tounit~helper}\n */\nexport default function toUnit( unit ) {\n\t/**\n\t * A function, which adds a pre–defined trailing `unit`\n\t * to the passed `value`.\n\t *\n\t * @function helper\n \t * @param {*} value A value to be given the unit.\n \t * @returns {String} A value with the trailing unit.\n\t */\n\treturn value => value + unit;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module utils/dom/getpositionedancestor\n */\n\nimport global from './global';\n\n/**\n * For a given element, returns the nearest ancestor element which CSS position is not \"static\".\n *\n * @param {HTMLElement} element Native DOM element to be checked.\n * @returns {HTMLElement|null}\n */\nexport default function getPositionedAncestor( element ) {\n\twhile ( element && element.tagName.toLowerCase() != 'html' ) {\n\t\tif ( global.window.getComputedStyle( element ).position != 'static' ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n\n\treturn null;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/panel/balloon/contextualballoon\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport BalloonPanelView from './balloonpanelview';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Provides the common contextual balloon panel for the editor.\n *\n * This plugin allows reusing a single {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} instance\n * to display multiple contextual balloon panels in the editor.\n *\n * Child views of such a panel are stored in the stack and the last one in the stack is visible. When the\n * visible view is removed from the stack, the previous view becomes visible, etc. If there are no more\n * views in the stack, the balloon panel will hide.\n *\n * It simplifies managing the views and helps\n * avoid the unnecessary complexity of handling multiple {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}\n * instances in the editor.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ContextualBalloon extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ContextualBalloon';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\t/**\n\t\t * The common balloon panel view.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} #view\n\t\t */\n\t\tthis.view = new BalloonPanelView();\n\n\t\t/**\n\t\t * The {@link module:utils/dom/position~Options#limiter position limiter}\n\t\t * for the {@link #view}, used when no `limiter` has been passed into {@link #add}\n\t\t * or {@link #updatePosition}.\n\t\t *\n\t\t * By default, a function, which obtains the farthest DOM\n\t\t * {@link module:engine/view/rooteditableelement~RootEditableElement}\n\t\t * of the {@link module:engine/view/document~Document#selection}.\n\t\t *\n\t\t * @member {module:utils/dom/position~Options#limiter} #positionLimiter\n\t\t */\n\t\tthis.positionLimiter = () => {\n\t\t\tconst view = this.editor.editing.view;\n\t\t\tconst viewDocument = view.document;\n\t\t\tconst editableElement = viewDocument.selection.editableElement;\n\n\t\t\tif ( editableElement ) {\n\t\t\t\treturn view.domConverter.mapViewToDom( editableElement.root );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\t/**\n\t\t * Stack of the views injected into the balloon. Last one in the stack is displayed\n\t\t * as a content of {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon#view}.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} #_stack\n\t\t */\n\t\tthis._stack = new Map();\n\n\t\t// Add balloon panel view to editor `body` collection and wait until view will be ready.\n\t\tthis.editor.ui.view.body.add( this.view );\n\n\t\t// Editor should be focused when contextual balloon is focused.\n\t\tthis.editor.ui.focusTracker.add( this.view.element );\n\t}\n\n\t/**\n\t * Returns the currently visible view or `null` when there are no\n\t * views in the stack.\n\t *\n\t * @returns {module:ui/view~View|null}\n\t */\n\tget visibleView() {\n\t\tconst item = this._stack.get( this.view.content.get( 0 ) );\n\n\t\treturn item ? item.view : null;\n\t}\n\n\t/**\n\t * Returns `true` when the given view is in the stack. Otherwise returns `false`.\n\t *\n\t * @param {module:ui/view~View} view\n\t * @returns {Boolean}\n\t */\n\thasView( view ) {\n\t\treturn this._stack.has( view );\n\t}\n\n\t/**\n\t * Adds a new view to the stack and makes it visible.\n\t *\n\t * @param {Object} data Configuration of the view.\n\t * @param {module:ui/view~View} [data.view] Content of the balloon.\n\t * @param {module:utils/dom/position~Options} [data.position] Positioning options.\n\t * @param {String} [data.balloonClassName] Additional css class for {@link #view} added when given view is visible.\n\t */\n\tadd( data ) {\n\t\tif ( this.hasView( data.view ) ) {\n\t\t\t/**\n\t\t\t * Trying to add configuration of the same view more than once.\n\t\t\t *\n\t\t\t * @error contextualballoon-add-view-exist\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'contextualballoon-add-view-exist: Cannot add configuration of the same view twice.' );\n\t\t}\n\n\t\t// When adding view to the not empty balloon.\n\t\tif ( this.visibleView ) {\n\t\t\t// Remove displayed content from the view.\n\t\t\tthis.view.content.remove( this.visibleView );\n\t\t}\n\n\t\t// Add new view to the stack.\n\t\tthis._stack.set( data.view, data );\n\n\t\t// And display it.\n\t\tthis._show( data );\n\t}\n\n\t/**\n\t * Removes the given view from the stack. If the removed view was visible,\n\t * then the view preceding it in the stack will become visible instead.\n\t * When there is no view in the stack then balloon will hide.\n\t *\n\t * @param {module:ui/view~View} view A view to be removed from the balloon.\n\t */\n\tremove( view ) {\n\t\tif ( !this.hasView( view ) ) {\n\t\t\t/**\n\t\t\t * Trying to remove configuration of the view not defined in the stack.\n\t\t\t *\n\t\t\t * @error contextualballoon-remove-view-not-exist\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'contextualballoon-remove-view-not-exist: Cannot remove configuration of not existing view.' );\n\t\t}\n\n\t\t// When visible view is being removed.\n\t\tif ( this.visibleView === view ) {\n\t\t\t// We need to remove it from the view content.\n\t\t\tthis.view.content.remove( view );\n\n\t\t\t// And then remove from the stack.\n\t\t\tthis._stack.delete( view );\n\n\t\t\t// Next we need to check if there is other view in stack to show.\n\t\t\tconst last = Array.from( this._stack.values() ).pop();\n\n\t\t\t// If it is some other view.\n\t\t\tif ( last ) {\n\t\t\t\t// Just show it.\n\t\t\t\tthis._show( last );\n\t\t\t} else {\n\t\t\t\t// Hide the balloon panel.\n\t\t\t\tthis.view.hide();\n\t\t\t}\n\t\t} else {\n\t\t\t// Just remove given view from the stack.\n\t\t\tthis._stack.delete( view );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the position of the balloon using position data of the first visible view in the stack.\n\t * When new position data is given then position data of currently visible panel will be updated.\n\t *\n\t * @param {module:utils/dom/position~Options} [position] position options.\n\t */\n\tupdatePosition( position ) {\n\t\tif ( position ) {\n\t\t\tthis._stack.get( this.visibleView ).position = position;\n\t\t}\n\n\t\tthis.view.pin( this._getBalloonPosition() );\n\t}\n\n\t/**\n\t * Sets the view as a content of the balloon and attaches balloon using position\n\t * options of the first view.\n\t *\n\t * @private\n\t * @param {Object} data Configuration.\n\t * @param {module:ui/view~View} [data.view] View to show in the balloon.\n\t * @param {String} [data.balloonClassName=''] Additional class name which will added to the {#_balloon} view.\n\t */\n\t_show( { view, balloonClassName = '' } ) {\n\t\tthis.view.className = balloonClassName;\n\n\t\tthis.view.content.add( view );\n\t\tthis.view.pin( this._getBalloonPosition() );\n\t}\n\n\t/**\n\t * Returns position options of the last view in the stack.\n\t * This keeps the balloon in the same position when view is changed.\n\t *\n\t * @private\n\t * @returns {module:utils/dom/position~Options}\n\t */\n\t_getBalloonPosition() {\n\t\tlet position = Array.from( this._stack.values() ).pop().position;\n\n\t\t// Use the default limiter if none has been specified.\n\t\tif ( position && !position.limiter ) {\n\t\t\t// Don't modify the original options object.\n\t\t\tposition = Object.assign( {}, position, {\n\t\t\t\tlimiter: this.positionLimiter\n\t\t\t} );\n\t\t}\n\n\t\treturn position;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/image/ui/utils\n */\n\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { isImageWidgetSelected } from '../utils';\n\n/**\n * A helper utility that positions the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} instance\n * with respect to the image in the editor content, if one is selected.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n */\nexport function repositionContextualBalloon( editor ) {\n\tconst balloon = editor.plugins.get( 'ContextualBalloon' );\n\n\tif ( isImageWidgetSelected( editor.editing.view.document.selection ) ) {\n\t\tconst position = getBalloonPositionData( editor );\n\n\t\tballoon.updatePosition( position );\n\t}\n}\n\n/**\n * Returns the positioning options that control the geometry of the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} with respect\n * to the selected element in the editor content.\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @returns {module:utils/dom/position~Options}\n */\nexport function getBalloonPositionData( editor ) {\n\tconst editingView = editor.editing.view;\n\tconst defaultPositions = BalloonPanelView.defaultPositions;\n\n\treturn {\n\t\ttarget: editingView.domConverter.viewToDom( editingView.document.selection.getSelectedElement() ),\n\t\tpositions: [\n\t\t\tdefaultPositions.northArrowSouth,\n\t\t\tdefaultPositions.northArrowSouthWest,\n\t\t\tdefaultPositions.northArrowSouthEast,\n\t\t\tdefaultPositions.southArrowNorth,\n\t\t\tdefaultPositions.southArrowNorthWest,\n\t\t\tdefaultPositions.southArrowNorthEast\n\t\t]\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module image/imagetextalternative/imagetextalternativeui\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';\nimport clickOutsideHandler from '@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler';\nimport TextAlternativeFormView from './ui/textalternativeformview';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport textAlternativeIcon from '@ckeditor/ckeditor5-core/theme/icons/low-vision.svg';\nimport {\n    repositionContextualBalloon,\n    getBalloonPositionData\n} from '../image/ui/utils';\nimport { isImageWidgetSelected } from '../image/utils';\n/**\n * The image text alternative UI plugin.\n *\n * The plugin uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageTextAlternativeUI extends Plugin {\n    /**\n\t * @inheritDoc\n\t */\n    static get requires() {\n        return [ContextualBalloon];\n    }\n    /**\n\t * @inheritDoc\n\t */\n    init() {\n        this._createButton();\n        this._createForm();\n    }\n    /**\n\t * Creates a button showing the balloon panel for changing the image text alternative and\n\t * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.\n\t *\n\t * @private\n\t */\n    _createButton() {\n        const editor = this.editor;\n        const t = editor.t;\n        editor.ui.componentFactory.add('imageTextAlternative', locale => {\n            const command = editor.commands.get('imageTextAlternative');\n            const view = new ButtonView(locale);\n            view.set({\n                label: t('Change image text alternative'),\n                icon: textAlternativeIcon,\n                tooltip: true\n            });\n            view.bind('isEnabled').to(command, 'isEnabled');\n            this.listenTo(view, 'execute', () => this._showForm());\n            return view;\n        });\n    }\n    /**\n\t * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}\n\t * form.\n\t *\n\t * @private\n\t */\n    _createForm() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        /**\n\t\t * The contextual balloon plugin instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}\n\t\t */\n        this._balloon = this.editor.plugins.get('ContextualBalloon');\n        /**\n\t\t * A form containing a textarea and buttons, used to change the `alt` text value.\n\t\t *\n\t\t * @member {module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}\n\t\t */\n        this._form = new TextAlternativeFormView(editor.locale);\n        // Render the form so its #element is available for clickOutsideHandler.\n        this._form.render();\n        this.listenTo(this._form, 'submit', () => {\n            editor.execute('imageTextAlternative', { newValue: this._form.labeledInput.inputView.element.value });\n            this._hideForm(true);\n        });\n        this.listenTo(this._form, 'cancel', () => {\n            this._hideForm(true);\n        });\n        // Close the form on Esc key press.\n        this._form.keystrokes.set('Esc', (data, cancel) => {\n            this._hideForm(true);\n            cancel();\n        });\n        // Reposition the balloon or hide the form if an image widget is no longer selected.\n        this.listenTo(editor.ui, 'update', () => {\n            if (!isImageWidgetSelected(viewDocument.selection)) {\n                this._hideForm(true);\n            } else if (this._isVisible) {\n                repositionContextualBalloon(editor);\n            }\n        });\n        // Close on click outside of balloon panel element.\n        clickOutsideHandler({\n            emitter: this._form,\n            activator: () => this._isVisible,\n            contextElements: [this._form.element],\n            callback: () => this._hideForm()\n        });\n    }\n    /**\n\t * Shows the {@link #_form} in the {@link #_balloon}.\n\t *\n\t * @private\n\t */\n    _showForm() {\n        if (this._isVisible) {\n            return;\n        }\n        const editor = this.editor;\n        const command = editor.commands.get('imageTextAlternative');\n        const labeledInput = this._form.labeledInput;\n        if (!this._balloon.hasView(this._form)) {\n            this._balloon.add({\n                view: this._form,\n                position: getBalloonPositionData(editor)\n            });\n        }\n        // Make sure that each time the panel shows up, the field remains in sync with the value of\n        // the command. If the user typed in the input, then canceled the balloon (`labeledInput#value`\n        // stays unaltered) and re-opened it without changing the value of the command, they would see the\n        // old value instead of the actual value of the command.\n        // https://github.com/ckeditor/ckeditor5-image/issues/114\n        labeledInput.value = labeledInput.inputView.element.value = command.value || '';\n        this._form.labeledInput.select();\n    }\n    /**\n\t * Removes the {@link #_form} from the {@link #_balloon}.\n\t *\n\t * @param {Boolean} [focusEditable=false] Controls whether the editing view is focused afterwards.\n\t * @private\n\t */\n    _hideForm(focusEditable) {\n        if (!this._isVisible) {\n            return;\n        }\n        this._balloon.remove(this._form);\n        if (focusEditable) {\n            this.editor.editing.view.focus();\n        }\n    }\n    /**\n\t * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.\n\t *\n\t * @private\n\t * @type {Boolean}\n\t */\n    get _isVisible() {\n        return this._balloon.visibleView == this._form;\n    }\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/bindings/clickoutsidehandler\n */\n\n/* global document */\n\n/**\n * Handles clicking **outside** of a specified set of elements, then fires an action.\n *\n * **Note**: Actually, the action is executed upon `mousedown`, not `click`. It prevents\n * certain issues when the user keeps holding the mouse button and the UI cannot react\n * properly.\n *\n * @param {Object} options Configuration options.\n * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior\n * should be added.\n * @param {Function} options.activator Function returning a `Boolean`, to determine whether the handler is active.\n * @param {Array.<HTMLElement>} options.contextElements HTML elements that determine the scope of the\n * handler. Clicking any of them or their descendants will **not** fire the callback.\n * @param {Function} options.callback An action executed by the handler.\n */\nexport default function clickOutsideHandler( { emitter, activator, callback, contextElements } ) {\n\temitter.listenTo( document, 'mousedown', ( evt, { target } ) => {\n\t\tif ( !activator() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const contextElement of contextElements ) {\n\t\t\tif ( contextElement.contains( target ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tcallback();\n\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/imagetextalternative\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageTextAlternativeEditing from './imagetextalternative/imagetextalternativeediting';\nimport ImageTextAlternativeUI from './imagetextalternative/imagetextalternativeui';\n\n/**\n * The image text alternative plugin.\n *\n * It loads the {@link module:image/imagetextalternative/imagetextalternativeediting~ImageTextAlternativeEditing}\n * and {@link module:image/imagetextalternative/imagetextalternativeui~ImageTextAlternativeUI} plugins.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageTextAlternative extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageTextAlternativeEditing, ImageTextAlternativeUI ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageTextAlternative';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/image\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageEditing from '../src/image/imageediting';\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport ImageTextAlternative from './imagetextalternative';\n\nimport '../theme/image.css';\n\n/**\n * The image plugin.\n *\n * Uses the {@link module:image/image/imageediting~ImageEditing}.\n *\n * For a detailed overview, check the {@glink features/image image feature} documentation.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Image extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageEditing, Widget, ImageTextAlternative ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Image';\n\t}\n}\n\n/**\n * The configuration of the image features. Used by the image features in the `@ckeditor/ckeditor5-image` package.\n *\n * Read more in {@link module:image/image~ImageConfig}.\n *\n * @member {module:image/image~ImageConfig} module:core/editor/editorconfig~EditorConfig#image\n */\n\n/**\n * The configuration of the image features. Used by the image features in the `@ckeditor/ckeditor5-image` package.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n * \t\t\t\timage: ... // Image feature options.\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.\n *\n * @interface ImageConfig\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module upload/ui/filedialogbuttonview\n */\n\nimport ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';\nimport View from '@ckeditor/ckeditor5-ui/src/view';\n\n/**\n * The file dialog button view.\n *\n * This component provides a button that opens the native file selection dialog.\n * It can be used to implement the UI of a file upload feature.\n *\n *\t\tconst view = new FileDialogButtonView( locale );\n *\n *\t\tview.set( {\n *\t\t\tacceptedType: 'image/*',\n *\t\t\tallowMultipleFiles: true\n *\t\t} );\n *\n *\t\tview.buttonView.set( {\n *\t\t\tlabel: t( 'Insert image' ),\n *\t\t\ticon: imageIcon,\n *\t\t\ttooltip: true\n *\t\t} );\n *\n *\t\tview.on( 'done', ( evt, files ) => {\n *\t\t\tfor ( const file of Array.from( files ) ) {\n *\t\t\t\tconsole.log( 'Selected file', file );\n *\t\t\t}\n *\t\t} );\n *\n * @extends module:ui/view~View\n */\nexport default class FileDialogButtonView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * The button view of the component.\n\t\t *\n\t\t * @member {module:ui/button/buttonview~ButtonView}\n\t\t */\n\t\tthis.buttonView = new ButtonView( locale );\n\n\t\t/**\n\t\t * A hidden `<input>` view used to execute file dialog.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:upload/ui/filedialogbuttonview~FileInputView}\n\t\t */\n\t\tthis._fileInputView = new FileInputView( locale );\n\n\t\t/**\n\t\t * Accepted file types. Can be provided in form of file extensions, media type or one of:\n\t\t * * `audio/*`,\n\t\t * * `video/*`,\n\t\t * * `image/*`.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #acceptedType\n\t\t */\n\t\tthis._fileInputView.bind( 'acceptedType' ).to( this );\n\n\t\t/**\n\t\t * Indicates if multiple files can be selected. Defaults to `true`.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #allowMultipleFiles\n\t\t */\n\t\tthis._fileInputView.bind( 'allowMultipleFiles' ).to( this );\n\n\t\t/**\n\t\t * Fired when file dialog is closed with file selected.\n\t\t *\n\t\t *\t\tview.on( 'done', ( evt, files ) => {\n\t\t *\t\t\tfor ( const file of files ) {\n\t\t *\t\t\t\tconsole.log( 'Selected file', file );\n\t\t *\t\t\t}\n\t\t *\t\t}\n\t\t *\n\t\t * @event done\n\t\t * @param {Array.<File>} files Array of selected files.\n\t\t */\n\t\tthis._fileInputView.delegate( 'done' ).to( this );\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'span',\n\t\t\tattributes: {\n\t\t\t\tclass: 'ck-file-dialog-button',\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\tthis.buttonView,\n\t\t\t\tthis._fileInputView\n\t\t\t]\n\t\t} );\n\n\t\tthis.buttonView.on( 'execute', () => {\n\t\t\tthis._fileInputView.open();\n\t\t} );\n\t}\n\n\t/**\n\t * Focuses the {@link #buttonView}.\n\t */\n\tfocus() {\n\t\tthis.buttonView.focus();\n\t}\n}\n\n/**\n * The hidden file input view class.\n *\n * @private\n * @extends {module:ui/view~View}\n */\nclass FileInputView extends View {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( locale ) {\n\t\tsuper( locale );\n\n\t\t/**\n\t\t * Accepted file types. Can be provided in form of file extensions, media type or one of:\n\t\t * * `audio/*`,\n\t\t * * `video/*`,\n\t\t * * `image/*`.\n\t\t *\n\t\t * @observable\n\t\t * @member {String} #acceptedType\n\t\t */\n\t\tthis.set( 'acceptedType' );\n\n\t\t/**\n\t\t * Indicates if multiple files can be selected. Defaults to `false`.\n\t\t *\n\t\t * @observable\n\t\t * @member {Boolean} #allowMultipleFiles\n\t\t */\n\t\tthis.set( 'allowMultipleFiles', false );\n\n\t\tconst bind = this.bindTemplate;\n\n\t\tthis.setTemplate( {\n\t\t\ttag: 'input',\n\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck-hidden'\n\t\t\t\t],\n\t\t\t\ttype: 'file',\n\t\t\t\ttabindex: '-1',\n\t\t\t\taccept: bind.to( 'acceptedType' ),\n\t\t\t\tmultiple: bind.to( 'allowMultipleFiles' )\n\t\t\t},\n\n\t\t\ton: {\n\t\t\t\t// Removing from code coverage since we cannot programmatically set input element files.\n\t\t\t\tchange: bind.to( /* istanbul ignore next */ () => {\n\t\t\t\t\tif ( this.element && this.element.files && this.element.files.length ) {\n\t\t\t\t\t\tthis.fire( 'done', this.element.files );\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.element.value = '';\n\t\t\t\t} )\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Opens file dialog.\n\t */\n\topen() {\n\t\tthis.element.click();\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module upload/utils\n */\n\nimport ModelPosition from '@ckeditor/ckeditor5-engine/src/model/position';\n\n/**\n * Checks if a given file is an image.\n *\n * @param {File} file\n * @returns {Boolean}\n */\nexport function isImageType( file ) {\n\tconst types = /^image\\/(jpeg|png|gif|bmp)$/;\n\n\treturn types.test( file.type );\n}\n\n/**\n * Returns a model position which is optimal (in terms of UX) for inserting an image.\n *\n * For instance, if a selection is in the middle of a paragraph, the position before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the position after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, that block will be returned. If that position\n * is then passed to {@link module:engine/model/model~Model#insertContent},\n * the block will be fully replaced by the image.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @returns {module:engine/model/position~Position} The optimal position.\n */\nexport function findOptimalInsertionPosition( selection ) {\n\tconst selectedElement = selection.getSelectedElement();\n\n\tif ( selectedElement ) {\n\t\treturn ModelPosition.createAfter( selectedElement );\n\t}\n\n\tconst firstBlock = selection.getSelectedBlocks().next().value;\n\n\tif ( firstBlock ) {\n\t\t// If inserting into an empty block – return position in that block. It will get\n\t\t// replaced with the image by insertContent(). #42.\n\t\tif ( firstBlock.isEmpty ) {\n\t\t\treturn ModelPosition.createAt( firstBlock );\n\t\t}\n\n\t\tconst positionAfter = ModelPosition.createAfter( firstBlock );\n\n\t\t// If selection is at the end of the block - return position after the block.\n\t\tif ( selection.focus.isTouching( positionAfter ) ) {\n\t\t\treturn positionAfter;\n\t\t}\n\n\t\t// Otherwise return position before the block.\n\t\treturn ModelPosition.createBefore( firstBlock );\n\t}\n\n\treturn selection.focus;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module image/imageupload/imageuploadui\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileDialogButtonView from '@ckeditor/ckeditor5-upload/src/ui/filedialogbuttonview';\nimport imageIcon from '@ckeditor/ckeditor5-core/theme/icons/image.svg';\nimport {\n    isImageType,\n    findOptimalInsertionPosition\n} from './utils';\n/**\n * The image upload button plugin.\n * Adds the `imageUpload` button to the {@link module:ui/componentfactory~ComponentFactory UI component factory}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUploadUI extends Plugin {\n    /**\n\t * @inheritDoc\n\t */\n    init() {\n        const editor = this.editor;\n        const t = editor.t;\n        // Setup `imageUpload` button.\n        editor.ui.componentFactory.add('imageUpload', locale => {\n            const view = new FileDialogButtonView(locale);\n            const command = editor.commands.get('imageUpload');\n            view.set({\n                acceptedType: 'image/*',\n                allowMultipleFiles: true\n            });\n            view.buttonView.set({\n                label: t('Insert image'),\n                icon: imageIcon,\n                tooltip: true\n            });\n            view.buttonView.bind('isEnabled').to(command);\n            view.on('done', (evt, files) => {\n                for (const file of Array.from(files)) {\n                    const insertAt = findOptimalInsertionPosition(editor.model.document.selection);\n                    if (isImageType(file)) {\n                        editor.execute('imageUpload', {\n                            file,\n                            insertAt\n                        });\n                    }\n                }\n            });\n            return view;\n        });\n    }\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/imageupload/imageuploadprogress\n */\n\n/* globals setTimeout */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport uploadingPlaceholder from '../../theme/icons/image_placeholder.svg';\nimport UIElement from '@ckeditor/ckeditor5-engine/src/view/uielement';\nimport ViewPosition from '@ckeditor/ckeditor5-engine/src/view/position';\nimport ViewRange from '@ckeditor/ckeditor5-engine/src/view/range';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport '../../theme/imageuploadprogress.css';\nimport '../../theme/imageuploadicon.css';\nimport '../../theme/imageuploadloader.css';\n\n/**\n * The image upload progress plugin.\n * It shows a placeholder when the image is read from the disk and a progress bar while the image is uploading.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUploadProgress extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The image placeholder that is displayed before real image data can be accessed.\n\t\t *\n\t\t * @protected\n\t\t * @member {String} #placeholder\n\t\t */\n\t\tthis.placeholder = 'data:image/svg+xml;utf8,' + encodeURIComponent( uploadingPlaceholder );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Upload status change - update image's view according to that status.\n\t\teditor.editing.downcastDispatcher.on( 'attribute:uploadStatus:image', ( ...args ) => this.uploadStatusChange( ...args ) );\n\t}\n\n\t/**\n\t * This method is called each time the image `uploadStatus` attribute is changed.\n\t *\n\t * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable Values to consume.\n\t * @param {Object} conversionApi\n\t */\n\tuploadStatusChange( evt, data, conversionApi ) {\n\t\tconst editor = this.editor;\n\t\tconst modelImage = data.item;\n\t\tconst uploadId = modelImage.getAttribute( 'uploadId' );\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\t\tconst status = uploadId ? data.attributeNewValue : null;\n\t\tconst placeholder = this.placeholder;\n\t\tconst viewFigure = editor.editing.mapper.toViewElement( modelImage );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\tif ( status == 'reading' ) {\n\t\t\t// Start \"appearing\" effect and show placeholder with infinite progress bar on the top\n\t\t\t// while image is read from disk.\n\t\t\t_startAppearEffect( viewFigure, viewWriter );\n\t\t\t_showPlaceholder( placeholder, viewFigure, viewWriter );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Show progress bar on the top of the image when image is uploading.\n\t\tif ( status == 'uploading' ) {\n\t\t\tconst loader = fileRepository.loaders.get( uploadId );\n\n\t\t\t// Start appear effect if needed - see https://github.com/ckeditor/ckeditor5-image/issues/191.\n\t\t\t_startAppearEffect( viewFigure, viewWriter );\n\n\t\t\tif ( !loader ) {\n\t\t\t\t// There is no loader associated with uploadId - this means that image came from external changes.\n\t\t\t\t// In such cases we still want to show the placeholder until image is fully uploaded.\n\t\t\t\t// Show placeholder if needed - see https://github.com/ckeditor/ckeditor5-image/issues/191.\n\t\t\t\t_showPlaceholder( placeholder, viewFigure, viewWriter );\n\t\t\t} else {\n\t\t\t\t// Hide placeholder and initialize progress bar showing upload progress.\n\t\t\t\t_hidePlaceholder( viewFigure, viewWriter );\n\t\t\t\t_showProgressBar( viewFigure, viewWriter, loader, editor.editing.view );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Because in Edge there is no way to show fancy animation of completeIcon we need to skip it.\n\t\tif ( status == 'complete' && fileRepository.loaders.get( uploadId ) && !env.isEdge ) {\n\t\t\t_showCompleteIcon( viewFigure, viewWriter, editor.editing.view );\n\t\t}\n\n\t\t// Clean up.\n\t\t_hideProgressBar( viewFigure, viewWriter );\n\t\t_hidePlaceholder( viewFigure, viewWriter );\n\t\t_stopAppearEffect( viewFigure, viewWriter );\n\t}\n}\n\n// Symbol added to progress bar UIElement to distinguish it from other elements.\nconst progressBarSymbol = Symbol( 'progress-bar' );\n\n// Symbol added to placeholder UIElement to distinguish it from other elements.\nconst placeholderSymbol = Symbol( 'placeholder' );\n\n// Adds ck-appear class to the image figure if one is not already applied.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\nfunction _startAppearEffect( viewFigure, writer ) {\n\tif ( !viewFigure.hasClass( 'ck-appear' ) ) {\n\t\twriter.addClass( 'ck-appear', viewFigure );\n\t}\n}\n\n// Removes ck-appear class to the image figure if one is not already removed.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\nfunction _stopAppearEffect( viewFigure, writer ) {\n\twriter.removeClass( 'ck-appear', viewFigure );\n}\n\n// Shows placeholder together with infinite progress bar on given image figure.\n//\n// @param {String} Data-uri with a svg placeholder.\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\nfunction _showPlaceholder( placeholder, viewFigure, writer ) {\n\tif ( !viewFigure.hasClass( 'ck-image-upload-placeholder' ) ) {\n\t\twriter.addClass( 'ck-image-upload-placeholder', viewFigure );\n\t}\n\n\tconst viewImg = viewFigure.getChild( 0 );\n\n\tif ( viewImg.getAttribute( 'src' ) !== placeholder ) {\n\t\twriter.setAttribute( 'src', placeholder, viewImg );\n\t}\n\n\tif ( !_getUIElement( viewFigure, placeholderSymbol ) ) {\n\t\twriter.insert( ViewPosition.createAfter( viewImg ), _createPlaceholder( writer ) );\n\t}\n}\n\n// Removes placeholder together with infinite progress bar on given image figure.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\nfunction _hidePlaceholder( viewFigure, writer ) {\n\tif ( viewFigure.hasClass( 'ck-image-upload-placeholder' ) ) {\n\t\twriter.removeClass( 'ck-image-upload-placeholder', viewFigure );\n\t}\n\n\t_removeUIElement( viewFigure, writer, placeholderSymbol );\n}\n\n// Shows progress bar displaying upload progress.\n// Attaches it to the file loader to update when upload percentace is changed.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\n// @param {module:upload/filerepository~FileLoader} loader\n// @param {module:engine/view/view~View} view\nfunction _showProgressBar( viewFigure, writer, loader, view ) {\n\tconst progressBar = _createProgressBar( writer );\n\twriter.insert( ViewPosition.createAt( viewFigure, 'end' ), progressBar );\n\n\t// Update progress bar width when uploadedPercent is changed.\n\tloader.on( 'change:uploadedPercent', ( evt, name, value ) => {\n\t\tview.change( writer => {\n\t\t\twriter.setStyle( 'width', value + '%', progressBar );\n\t\t} );\n\t} );\n}\n\n// Hides upload progress bar.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\nfunction _hideProgressBar( viewFigure, writer ) {\n\t_removeUIElement( viewFigure, writer, progressBarSymbol );\n}\n\n// Shows complete icon and hides after a certain amount of time.\n//\n// @param {module:engine/view/containerelement~ContainerElement} viewFigure\n// @param {module:engine/view/writer~Writer} writer\n// @param {module:engine/view/view~View} view\nfunction _showCompleteIcon( viewFigure, writer, view ) {\n\tconst completeIcon = new UIElement( 'div', { class: 'ck-image-upload-complete-icon' } );\n\n\twriter.insert( ViewPosition.createAt( viewFigure, 'end' ), completeIcon );\n\n\tsetTimeout( () => {\n\t\tview.change( writer => writer.remove( ViewRange.createOn( completeIcon ) ) );\n\t}, 3000 );\n}\n\n// Create progress bar element using {@link module:engine/view/uielement~UIElement}.\n//\n// @private\n// @param {module:engine/view/writer~Writer} writer\n// @returns {module:engine/view/uielement~UIElement}\nfunction _createProgressBar( writer ) {\n\tconst progressBar = writer.createUIElement( 'div', { class: 'ck-progress-bar' } );\n\n\twriter.setCustomProperty( progressBarSymbol, true, progressBar );\n\n\treturn progressBar;\n}\n\n// Create placeholder element using {@link module:engine/view/uielement~UIElement}.\n//\n// @private\n// @param {module:engine/view/writer~Writer} writer\n// @returns {module:engine/view/uielement~UIElement}\nfunction _createPlaceholder( writer ) {\n\tconst placeholder = writer.createUIElement( 'div', { class: 'ck-upload-placeholder-loader' } );\n\n\twriter.setCustomProperty( placeholderSymbol, true, placeholder );\n\n\treturn placeholder;\n}\n\n// Returns {@link module:engine/view/uielement~UIElement} of given unique property from image figure element.\n// Returns `undefined` if element is not found.\n//\n// @private\n// @param {module:engine/view/element~Element} imageFigure\n// @param {Symbol} uniqueProperty\n// @returns {module:engine/view/uielement~UIElement|undefined}\nfunction _getUIElement( imageFigure, uniqueProperty ) {\n\tfor ( const child of imageFigure.getChildren() ) {\n\t\tif ( child.getCustomProperty( uniqueProperty ) ) {\n\t\t\treturn child;\n\t\t}\n\t}\n}\n\n// Removes {@link module:engine/view/uielement~UIElement} of given unique property from image figure element.\n//\n// @private\n// @param {module:engine/view/element~Element} imageFigure\n// @param {module:engine/view/writer~Writer} writer\n// @param {Symbol} uniqueProperty\nfunction _removeUIElement( viewFigure, writer, uniqueProperty ) {\n\tconst element = _getUIElement( viewFigure, uniqueProperty );\n\n\tif ( element ) {\n\t\twriter.remove( ViewRange.createOn( element ) );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport ModelRange from '@ckeditor/ckeditor5-engine/src/model/range';\nimport ModelSelection from '@ckeditor/ckeditor5-engine/src/model/selection';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\n/**\n * @module image/imageupload/imageuploadcommand\n */\n\n/**\n * Image upload command.\n *\n * @extends module:core/command~Command\n */\nexport default class ImageUploadCommand extends Command {\n\t/**\n\t * Executes the command.\n\t *\n\t * @fires execute\n\t * @param {Object} options Options for the executed command.\n\t * @param {File} options.file The image file to upload.\n\t * @param {module:engine/model/position~Position} [options.insertAt] The position at which the image should be inserted.\n\t * If the position is not specified, the image will be inserted into the current selection.\n\t * Note: You can use the {@link module:upload/utils~findOptimalInsertionPosition} function to calculate\n\t * (e.g. based on the current selection) a position which is more optimal from the UX perspective.\n\t */\n\texecute( options ) {\n\t\tconst editor = this.editor;\n\t\tconst doc = editor.model.document;\n\t\tconst file = options.file;\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\n\t\teditor.model.change( writer => {\n\t\t\tconst loader = fileRepository.createLoader( file );\n\n\t\t\t// Do not throw when upload adapter is not set. FileRepository will log an error anyway.\n\t\t\tif ( !loader ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst imageElement = writer.createElement( 'image', {\n\t\t\t\tuploadId: loader.id\n\t\t\t} );\n\n\t\t\tlet insertAtSelection;\n\n\t\t\tif ( options.insertAt ) {\n\t\t\t\tinsertAtSelection = new ModelSelection( [ new ModelRange( options.insertAt ) ] );\n\t\t\t} else {\n\t\t\t\tinsertAtSelection = doc.selection;\n\t\t\t}\n\n\t\t\teditor.model.insertContent( imageElement, insertAtSelection );\n\n\t\t\t// Inserting an image might've failed due to schema regulations.\n\t\t\tif ( imageElement.parent ) {\n\t\t\t\twriter.setSelection( imageElement, 'on' );\n\t\t\t}\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module ui/notification/notification\n */\n\n/* globals window */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\n/**\n * The Notification plugin.\n *\n * This plugin sends few base types of notifications: `success`, `info` and `warning`. This notifications need to be\n * handled and displayed by plugin responsible for showing UI of the notifications. Using this plugin for dispatching\n * notifications makes possible to switch the notifications UI.\n *\n * Note that every unhandled and not stopped `warning` notification will be displayed as system alert.\n * See {@link module:ui/notification/notification~Notification#showWarning}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Notification extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Notification';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\t// Each unhandled and not stopped `show:warning` event is displayed as system alert.\n\t\tthis.on( 'show:warning', ( evt, data ) => {\n\t\t\twindow.alert( data.message ); // eslint-disable-line no-alert\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Shows success notification.\n\t *\n\t * At default it fires `show:success` event with given data but event namespace can be extended\n\t * by `data.namespace` option e.g.\n\t *\n\t * \t\tshowSuccess( 'Image is uploaded.', {\n\t * \t\t\tnamespace: 'upload:image'\n\t * \t\t} );\n\t *\n\t * will fire `show:success:upload:image` event.\n\t * Title of the notification can be provided:\n\t *\n\t *\t\tshowSuccess( 'Image is uploaded.', {\n\t *\t\t\ttitle: 'Image upload success'\n\t *\t\t});\n\t *\n\t * @param {String} message Content of the notification.\n\t * @param {Object} [data={}] Additional data.\n\t * @param {String} [data.namespace] Additional event namespace.\n\t * @param {String} [data.title] Title of the notification.\n\t */\n\tshowSuccess( message, data = {} ) {\n\t\tthis._showNotification( {\n\t\t\tmessage,\n\t\t\ttype: 'success',\n\t\t\tnamespace: data.namespace,\n\t\t\ttitle: data.title\n\t\t} );\n\t}\n\n\t/**\n\t * Shows info notification.\n\t *\n\t * At default it fires `show:info` event with given data but event namespace can be extended\n\t * by `data.namespace` option e.g.\n\t *\n\t * \t\tshowInfo( 'Editor is offline.', {\n\t * \t\t\tnamespace: 'editor:status'\n\t * \t\t} );\n\t *\n\t * will fire `show:info:editor:status` event.\n\t * Title of the notification can be provided:\n\t *\n\t *\t\tshowInfo( 'Editor is offline.', {\n\t *\t\t\ttitle: 'Network information'\n\t *\t\t});\n\t *\n\t * @param {String} message Content of the notification.\n\t * @param {Object} [data={}] Additional data.\n\t * @param {String} [data.namespace] Additional event namespace.\n\t * @param {String} [data.title] Title of the notification.\n\t */\n\tshowInfo( message, data = {} ) {\n\t\tthis._showNotification( {\n\t\t\tmessage,\n\t\t\ttype: 'info',\n\t\t\tnamespace: data.namespace,\n\t\t\ttitle: data.title\n\t\t} );\n\t}\n\n\t/**\n\t * Shows warning notification.\n\t *\n\t * At default it fires `show:warning` event with given data but event namespace can be extended\n\t * by `data.namespace` option e.g.\n\t *\n\t * \t\tshowWarning( 'Image upload error.', {\n\t * \t\t\tnamespace: 'upload:image'\n\t * \t\t} );\n\t *\n\t * will fire `show:warning:upload:image` event.\n\t * Title of the notification can be provided:\n\t *\n\t *\t\tshowWarning( 'Image upload error.', {\n\t *\t\t\ttitle: 'Upload failed'\n\t *\t\t});\n\t *\n\t * Note that each unhandled and not stopped `warning` notification will be displayed as system alert.\n\t * Plugin responsible for displaying warnings should `stop()` the event to prevent of displaying it as alert:\n\t *\n\t * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n\t * \t\t\t// Do something with data.\n\t *\n\t * \t\t\t// Stop this event to prevent of displaying as alert.\n\t * \t\t\tevt.stop();\n\t * \t\t} );\n\t *\n\t * You can attach many listeners to the same event and `stop()` this event in the listener with the low priority:\n\t *\n\t * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n\t * \t\t\t// Show warning in the UI, but not stop it.\n\t * \t\t} );\n\t *\n\t * \t\tnotifications.on( 'show:warning', ( evt, data ) => {\n\t * \t\t\t// Log warning to some error tracker.\n\t *\n\t * \t\t\t// Stop this event to prevent of displaying as alert.\n\t * \t\t\tevt.stop();\n\t * \t\t}, { priority: 'low' } );\n\t *\n\t * @param {String} message Content of the notification.\n\t * @param {Object} [data={}] Additional data.\n\t * @param {String} [data.namespace] Additional event namespace.\n\t * @param {String} [data.title] Title of the notification.\n\t */\n\tshowWarning( message, data = {} ) {\n\t\tthis._showNotification( {\n\t\t\tmessage,\n\t\t\ttype: 'warning',\n\t\t\tnamespace: data.namespace,\n\t\t\ttitle: data.title\n\t\t} );\n\t}\n\n\t/**\n\t * Fires `show` event with specified type, namespace and message.\n\t *\n\t * @private\n\t * @param {Object} data Message data.\n\t * @param {String} data.message Content of the notification.\n\t * @param {'success'|'info'|'warning'} data.type Type of message.\n\t * @param {String} [data.namespace] Additional event namespace.\n\t * @param {String} [data.title=''] Title of the notification.\n\t */\n\t_showNotification( data ) {\n\t\tconst event = `show:${ data.type }` + ( data.namespace ? `:${ data.namespace }` : '' );\n\n\t\tthis.fire( event, {\n\t\t\tmessage: data.message,\n\t\t\ttype: data.type,\n\t\t\ttitle: data.title || ''\n\t\t} );\n\t}\n\n\t/**\n\t * Fired when one of `showSuccess`, `showInfo`, `showWarning` methods is called.\n\t *\n\t * @event show\n\t * @param {Object} data Notification data.\n\t * @param {String} data.message Content of the notification.\n\t * @param {String} data.title Title of the notification.\n\t * @param {'success'|'info'|'warning'} data.type Type of notification.\n\t */\n\n\t/**\n\t * Fired when `showSuccess` method is called.\n\t *\n\t * @event show:success\n\t * @param {Object} data Notification data.\n\t * @param {String} data.message Content of the notification.\n\t * @param {String} data.title Title of the notification.\n\t * @param {'success'} data.type Type of notification.\n\t */\n\n\t/**\n\t * Fired when `showInfo` method is called.\n\t *\n\t * @event show:info\n\t * @param {Object} data Notification data.\n\t * @param {String} data.message Content of the notification.\n\t * @param {String} data.title Title of the notification.\n\t * @param {'info'} data.type Type of notification.\n\t */\n\n\t/**\n\t * Fired when `showWarning` method is called.\n\t *\n\t * When this event won't be handled and stopped by `event.stop()` then data.message of this event will\n\t * be automatically displayed as system alert.\n\t *\n\t * @event show:warning\n\t * @param {Object} data Notification data.\n\t * @param {String} data.message Content of the notification.\n\t * @param {String} data.title Title of the notification.\n\t * @param {'warning'} data.type Type of notification.\n\t */\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * @module image/imageupload/imageuploadediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport ImageUploadCommand from '../../src/imageupload/imageuploadcommand';\nimport Notification from '@ckeditor/ckeditor5-ui/src/notification/notification';\nimport ModelSelection from '@ckeditor/ckeditor5-engine/src/model/selection';\nimport ModelRange from '@ckeditor/ckeditor5-engine/src/model/range';\nimport {\n    isImageType,\n    findOptimalInsertionPosition\n} from '../../src/imageupload/utils';\n/**\n * Image upload editing plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUploadEditing extends Plugin {\n    /**\n\t * @inheritDoc\n\t */\n    static get requires() {\n        return [\n            FileRepository,\n            Notification\n        ];\n    }\n    /**\n\t * @inheritDoc\n\t */\n    init() {\n        const editor = this.editor;\n        const doc = editor.model.document;\n        const schema = editor.model.schema;\n        const fileRepository = editor.plugins.get(FileRepository);\n        // Setup schema to allow uploadId and uploadStatus for images.\n        schema.extend('image', {\n            allowAttributes: [\n                'uploadId',\n                'uploadStatus'\n            ]\n        });\n        // Register imageUpload command.\n        editor.commands.add('imageUpload', new ImageUploadCommand(editor));\n        // Execute imageUpload command when image is dropped or pasted.\n        this.listenTo(editor.editing.view.document, 'clipboardInput', (evt, data) => {\n            // Skip if non empty HTML data is included.\n            // https://github.com/ckeditor/ckeditor5-upload/issues/68\n            if (isHtmlIncluded(data.dataTransfer)) {\n                return;\n            }\n            let targetModelSelection = new ModelSelection(data.targetRanges.map(viewRange => editor.editing.mapper.toModelRange(viewRange)));\n            for (const file of data.dataTransfer.files) {\n                if (isImageType(file)) {\n                    const insertAt = findOptimalInsertionPosition(targetModelSelection);\n                    editor.model.change(writer => {\n                        const loader = fileRepository.createLoader(file);\n                        // Do not throw when upload adapter is not set. FileRepository will log an error anyway.\n                        if (!loader) {\n                            return;\n                        }\n                        const imageElement = writer.createElement('image', { uploadId: loader.id });\n                        const targetSelection = new ModelSelection([new ModelRange(insertAt)]);\n                        editor.model.insertContent(imageElement, targetSelection);\n                        // Inserting an image might've failed due to schema regulations.\n                        if (imageElement.parent) {\n                            writer.setSelection(imageElement, 'on');\n                        }\n                    });\n                    evt.stop();\n                }\n                // Use target ranges only for the first image. Then, use that image position\n                // so we keep adding the next ones after the previous one.\n                targetModelSelection = doc.selection;\n            }\n        });\n        // Prevents from browser redirecting to the dropped image.\n        editor.editing.view.document.on('dragover', (evt, data) => {\n            data.preventDefault();\n        });\n        doc.on('change', () => {\n            const changes = doc.differ.getChanges({ includeChangesInGraveyard: true });\n            for (const entry of changes) {\n                if (entry.type == 'insert' && entry.name == 'image') {\n                    const item = entry.position.nodeAfter;\n                    const isInGraveyard = entry.position.root.rootName == '$graveyard';\n                    // Check if the image element still has upload id.\n                    const uploadId = item.getAttribute('uploadId');\n                    if (!uploadId) {\n                        continue;\n                    }\n                    // Check if the image is loaded on this client.\n                    const loader = fileRepository.loaders.get(uploadId);\n                    if (!loader) {\n                        continue;\n                    }\n                    if (isInGraveyard) {\n                        // If the image was inserted to the graveyard - abort the loading process.\n                        loader.abort();\n                    } else if (loader.status == 'idle') {\n                        // If the image was inserted into content and has not been loaded, start loading it.\n                        this._load(loader, item);\n                    }\n                }\n            }\n        });\n    }\n    /**\n\t * Performs image loading. The image is read from the disk and temporary data is displayed. When the upload process\n\t * is complete the temporary data is replaced with the target image from the server.\n\t *\n\t * @private\n\t * @param {module:upload/filerepository~FileLoader} loader\n\t * @param {module:engine/model/element~Element} imageElement\n\t * @returns {Promise}\n\t */\n    _load(loader, imageElement) {\n        const editor = this.editor;\n        const model = editor.model;\n        const t = editor.locale.t;\n        const fileRepository = editor.plugins.get(FileRepository);\n        const notification = editor.plugins.get(Notification);\n        model.enqueueChange('transparent', writer => {\n            writer.setAttribute('uploadStatus', 'reading', imageElement);\n        });\n        return loader.read().then(data => {\n            const viewFigure = editor.editing.mapper.toViewElement(imageElement);\n            const viewImg = viewFigure.getChild(0);\n            const promise = loader.upload();\n            editor.editing.view.change(writer => {\n                writer.setAttribute('src', data, viewImg);\n            });\n            model.enqueueChange('transparent', writer => {\n                writer.setAttribute('uploadStatus', 'uploading', imageElement);\n            });\n            return promise;\n        }).then(data => {\n            model.enqueueChange('transparent', writer => {\n                writer.setAttributes({\n                    uploadStatus: 'complete',\n                    src: data.default\n                }, imageElement);\n                // Srcset attribute for responsive images support.\n                let maxWidth = 0;\n                const srcsetAttribute = Object.keys(data)    // Filter out keys that are not integers.\n.filter(key => {\n                    const width = parseInt(key, 10);\n                    if (!isNaN(width)) {\n                        maxWidth = Math.max(maxWidth, width);\n                        return true;\n                    }\n                })    // Convert each key to srcset entry.\n.map(key => `${ data[key] } ${ key }w`)    // Join all entries.\n.join(', ');\n                if (srcsetAttribute != '') {\n                    writer.setAttribute('srcset', {\n                        data: srcsetAttribute,\n                        width: maxWidth\n                    }, imageElement);\n                }\n            });\n            clean();\n        }).catch(error => {\n            // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n            // it might be generic error and it would be real pain to find what is going on.\n            if (loader.status !== 'error' && loader.status !== 'aborted') {\n                throw error;\n            }\n            // Might be 'aborted'.\n            if (loader.status == 'error') {\n                notification.showWarning(error, {\n                    title: t('Upload failed'),\n                    namespace: 'upload'\n                });\n            }\n            clean();\n            // Permanently remove image from insertion batch.\n            model.enqueueChange('transparent', writer => {\n                writer.remove(imageElement);\n            });\n        });\n        function clean() {\n            model.enqueueChange('transparent', writer => {\n                writer.removeAttribute('uploadId', imageElement);\n                writer.removeAttribute('uploadStatus', imageElement);\n            });\n            fileRepository.destroyLoader(loader);\n        }\n    }\n}\n// Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\nexport function isHtmlIncluded(dataTransfer) {\n    return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';\n}","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module image/imageupload\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ImageUploadUI from './imageupload/imageuploadui';\nimport ImageUploadProgress from './imageupload/imageuploadprogress';\nimport ImageUploadEditing from './imageupload/imageuploadediting';\n\n/**\n * The image upload plugin.\n *\n * This plugin does not do anything directly, but it loads a set of specific plugins to enable image uploading:\n * * {@link module:image/imageupload/imageuploadediting~ImageUploadEditing},\n * * {@link module:image/imageupload/imageuploadui~ImageUploadUI},\n * * {@link module:image/imageupload/imageuploadprogress~ImageUploadProgress}.\n *\n * For a detailed overview, check the {@glink features/image-upload image upload feature} documentation.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUpload extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageUpload';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageUploadEditing, ImageUploadUI, ImageUploadProgress ];\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n// WARNING: The URLs below should not be used for any other purpose than Easy Image plugin development.\n// Images uploaded using the testing token service may be deleted automatically at any moment.\n// If you would like to try the Easy Image service, please sign up for a free trial (https://ckeditor.com/ckeditor-cloud-services/).\n// Images uploaded during the free trial will not be deleted for the whole trial period and additionally the trial service can be converted\n// into a subscription at any moment, allowing you to preserve all uploaded images.\n\nexport const TOKEN_URL = 'https://33333.cke-cs.com/token/dev/ijrDsqFix838Gh3wGO3F77FSW94BwcLXprJ4APSp3XQ26xsUHTi0jcb1hoBt';\n\nexport const UPLOAD_URL = 'https://33333.cke-cs.com/easyimage/upload/';\n\nexport const CS_CONFIG = {\n\ttokenUrl: TOKEN_URL,\n\tuploadUrl: UPLOAD_URL\n};\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals $, window, console:false */\n\n// Basic classes to create an editor.\nimport Editor from '@ckeditor/ckeditor5-core/src/editor/editor';\nimport EditorUIView from '@ckeditor/ckeditor5-ui/src/editorui/editoruiview';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport ComponentFactory from '@ckeditor/ckeditor5-ui/src/componentfactory';\nimport InlineEditableUIView from '@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview';\nimport HtmlDataProcessor from '@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor';\nimport ElementReplacer from '@ckeditor/ckeditor5-utils/src/elementreplacer';\n\n// Interfaces to extend basic Editor API.\nimport DataApiMixin from '@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin';\nimport ElementApiMixin from '@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin';\n\n// Helper function for adding interfaces to the Editor class.\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n// Helper function that gets data from HTML element that the Editor is attached to.\nimport getDataFromElement from '@ckeditor/ckeditor5-utils/src/dom/getdatafromelement';\n\n// Helper function that binds editor with HTMLForm element.\nimport attachToForm from '@ckeditor/ckeditor5-core/src/editor/utils/attachtoform';\n\n// Basic features that every editor should enable.\nimport Clipboard from '@ckeditor/ckeditor5-clipboard/src/clipboard';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Typing from '@ckeditor/ckeditor5-typing/src/typing';\nimport Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';\nimport UndoEditing from '@ckeditor/ckeditor5-undo/src/undoediting';\n\n// Basic features to associated with the edited content.\nimport BoldEditing from '@ckeditor/ckeditor5-basic-styles/src/bold/boldediting';\nimport ItalicEditing from '@ckeditor/ckeditor5-basic-styles/src/italic/italicediting';\nimport UnderlineEditing from '@ckeditor/ckeditor5-basic-styles/src/underline/underlineediting';\nimport HeadingEditing from '@ckeditor/ckeditor5-heading/src/headingediting';\n\n// The easy image integration.\nimport EasyImage from '@ckeditor/ckeditor5-easy-image/src/easyimage';\nimport { CS_CONFIG } from '@ckeditor/ckeditor5-cloud-services/tests/_utils/cloud-services-config';\n\n// Extending the Editor class, which brings base editor API.\nexport default class BootstrapEditor extends Editor {\n\tconstructor( element, config ) {\n\t\tsuper( config );\n\n\t\t// Remember the element the editor is created with.\n\t\tthis.sourceElement = element;\n\n\t\t// Use the HTML data processor in this editor.\n\t\tthis.data.processor = new HtmlDataProcessor();\n\n\t\t// Create the (\"main\") root element of the model tree.\n\t\tthis.model.document.createRoot();\n\n\t\t// The UI layer of the editor.\n\t\tthis.ui = new BootstrapEditorUI( this );\n\n\t\t// When editor#element is a textarea inside a form element\n\t\t// then content of this textarea will be updated on form submit.\n\t\tattachToForm( this );\n\n\t\t// A helper to easily replace the editor#element with editor.editable#element.\n\t\tthis._elementReplacer = new ElementReplacer();\n\t}\n\n\tget element() {\n\t\treturn this.ui.view.element;\n\t}\n\n\tdestroy() {\n\t\t// When destroyed, editor sets the output of editor#getData() into editor#element...\n\t\tthis.updateSourceElement();\n\n\t\t// ...and restores the original editor#element...\n\t\tthis._elementReplacer.restore();\n\n\t\t// ...and destroys the UI.\n\t\tthis.ui.destroy();\n\n\t\treturn super.destroy();\n\t}\n\n\tstatic create( element, config ) {\n\t\treturn new Promise( resolve => {\n\t\t\tconst editor = new this( element, config );\n\t\t\tconst editable = editor.ui.view.editable;\n\n\t\t\tresolve(\n\t\t\t\teditor.initPlugins()\n\t\t\t\t\t.then( () => {\n\t\t\t\t\t\t// Initialize the UI first. See the BootstrapEditorUI class to learn more.\n\t\t\t\t\t\teditor.ui.init();\n\n\t\t\t\t\t\t// Replace the editor#element with editor.editable#element.\n\t\t\t\t\t\teditor._elementReplacer.replace( element, editable.element );\n\n\t\t\t\t\t\t// Tell the world that the UI of the editor is ready to use.\n\t\t\t\t\t\teditor.fire( 'uiReady' );\n\t\t\t\t\t} )\n\t\t\t\t\t// Bind the editor editing layer to the editable in DOM.\n\t\t\t\t\t.then( () => editor.editing.view.attachDomRoot( editable.element ) )\n\t\t\t\t\t// Fill the editable with the initial data.\n\t\t\t\t\t.then( () => editor.data.init( getDataFromElement( element ) ) )\n\t\t\t\t\t// Fire the events that announce that the editor is complete and ready to use.\n\t\t\t\t\t.then( () => {\n\t\t\t\t\t\teditor.fire( 'dataReady' );\n\t\t\t\t\t\teditor.fire( 'ready' );\n\t\t\t\t\t} )\n\t\t\t\t\t.then( () => editor )\n\t\t\t);\n\t\t} );\n\t}\n}\n\n// Mixing interfaces, which extends basic editor API.\nmix( BootstrapEditor, DataApiMixin );\nmix( BootstrapEditor, ElementApiMixin );\n\n// The class organizing the UI of the editor, binding it with existing Bootstrap elements in DOM.\nclass BootstrapEditorUI {\n\tconstructor( editor ) {\n\t\tthis.editor = editor;\n\n\t\t// The global UI view of the editor. It aggregates various Bootstrap DOM elements.\n\t\tconst view = this.view = new EditorUIView( editor.locale );\n\n\t\t// This is the main editor element in DOM.\n\t\tview.element = $( '.ck-editor' );\n\n\t\t// This is the editable view in DOM. It will replace the data container in DOM.\n\t\tview.editable = new InlineEditableUIView( editor.locale );\n\n\t\t// References to the dropdown elements for further usage. See #_setupBootstrapHeadingDropdown.\n\t\tview.dropdownMenu = view.element.find( '.dropdown-menu' );\n\t\tview.dropdownToggle = view.element.find( '.dropdown-toggle' );\n\n\t\t// References to the toolbar buttons for further usage. See #_setupBootstrapToolbarButtons.\n\t\tview.toolbarButtons = {};\n\n\t\t[ 'bold', 'italic', 'underline', 'undo', 'redo' ].forEach( name => {\n\t\t\t// Retrieve the jQuery object corresponding with the button in DOM.\n\t\t\tview.toolbarButtons[ name ] = view.element.find( `#${ name }` );\n\t\t} );\n\n\t\t// Mandatory EditorUI interface components.\n\t\tthis.componentFactory = new ComponentFactory( editor );\n\t\tthis.focusTracker = new FocusTracker();\n\t}\n\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = this.view;\n\n\t\t// Render the editable component in DOM first.\n\t\tview.editable.render();\n\n\t\t// Create an editing root in the editing layer. It will correspond with the\n\t\t// document root created in the constructor().\n\t\tconst editingRoot = editor.editing.view.document.getRoot();\n\n\t\t// Bind the basic attributes of the editable in DOM with the editing layer.\n\t\tview.editable.bind( 'isReadOnly' ).to( editingRoot );\n\t\tview.editable.bind( 'isFocused' ).to( editor.editing.view.document );\n\t\tview.editable.name = editingRoot.rootName;\n\n\t\t// Setup the existing, external Bootstrap UI so it works with the rest of the editor.\n\t\tthis._setupBootstrapToolbarButtons();\n\t\tthis._setupBootstrapHeadingDropdown();\n\t}\n\n\tdestroy() {\n\t\tthis.view.editable.destroy();\n\t}\n\n\t// This method activates Bold, Italic, Underline, Undo and Redo buttons in the toolbar.\n\t_setupBootstrapToolbarButtons() {\n\t\tconst editor = this.editor;\n\n\t\tfor ( const name in this.view.toolbarButtons ) {\n\t\t\t// Retrieve the editor command corresponding with the id of the button in DOM.\n\t\t\tconst command = editor.commands.get( name );\n\t\t\tconst button = this.view.toolbarButtons[ name ];\n\n\t\t\t// Clicking on the buttons should execute the editor command...\n\t\t\tbutton.click( () => editor.execute( name ) );\n\n\t\t\t// ...but it should not steal the focus so the editing is uninterrupted.\n\t\t\tbutton.mousedown( evt => evt.preventDefault() );\n\n\t\t\tconst onValueChange = () => {\n\t\t\t\tbutton.toggleClass( 'active', command.value );\n\t\t\t};\n\n\t\t\tconst onIsEnabledChange = () => {\n\t\t\t\tbutton.attr( 'disabled', () => !command.isEnabled );\n\t\t\t};\n\n\t\t\t// Commands can become disabled, e.g. when the editor is read-only.\n\t\t\t// Make sure the buttons reflect this state change.\n\t\t\tcommand.on( 'change:isEnabled', onIsEnabledChange );\n\t\t\tonIsEnabledChange();\n\n\t\t\t// Bold, Italic and Underline commands have a value that changes\n\t\t\t// when the selection starts in an element the command creates.\n\t\t\t// The button should indicate that e.g. editing text which is already bold.\n\t\t\tif ( !new Set( [ 'undo', 'redo' ] ).has( name ) ) {\n\t\t\t\tcommand.on( 'change:value', onValueChange );\n\t\t\t\tonValueChange();\n\t\t\t}\n\t\t}\n\t}\n\n\t// This method activates the headings dropdown in the toolbar.\n\t_setupBootstrapHeadingDropdown() {\n\t\tconst editor = this.editor;\n\t\tconst dropdownMenu = this.view.dropdownMenu;\n\t\tconst dropdownToggle = this.view.dropdownToggle;\n\n\t\t// Retrieve the editor commands for heading and paragraph.\n\t\tconst headingCommand = editor.commands.get( 'heading' );\n\t\tconst paragraphCommand = editor.commands.get( 'paragraph' );\n\n\t\t// Create a dropdown menu entry for each heading configuration option.\n\t\teditor.config.get( 'heading.options' ).map( option => {\n\t\t\t// Check is options is paragraph or heading as their commands slightly differ.\n\t\t\tconst isParagraph = option.model === 'paragraph';\n\n\t\t\t// Create the menu item DOM element.\n\t\t\tconst menuItem = $(\n\t\t\t\t`<a href=\"#\" class=\"dropdown-item heading-item_${ option.model }\">` +\n\t\t\t\t\t`${ option.title }` +\n\t\t\t\t'</a>'\n\t\t\t);\n\n\t\t\t// Upon click, the dropdown menu item should execute the command and focus\n\t\t\t// the editing view to keep the editing process uninterrupted.\n\t\t\tmenuItem.click( () => {\n\t\t\t\tconst commandName = isParagraph ? 'paragraph' : 'heading';\n\t\t\t\tconst commandValue = isParagraph ? undefined : { value: option.model };\n\n\t\t\t\teditor.execute( commandName, commandValue );\n\t\t\t\teditor.editing.view.focus();\n\t\t\t} );\n\n\t\t\tdropdownMenu.append( menuItem );\n\n\t\t\tconst command = isParagraph ? paragraphCommand : headingCommand;\n\n\t\t\t// Make sure the dropdown and its items reflect the state of the\n\t\t\t// currently active command.\n\t\t\tconst onValueChange = isParagraph ? onValueChangeParagraph : onValueChangeHeading;\n\t\t\tcommand.on( 'change:value', onValueChange );\n\t\t\tonValueChange();\n\n\t\t\t// Heading commands can become disabled, e.g. when the editor is read-only.\n\t\t\t// Make sure the UI reflects this state change.\n\t\t\tcommand.on( 'change:isEnabled', onIsEnabledChange );\n\n\t\t\tonIsEnabledChange();\n\n\t\t\tfunction onValueChangeHeading() {\n\t\t\t\tconst isActive = !isParagraph && command.value === option.model;\n\n\t\t\t\tif ( isActive ) {\n\t\t\t\t\tdropdownToggle.children( ':first' ).text( option.title );\n\t\t\t\t}\n\n\t\t\t\tmenuItem.toggleClass( 'active', isActive );\n\t\t\t}\n\n\t\t\tfunction onValueChangeParagraph() {\n\t\t\t\tif ( command.value ) {\n\t\t\t\t\tdropdownToggle.children( ':first' ).text( option.title );\n\t\t\t\t}\n\n\t\t\t\tmenuItem.toggleClass( 'active', command.value );\n\t\t\t}\n\n\t\t\tfunction onIsEnabledChange() {\n\t\t\t\tdropdownToggle.attr( 'disabled', () => !command.isEnabled );\n\t\t\t}\n\t\t} );\n\t}\n}\n\n// Finally, create the BootstrapEditor instance with a selected set of features.\nBootstrapEditor\n\t.create( $( '#editor' ).get( 0 ), {\n\t\tplugins: [\n\t\t\tClipboard, Enter, Typing, Paragraph, EasyImage,\n\t\t\tBoldEditing, ItalicEditing, UnderlineEditing, HeadingEditing, UndoEditing\n\t\t],\n\t\tcloudServices: CS_CONFIG\n\t} )\n\t.then( editor => {\n\t\twindow.editor = editor;\n\n\t\t$( '#toggle-readonly' ).on( 'click', () => {\n\t\t\teditor.isReadOnly = !editor.isReadOnly;\n\t\t} );\n\t} )\n\t.catch( err => {\n\t\tconsole.error( err.stack );\n\t} );\n","/**\n * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport isFunction from '@ckeditor/ckeditor5-utils/src/lib/lodash/isFunction';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * @module core/editor/utils/attachtoform\n */\n\n/**\n * Checks if the editor is initialized on a `<textarea>` element that belongs to a form. If yes, it updates the editor's element\n * content before submitting the form.\n *\n * This helper requires the {@link module:core/editor/utils/elementapimixin~ElementApi ElementApi interface}.\n *\n * @param {module:core/editor/editor~Editor} editor Editor instance.\n */\nexport default function attachToForm( editor ) {\n\tif ( !isFunction( editor.updateSourceElement ) ) {\n\t\t/**\n\t\t * The editor passed to `attachToForm()` must implement the\n\t\t * {@link module:core/editor/utils/elementapimixin~ElementApi} interface.\n\t\t *\n\t\t * @error attachtoform-missing-elementapi-interface\n\t\t */\n\t\tthrow new CKEditorError( 'attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.' );\n\t}\n\n\tconst sourceElement = editor.sourceElement;\n\n\t// Only when replacing a textarea which is inside of a form element.\n\tif ( sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.form ) {\n\t\tlet originalSubmit;\n\t\tconst form = sourceElement.form;\n\t\tconst onSubmit = () => editor.updateSourceElement();\n\n\t\t// Replace the original form#submit() to call a custom submit function first.\n\t\t// Check if #submit is a function because the form might have an input named \"submit\".\n\t\tif ( isFunction( form.submit ) ) {\n\t\t\toriginalSubmit = form.submit;\n\n\t\t\tform.submit = () => {\n\t\t\t\tonSubmit();\n\t\t\t\toriginalSubmit.apply( form );\n\t\t\t};\n\t\t}\n\n\t\t// Update the replaced textarea with data before each form#submit event.\n\t\tform.addEventListener( 'submit', onSubmit );\n\n\t\t// Remove the submit listener and revert the original submit method on\n\t\t// editor#destroy.\n\t\teditor.on( 'destroy', () => {\n\t\t\tform.removeEventListener( 'submit', onSubmit );\n\n\t\t\tif ( originalSubmit ) {\n\t\t\t\tform.submit = originalSubmit;\n\t\t\t}\n\t\t} );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals HTMLTextAreaElement */\n\n/**\n * @module utils/dom/getdatafromelement\n */\n\n/**\n * Gets data from a given source element.\n *\n * @param {HTMLElement} el The element from which the data will be retrieved.\n * @returns {String} The data string.\n */\nexport default function getDataFromElement( el ) {\n\tif ( el instanceof HTMLTextAreaElement ) {\n\t\treturn el.value;\n\t}\n\n\treturn el.innerHTML;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/clipboard\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\nimport ClipboardObserver from './clipboardobserver';\n\nimport plainTextToHtml from './utils/plaintexttohtml';\nimport normalizeClipboardHtml from './utils/normalizeclipboarddata';\nimport viewToPlainText from './utils/viewtoplaintext.js';\n\nimport HtmlDataProcessor from '@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor';\n\n/**\n * The clipboard feature. Currently, it's responsible for intercepting the `paste` and `drop` events and\n * passing the pasted content through the clipboard pipeline.\n *\n * # Clipboard input pipeline\n *\n * The feature creates the clipboard input pipeline which allows processing clipboard content\n * before it gets inserted into the editor. The pipeline consists of two events on which\n * the features can listen in order to modify or totally override the default behavior.\n *\n * ## On {@link module:engine/view/document~Document#event:paste} and {@link module:engine/view/document~Document#event:drop}\n *\n * The default action is to:\n *\n * 1. get HTML or plain text from the clipboard,\n * 2. prevent the default action of the native `paste` or `drop` event,\n * 3. fire {@link module:engine/view/document~Document#event:clipboardInput} with a\n * {@link module:clipboard/datatransfer~DataTransfer `dataTransfer`} property.\n * 4. fire {@link module:clipboard/clipboard~Clipboard#event:inputTransformation} with a `data` containing the clipboard data parsed to\n * a {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n *\n * These action are performed by a low priority listeners, so they can be overridden by a normal ones\n * when a deeper change in pasting behavior is needed. For example, a feature which wants to differently read\n * data from the clipboard (the {@link module:clipboard/datatransfer~DataTransfer `DataTransfer`}).\n * should plug a listener at this stage.\n *\n * ## On {@link module:engine/view/document~Document#event:clipboardInput}\n *\n * This action is performed by a low priority listener, so it can be overridden by a normal one.\n *\n * At this stage the dataTransfer object can be processed by the features, which want to transform the original dataTransform.\n *\n *\t\tthis.listenTo( editor.editing.view, 'clipboardInput', ( evt, data ) => {\n *\t\t\tconst content = customTransform( data.dataTransfer.get( 'text/html' ) );\n *\t\t\tconst transformedContent = transform( content );\n *\t\t\tdata.dataTransfer.set( 'text/html', transformedContent );\n *\t\t} );\n *\n * ## On {@link module:clipboard/clipboard~Clipboard#event:inputTransformation}\n *\n * The default action is to insert the content (`data.content`, represented by a\n * {@link module:engine/view/documentfragment~DocumentFragment}) to an editor if the data is not empty.\n *\n * This action is performed by a low priority listener, so it can be overridden by a normal one.\n *\n * At this stage the pasted content can be processed by the features. E.g. a feature which wants to transform\n * a pasted text into a link can be implemented in this way:\n *\n *\t\tthis.listenTo( editor.plugins.get( 'Clipboard' ), 'inputTransformation', ( evt, data ) => {\n *\t\t\tif ( data.content.childCount == 1 && isUrlText( data.content.getChild( 0 ) ) ) {\n *\t\t\t\tconst linkUrl = data.content.getChild( 0 ).data;\n *\n *\t\t\t\tdata.content = new ViewDocumentFragment( [\n *\t\t\t\t\tViewElement(\n *\t\t\t\t\t\t'a',\n *\t\t\t\t\t\t{ href: linkUrl },\n *\t\t\t\t\t\t[ new ViewText( linkUrl ) ]\n *\t\t\t\t\t)\n *\t\t\t\t] );\n *\t\t\t}\n *\t\t} );\n *\n * # Clipboard output pipeline\n *\n * The output pipeline is the equivalent of the input pipeline but for the copy and cut operations.\n * It allows to process the content which will be then put into the clipboard or to override the whole process.\n *\n * ## On {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}\n *\n * The default action is to:\n *\n * 1. {@link module:engine/model/model~Model#getSelectedContent get selected content} from the editor,\n * 2. prevent the default action of the native `copy` or `cut` event,\n * 3. fire {@link module:engine/view/document~Document#event:clipboardOutput} with a clone of the selected content\n * converted to a {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n *\n * ## On {@link module:engine/view/document~Document#event:clipboardOutput}\n *\n * The default action is to put the content (`data.content`, represented by a\n * {@link module:engine/view/documentfragment~DocumentFragment}) to the clipboard as HTML. In case of the cut operation,\n * the selected content is also deleted from the editor.\n *\n * This action is performed by a low priority listener, so it can be overridden by a normal one.\n *\n * At this stage the copied/cut content can be processed by the features.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Clipboard extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Clipboard';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst modelDocument = editor.model.document;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t/**\n\t\t * Data processor used to convert pasted HTML to a view structure.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #_htmlDataProcessor\n\t\t */\n\t\tthis._htmlDataProcessor = new HtmlDataProcessor();\n\n\t\tview.addObserver( ClipboardObserver );\n\n\t\t// The clipboard paste pipeline.\n\n\t\t// Pasting and dropping is disabled when editor is read-only.\n\t\t// See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n\t\tthis.listenTo( viewDocument, 'clipboardInput', evt => {\n\t\t\tif ( editor.isReadOnly ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.listenTo( viewDocument, 'clipboardInput', ( evt, data ) => {\n\t\t\tconst dataTransfer = data.dataTransfer;\n\t\t\tlet content = '';\n\n\t\t\tif ( dataTransfer.getData( 'text/html' ) ) {\n\t\t\t\tcontent = normalizeClipboardHtml( dataTransfer.getData( 'text/html' ) );\n\t\t\t} else if ( dataTransfer.getData( 'text/plain' ) ) {\n\t\t\t\tcontent = plainTextToHtml( dataTransfer.getData( 'text/plain' ) );\n\t\t\t}\n\n\t\t\tcontent = this._htmlDataProcessor.toView( content );\n\n\t\t\tthis.fire( 'inputTransformation', { content } );\n\n\t\t\tview.scrollToTheSelection();\n\t\t}, { priority: 'low' } );\n\n\t\tthis.listenTo( this, 'inputTransformation', ( evt, data ) => {\n\t\t\tif ( !data.content.isEmpty ) {\n\t\t\t\tconst dataController = this.editor.data;\n\t\t\t\tconst model = this.editor.model;\n\n\t\t\t\t// Convert the pasted content to a model document fragment.\n\t\t\t\t// Conversion is contextual, but in this case we need an \"all allowed\" context and for that\n\t\t\t\t// we use the $clipboardHolder item.\n\t\t\t\tconst modelFragment = dataController.toModel( data.content, '$clipboardHolder' );\n\n\t\t\t\tif ( modelFragment.childCount == 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmodel.insertContent( modelFragment, modelDocument.selection );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// The clipboard copy/cut pipeline.\n\n\t\tfunction onCopyCut( evt, data ) {\n\t\t\tconst dataTransfer = data.dataTransfer;\n\n\t\t\tdata.preventDefault();\n\n\t\t\tconst content = editor.data.toView( editor.model.getSelectedContent( modelDocument.selection ) );\n\n\t\t\tviewDocument.fire( 'clipboardOutput', { dataTransfer, content, method: evt.name } );\n\t\t}\n\n\t\tthis.listenTo( viewDocument, 'copy', onCopyCut, { priority: 'low' } );\n\t\tthis.listenTo( viewDocument, 'cut', ( evt, data ) => {\n\t\t\t// Cutting is disabled when editor is read-only.\n\t\t\t// See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n\t\t\tif ( editor.isReadOnly ) {\n\t\t\t\tdata.preventDefault();\n\t\t\t} else {\n\t\t\t\tonCopyCut( evt, data );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\tthis.listenTo( viewDocument, 'clipboardOutput', ( evt, data ) => {\n\t\t\tif ( !data.content.isEmpty ) {\n\t\t\t\tdata.dataTransfer.setData( 'text/html', this._htmlDataProcessor.toData( data.content ) );\n\t\t\t\tdata.dataTransfer.setData( 'text/plain', viewToPlainText( data.content ) );\n\t\t\t}\n\n\t\t\tif ( data.method == 'cut' ) {\n\t\t\t\teditor.model.deleteContent( modelDocument.selection );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t}\n}\n\n/**\n * Fired with a `content`, which comes from the clipboard (was pasted or dropped) and\n * should be processed in order to be inserted into the editor.\n * It's part of the {@link module:clipboard/clipboard~Clipboard \"clipboard pipeline\"}.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:clipboard/clipboard~Clipboard#event:inputTransformation\n * @param {Object} data Event data.\n * @param {module:engine/view/documentfragment~DocumentFragment} data.content Event data. Content to be inserted into the editor.\n * It can be modified by the event listeners. Read more about the clipboard pipelines in {@link module:clipboard/clipboard~Clipboard}\n */\n\n/**\n * Fired on {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}\n * with a copy of selected content. The content can be processed before it ends up in the clipboard.\n * It's part of the {@link module:clipboard/clipboard~Clipboard \"clipboard pipeline\"}.\n *\n * @see module:clipboard/clipboardobserver~ClipboardObserver\n * @see module:clipboard/clipboard~Clipboard\n * @event module:engine/view/document~Document#event:clipboardOutput\n * @param {module:clipboard/clipboard~ClipboardOutputEventData} data Event data.\n */\n\n/**\n * The value of the {@link module:engine/view/document~Document#event:clipboardOutput} event.\n *\n * @class module:clipboard/clipboard~ClipboardOutputEventData\n */\n\n/**\n * Data transfer instance.\n *\n * @readonly\n * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboard~ClipboardOutputEventData#dataTransfer\n */\n\n/**\n * Content to be put into the clipboard. It can be modified by the event listeners.\n * Read more about the clipboard pipelines in {@link module:clipboard/clipboard~Clipboard}.\n *\n * @member {module:engine/view/documentfragment~DocumentFragment} module:clipboard/clipboard~ClipboardOutputEventData#content\n */\n\n/**\n * Whether the event was triggered by copy or cut operation.\n *\n * @member {'copy'|'cut'} module:clipboard/clipboard~ClipboardOutputEventData#method\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/utils/normalizeclipboarddata\n */\n\n/**\n * Removes some popular browser quirks out of the clipboard data (HTML).\n *\n * @param {String} data The HTML data to normalize.\n * @returns {String} Normalized HTML.\n */\nexport default function normalizeClipboardData( data ) {\n\treturn data\n\t\t.replace( /<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, ( fullMatch, spaces ) => {\n\t\t\t// Handle the most popular and problematic case when even a single space becomes an nbsp;.\n\t\t\t// Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.\n\t\t\tif ( spaces.length == 1 ) {\n\t\t\t\treturn ' ';\n\t\t\t}\n\n\t\t\treturn spaces;\n\t\t} );\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module clipboard/utils/plaintexttohtml\n */\n\n/**\n * Converts plain text to its HTML-ized version.\n *\n * @param {String} text The plain text to convert.\n * @returns {String} HTML generated from the plain text.\n */\nexport default function plainTextToHtml( text ) {\n\ttext = text\n\t\t// Encode <>.\n\t\t.replace( /</g, '&lt;' )\n\t\t.replace( />/g, '&gt;' )\n\t\t// Creates paragraphs for double line breaks and change single line breaks to <br>s.\n\t\t.replace( /\\n\\n/g, '</p><p>' )\n\t\t.replace( /\\n/g, '<br>' )\n\t\t// Preserve trailing spaces (only the first and last one – the rest is handled below).\n\t\t.replace( /^\\s/, '&nbsp;' )\n\t\t.replace( /\\s$/, '&nbsp;' )\n\t\t// Preserve other subsequent spaces now.\n\t\t.replace( /\\s\\s/g, ' &nbsp;' );\n\n\tif ( text.indexOf( '</p><p>' ) > -1 ) {\n\t\t// If we created paragraphs above, add the trailing ones.\n\t\ttext = `<p>${ text }</p>`;\n\t}\n\n\t// TODO:\n\t// * What about '\\nfoo' vs ' foo'?\n\n\treturn text;\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module enter/enter\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport EnterCommand from './entercommand';\nimport EnterObserver from './enterobserver';\n\n/**\n * This plugin handles the <kbd>Enter</kbd> key (hard line break) in the editor.\n *\n * See also the {@link module:enter/shiftenter~ShiftEnter} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Enter extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Enter';\n\t}\n\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\tview.addObserver( EnterObserver );\n\n\t\teditor.commands.add( 'enter', new EnterCommand( editor ) );\n\n\t\tthis.listenTo( viewDocument, 'enter', ( evt, data ) => {\n\t\t\t// The soft enter key is handled by the ShiftEnter plugin.\n\t\t\tif ( data.isSoft ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor.execute( 'enter' );\n\t\t\tdata.preventDefault();\n\t\t\tview.scrollToTheSelection();\n\t\t}, { priority: 'low' } );\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module typing/typing\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Input from './input';\nimport Delete from './delete';\n\n/**\n * The typing feature. It handles typing.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Typing extends Plugin {\n\tstatic get requires() {\n\t\treturn [ Input, Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Typing';\n\t}\n}\n\n/**\n * The configuration of the typing features. Used by the features from the `@ckeditor/ckeditor5-typing` package.\n *\n * Read more in {@link module:typing/typing~TypingConfig}.\n *\n * @member {module:typing/typing~TypingConfig} module:core/editor/editorconfig~EditorConfig#typing\n */\n\n/**\n * The configuration of the typing features. Used by the typing features in `@ckeditor/ckeditor5-typing` package.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n * \t\t\t\ttyping: ... // Typing feature options.\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.\n *\n * @interface TypingConfig\n */\n\n/**\n * The granularity of undo/redo for typing and deleting. The value `20` means (more or less) that a new undo step\n * is created every 20 characters are inserted or deleted.\n *\n * @member {Number} [module:typing/typing~TypingConfig#undoStep=20]\n */\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module easy-image/easyimage\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport CloudServicesUploadAdapter from './cloudservicesuploadadapter';\nimport Image from '@ckeditor/ckeditor5-image/src/image';\nimport ImageUpload from '@ckeditor/ckeditor5-image/src/imageupload';\n\n/**\n * The Easy Image feature.\n *\n * This plugin enables:\n *\n * * {@link module:image/image~Image},\n * * {@link module:image/imageupload~ImageUpload},\n * * {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter}.\n *\n * After enabling the Easy Image plugin you need to configure the [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/)\n * integration through {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudServices`}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class EasyImage extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [\n\t\t\tCloudServicesUploadAdapter,\n\t\t\tImage,\n\t\t\tImageUpload\n\t\t];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'EasyImage';\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2018, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * @module undo/undoediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport UndoCommand from './undocommand';\nimport RedoCommand from './redocommand';\n\n/**\n * The undo engine feature.\n *\n * Undo brings in possibility to undo and redo changes done in the model by deltas through\n * the {@link module:engine/model/writer~Writer Writer API}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class UndoEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The command that manages undo {@link module:engine/model/batch~Batch batches} stack (history).\n\t\t * Created and registered during the {@link #init feature initialization}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:undo/undocommand~UndoCommand} #_undoCommand\n\t\t */\n\n\t\t/**\n\t\t * The command that manages redo {@link module:engine/model/batch~Batch batches} stack (history).\n\t\t * Created and registered during the {@link #init feature initialization}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:undo/undocommand~UndoCommand} #_redoCommand\n\t\t */\n\n\t\t/**\n\t\t * Keeps track of which batches were registered in undo.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakSet.<module:engine/model/batch~Batch>}\n\t\t */\n\t\tthis._batchRegistry = new WeakSet();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Create commands.\n\t\tthis._undoCommand = new UndoCommand( editor );\n\t\tthis._redoCommand = new RedoCommand( editor );\n\n\t\t// Register command to the editor.\n\t\teditor.commands.add( 'undo', this._undoCommand );\n\t\teditor.commands.add( 'redo', this._redoCommand );\n\n\t\tthis.listenTo( editor.model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\t// Do not register batch if the operation is not a document operation.\n\t\t\t// This prevents from creating empty undo steps, where all operations where non-document operations.\n\t\t\t// Non-document operations creates and alters content in detached tree fragments (for example, document fragments).\n\t\t\t// Most of time this is preparing data before it is inserted into actual tree (for example during copy & paste).\n\t\t\t// Such operations should not be reversed.\n\t\t\tif ( !operation.isDocumentOperation ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst batch = operation.delta.batch;\n\n\t\t\t// If changes are not a part of a batch or this is not a new batch, omit those changes.\n\t\t\tif ( this._batchRegistry.has( batch ) || batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif ( this._redoCommand._createdBatches.has( batch ) ) {\n\t\t\t\t\t// If this batch comes from `redoCommand`, add it to `undoCommand` stack.\n\t\t\t\t\tthis._undoCommand.addBatch( batch );\n\t\t\t\t} else if ( !this._undoCommand._createdBatches.has( batch ) ) {\n\t\t\t\t\t// A default batch - these are new changes in the document, not introduced by undo feature.\n\t\t\t\t\t// Add them to `undoCommand` stack and clear `redoCommand` stack.\n\t\t\t\t\tthis._undoCommand.addBatch( batch );\n\t\t\t\t\tthis._redoCommand.clearStack();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the batch to the registry so it will not be processed again.\n\t\t\tthis._batchRegistry.add( batch );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.listenTo( this._undoCommand, 'revert', ( evt, undoneBatch, undoingBatch ) => {\n\t\t\tthis._redoCommand.addBatch( undoingBatch );\n\t\t} );\n\n\t\teditor.keystrokes.set( 'CTRL+Z', 'undo' );\n\t\teditor.keystrokes.set( 'CTRL+Y', 'redo' );\n\t\teditor.keystrokes.set( 'CTRL+SHIFT+Z', 'redo' );\n\t}\n}\n"],"sourceRoot":""}